<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Linux Standard Base Core Specification 3.1</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Linux Standard Base Core Specification 3.1</A
></H1
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2004, 2005 Free Standards Group</P
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="LEGAL"
></A
><P
>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1;
with no Invariant Sections, with no Front-Cover Texts, and with no
Back-Cover Texts.  A copy of the license is included in the section
entitled "GNU Free Documentation License".</P
><P
></P
></DIV
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN10"
></A
><P
>Portions of the text are copyrighted by the following parties:</P
><P
></P
><UL
><LI
><P
>The Regents of the University of California</P
></LI
><LI
><P
>Free Software Foundation</P
></LI
><LI
><P
>Ian F. Darwin</P
></LI
><LI
><P
>Paul Vixie</P
></LI
><LI
><P
>BSDI (now Wind River)</P
></LI
><LI
><P
>Andrew G Morgan</P
></LI
><LI
><P
>Jean-loup Gailly and Mark Adler</P
></LI
><LI
><P
>Massachusetts Institute of Technology</P
></LI
></UL
><P
>These excerpts are being used in accordance
with their respective licenses.</P
><P
>Linux is a trademark of Linus Torvalds.</P
><P
>UNIX a registered trademark of the Open Group in the United States and
other countries.</P
><P
>LSB is a trademark of the Free Standards Group in the USA and other countries.</P
><P
>AMD is a trademark of Advanced Micro Devices, Inc.</P
><P
>Intel and Itanium are registered trademarks and Intel386
is a trademarks of Intel Corporation.</P
><P
>PowerPC and PowerPC Architecture are trademarks of the IBM Corporation. </P
><P
>OpenGL is a registered trademark of Silicon Graphics, Inc.</P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#OVERVIEW"
>Foreword</A
></DT
><DT
><A
HREF="#INTRO"
>Introduction</A
></DT
><DT
>I. <A
HREF="#TOCINTRO"
>Introductory Elements</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#SCOPE"
>Scope</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#GENSCOPE"
>General</A
></DT
><DT
>1.2. <A
HREF="#MODSCOPE"
>Module Specific Scope</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#NORMATIVEREFS"
>References</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#NORMATIVEREFSSECT"
>Normative References</A
></DT
><DT
>2.2. <A
HREF="#INFORMATIVEREFS"
>Informative References/Bibliography</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#REQUIREMENTS"
>Requirements</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#RLIBRARIES"
>Relevant Libraries</A
></DT
><DT
>3.2. <A
HREF="#IMPLEMENTATION"
>LSB Implementation Conformance</A
></DT
><DT
>3.3. <A
HREF="#APPLICATION"
>LSB Application Conformance</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#DEF"
>Definitions</A
></DT
><DT
>5. <A
HREF="#TERMS"
>Terminology</A
></DT
><DT
>6. <A
HREF="#DOCCONV"
>Documentation Conventions</A
></DT
><DT
>7. <A
HREF="#POSIXCONFLICTS"
>Relationship To ISO/IEC 9945 POSIX</A
></DT
><DT
>8. <A
HREF="#RELTOFSG"
>Relationship To Other Free Standards Group Specifications</A
></DT
></DL
></DD
><DT
>II. <A
HREF="#ELF-GENERIC"
>Executable And Linking Format (ELF)</A
></DT
><DD
><DL
><DT
>9. <A
HREF="#ELFINTRO"
>Introduction</A
></DT
><DT
>10. <A
HREF="#LOWLEVEL"
>Low Level System Information</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#OSINTERFACE"
>Operating System Interface</A
></DT
><DT
>10.2. <A
HREF="#MACHINEINTERFACE"
>Machine Interface</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#TOCOBJFORMAT"
>Object Format</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#OBJFMT"
>Object Files</A
></DT
><DT
>11.2. <A
HREF="#SECTIONS"
>Sections</A
></DT
><DT
>11.3. <A
HREF="#SPECIALSECTIONS"
>Special Sections</A
></DT
><DT
>11.4. <A
HREF="#SYMMAP"
>Symbol Mapping</A
></DT
><DT
>11.5. <A
HREF="#DWARFEXT"
>DWARF Extensions</A
></DT
><DT
>11.6. <A
HREF="#EHFRAMECHPT"
>Exception Frames</A
></DT
><DT
>11.7. <A
HREF="#SYMVERSION"
>Symbol Versioning</A
></DT
><DT
>11.8. <A
HREF="#NOTEABITAG"
>ABI note tag</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#TOCDYNLNK"
>Dynamic Linking</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#DYNLNK"
>Program Loading and Dynamic Linking</A
></DT
><DT
>12.2. <A
HREF="#PROGHEADER"
>Program Header</A
></DT
><DT
>12.3. <A
HREF="#DYNAMICSECTION"
>Dynamic Entries</A
></DT
></DL
></DD
></DL
></DD
><DT
>III. <A
HREF="#TOCBASELIB"
>Base Libraries</A
></DT
><DD
><DL
><DT
>13. <A
HREF="#BASELIB"
>Base Libraries</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#AEN1989"
>Introduction</A
></DT
><DT
>13.2. <A
HREF="#PROGINTERP"
>Program Interpreter</A
></DT
><DT
>13.3. <A
HREF="#LIBC"
>Interfaces for libc</A
></DT
><DT
>13.4. <A
HREF="#LIBC-DDEFS"
>Data Definitions for libc</A
></DT
><DT
>13.5. <A
HREF="#LIBCMAN"
>Interface Definitions for libc</A
></DT
><DT
>13.6. <A
HREF="#LIBM"
>Interfaces for libm</A
></DT
><DT
>13.7. <A
HREF="#LIBM-DDEFS"
>Data Definitions for libm</A
></DT
><DT
>13.8. <A
HREF="#LIBMMAN"
>Interface Definitions for libm</A
></DT
><DT
>13.9. <A
HREF="#LIBPTHREAD"
>Interfaces for libpthread</A
></DT
><DT
>13.10. <A
HREF="#LIBPTHREAD-DDEFS"
>Data Definitions for libpthread</A
></DT
><DT
>13.11. <A
HREF="#LIBPTHREADMAN"
>Interface Definitions for libpthread</A
></DT
><DT
>13.12. <A
HREF="#LIBGCC-S"
>Interfaces for libgcc_s</A
></DT
><DT
>13.13. <A
HREF="#LIBGCC-S-DDEFS"
>Data Definitions for libgcc_s</A
></DT
><DT
>13.14. <A
HREF="#LIBDL"
>Interfaces for libdl</A
></DT
><DT
>13.15. <A
HREF="#LIBDL-DDEFS"
>Data Definitions for libdl</A
></DT
><DT
>13.16. <A
HREF="#LIBDLMAN"
>Interface Definitions for libdl</A
></DT
><DT
>13.17. <A
HREF="#LIBRT"
>Interfaces for librt</A
></DT
><DT
>13.18. <A
HREF="#LIBCRYPT"
>Interfaces for libcrypt</A
></DT
><DT
>13.19. <A
HREF="#LIBPAM"
>Interfaces for libpam</A
></DT
><DT
>13.20. <A
HREF="#LIBPAM-DDEFS"
>Data Definitions for libpam</A
></DT
><DT
>13.21. <A
HREF="#LIBPAMMAN"
>Interface Definitions for libpam</A
></DT
></DL
></DD
></DL
></DD
><DT
>IV. <A
HREF="#TOCUTILLIB"
>Utility Libraries</A
></DT
><DD
><DL
><DT
>14. <A
HREF="#UTILLIB"
>Utility Libraries</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN16599"
>Introduction</A
></DT
><DT
>14.2. <A
HREF="#LIBZ"
>Interfaces for libz</A
></DT
><DT
>14.3. <A
HREF="#LIBZ-DDEFS"
>Data Definitions for libz</A
></DT
><DT
>14.4. <A
HREF="#LIBZMAN"
>Interface Definitions for libz</A
></DT
><DT
>14.5. <A
HREF="#LIBNCURSES"
>Interfaces for libncurses</A
></DT
><DT
>14.6. <A
HREF="#LIBNCURSES-DDEFS"
>Data Definitions for libncurses</A
></DT
><DT
>14.7. <A
HREF="#LIBUTIL"
>Interfaces for libutil</A
></DT
><DT
>14.8. <A
HREF="#LIBUTILMAN"
>Interface Definitions for libutil</A
></DT
></DL
></DD
></DL
></DD
><DT
>V. <A
HREF="#TOCCOMMAND"
>Commands and Utilities</A
></DT
><DD
><DL
><DT
>15. <A
HREF="#COMMAND"
>Commands and Utilities</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#CMDUTIL"
>Commands and Utilities</A
></DT
><DT
>15.2. <A
HREF="#CMDBEHAV"
>Command Behavior</A
></DT
></DL
></DD
></DL
></DD
><DT
>VI. <A
HREF="#TOCEXECENV"
>Execution Environment</A
></DT
><DD
><DL
><DT
>16. <A
HREF="#EXECENVFHS"
>File System Hierarchy</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#DEV"
><TT
CLASS="FILENAME"
>/dev</TT
>: Device Files</A
></DT
><DT
>16.2. <A
HREF="#ETC"
><TT
CLASS="FILENAME"
>/etc</TT
>: Host-specific system configuration</A
></DT
><DT
>16.3. <A
HREF="#FHS-USER-ACCOUNTING-DBS"
>User Accounting Databases</A
></DT
><DT
>16.4. <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
></DT
></DL
></DD
><DT
>17. <A
HREF="#EXECSTUFF"
>Additional Recommendations</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#PERMISSIONS-SHOULD"
>Recommendations for applications on ownership and permissions</A
></DT
></DL
></DD
><DT
>18. <A
HREF="#EXECENV-ADDNTL-BHVR"
>Additional Behaviors</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#AEN25313"
>Mandatory Optional Behaviors</A
></DT
></DL
></DD
><DT
>19. <A
HREF="#LOCALIZATION"
>Localization</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#AEN25424"
>Introduction</A
></DT
><DT
>19.2. <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
></DT
><DT
>19.3. <A
HREF="#LOCALIZATION-GLOB"
>Pattern Matching Notation</A
></DT
></DL
></DD
></DL
></DD
><DT
>VII. <A
HREF="#TOCSYSINIT"
>System Initialization</A
></DT
><DD
><DL
><DT
>20. <A
HREF="#SYSINIT"
>System Initialization</A
></DT
><DD
><DL
><DT
>20.1. <A
HREF="#CRONJOBS"
>Cron Jobs</A
></DT
><DT
>20.2. <A
HREF="#INISCRPTACT"
>Init Script Actions</A
></DT
><DT
>20.3. <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
></DT
><DT
>20.4. <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
></DT
><DT
>20.5. <A
HREF="#RUNLEVELS"
>Run Levels</A
></DT
><DT
>20.6. <A
HREF="#FACILNAME"
>Facility Names</A
></DT
><DT
>20.7. <A
HREF="#SCRPTNAMES"
>Script Names</A
></DT
><DT
>20.8. <A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
></DT
></DL
></DD
></DL
></DD
><DT
>VIII. <A
HREF="#TOCUSERSGROUPS"
>Users &#38; Groups</A
></DT
><DD
><DL
><DT
>21. <A
HREF="#USERSGROUPS"
>Users &#38; Groups</A
></DT
><DD
><DL
><DT
>21.1. <A
HREF="#USERGRPDATABASE"
>User and Group Database</A
></DT
><DT
>21.2. <A
HREF="#USERNAMES"
>User &#38; Group Names</A
></DT
><DT
>21.3. <A
HREF="#UIDRANGE"
>User ID Ranges</A
></DT
><DT
>21.4. <A
HREF="#USERGRPRAT"
>Rationale</A
></DT
></DL
></DD
></DL
></DD
><DT
>IX. <A
HREF="#PACKAGEFMT"
>Package Format and Installation</A
></DT
><DD
><DL
><DT
>22. <A
HREF="#SWINSTALL"
>Software Installation</A
></DT
><DD
><DL
><DT
>22.1. <A
HREF="#SWINSTALL-INTRO"
>Introduction</A
></DT
><DT
>22.2. <A
HREF="#PKGFORMAT"
>Package File Format</A
></DT
><DT
>22.3. <A
HREF="#PKGSCRIPTS"
>Package Script Restrictions</A
></DT
><DT
>22.4. <A
HREF="#PKGTOOLS"
>Package Tools</A
></DT
><DT
>22.5. <A
HREF="#PKGNAMECONV"
>Package Naming</A
></DT
><DT
>22.6. <A
HREF="#PKGDEPEND"
>Package Dependencies</A
></DT
><DT
>22.7. <A
HREF="#PKGARCHCON"
>Package Architecture Considerations</A
></DT
></DL
></DD
></DL
></DD
><DT
>A. <A
HREF="#APP-A"
>Alphabetical Listing of Interfaces</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#APP-LIBC"
>libc</A
></DT
><DT
>A.2. <A
HREF="#APP-LIBCRYPT"
>libcrypt</A
></DT
><DT
>A.3. <A
HREF="#APP-LIBDL"
>libdl</A
></DT
><DT
>A.4. <A
HREF="#APP-LIBM"
>libm</A
></DT
><DT
>A.5. <A
HREF="#APP-LIBNCURSES"
>libncurses</A
></DT
><DT
>A.6. <A
HREF="#APP-LIBPAM"
>libpam</A
></DT
><DT
>A.7. <A
HREF="#APP-LIBPTHREAD"
>libpthread</A
></DT
><DT
>A.8. <A
HREF="#APP-LIBRT"
>librt</A
></DT
><DT
>A.9. <A
HREF="#APP-LIBUTIL"
>libutil</A
></DT
><DT
>A.10. <A
HREF="#APP-LIBZ"
>libz</A
></DT
></DL
></DD
><DT
>B. <A
HREF="#FUTURE-DIRECTIONS-ANNEX"
>Future Directions (Informative)</A
></DT
><DD
><DL
><DT
>B.1. <A
HREF="#APPB-INTRO"
>Introduction</A
></DT
><DT
>B.2. <A
HREF="#APPB-COMMANDS"
>Commands And Utilities</A
></DT
><DD
><DL
><DT
><A
HREF="#LSBINSTALL"
>lsbinstall</A
>&nbsp;--&nbsp;installation tool for various types of data</DT
></DL
></DD
></DL
></DD
><DT
>C. <A
HREF="#GFDL"
>GNU Free Documentation License (Informative)</A
></DT
><DD
><DL
><DT
>C.1. <A
HREF="#GFDL-0"
>PREAMBLE</A
></DT
><DT
>C.2. <A
HREF="#GFDL-1"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>C.3. <A
HREF="#GFDL-2"
>VERBATIM COPYING</A
></DT
><DT
>C.4. <A
HREF="#GFDL-3"
>COPYING IN QUANTITY</A
></DT
><DT
>C.5. <A
HREF="#GFDL-4"
>MODIFICATIONS</A
></DT
><DT
>C.6. <A
HREF="#GFDL-5"
>COMBINING DOCUMENTS</A
></DT
><DT
>C.7. <A
HREF="#GFDL-6"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>C.8. <A
HREF="#GFDL-7"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>C.9. <A
HREF="#GFDL-8"
>TRANSLATION</A
></DT
><DT
>C.10. <A
HREF="#GFDL-9"
>TERMINATION</A
></DT
><DT
>C.11. <A
HREF="#GFDL-10"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>C.12. <A
HREF="#GFDL-11"
>How to use this License for your documents</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>11-1. <A
HREF="#VERDEFENTRIES"
>Version Definition Entries</A
></DT
><DT
>11-2. <A
HREF="#VERDEFEXTS"
>Version Definition Auxiliary Entries</A
></DT
><DT
>11-3. <A
HREF="#VERNEEDFIG"
>Version Needed Entries</A
></DT
><DT
>11-4. <A
HREF="#VERNEEDEXTFIG"
>Version Needed Auxiliary Entries</A
></DT
><DT
>12-1. <A
HREF="#AEN1766"
>Dynamic Structure</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>2-1. <A
HREF="#STD."
>Normative References</A
></DT
><DT
>2-2. <A
HREF="#AEN166"
>Other References</A
></DT
><DT
>3-1. <A
HREF="#TBL-GLSB-STDLIB"
>Standard Library Names</A
></DT
><DT
>3-2. <A
HREF="#TBL-LSBGENERIC-ARCHLIB"
>Standard Library Names defined in the Architecture Specific Supplement</A
></DT
><DT
>10-1. <A
HREF="#AEN544"
>Scalar Types</A
></DT
><DT
>11-1. <A
HREF="#TBL.ABIUPDATE"
>ELF Section Types</A
></DT
><DT
>11-2. <A
HREF="#TBL.LSB"
>Additional Section Types</A
></DT
><DT
>11-3. <A
HREF="#AEN703"
>ELF Special Sections</A
></DT
><DT
>11-4. <A
HREF="#AEN916"
>Additional Special Sections</A
></DT
><DT
>11-5. <A
HREF="#AEN1064"
>DWARF Exception Header value format</A
></DT
><DT
>11-6. <A
HREF="#AEN1111"
>DWARF Exception Header application</A
></DT
><DT
>11-7. <A
HREF="#AEN1145"
>Additional DWARF Call Frame Instructions</A
></DT
><DT
>11-8. <A
HREF="#AEN1194"
>Call Frame Information Format</A
></DT
><DT
>11-9. <A
HREF="#AEN1204"
>Common Information Entry Format</A
></DT
><DT
>11-10. <A
HREF="#AEN1328"
>Frame Description Entry Format</A
></DT
><DT
>11-11. <A
HREF="#AEN1419"
><SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> Section Format</A
></DT
><DT
>12-1. <A
HREF="#AEN1726"
>Linux Segment Types</A
></DT
><DT
>13-1. <A
HREF="#LIB-LIBC-DEF"
>libc Definition</A
></DT
><DT
>13-2. <A
HREF="#TBL-LIBC-RPC-INTS"
>libc - RPC Function Interfaces</A
></DT
><DT
>13-3. <A
HREF="#TBL-LIBC-SYS-INTS"
>libc - System Calls Function Interfaces</A
></DT
><DT
>13-4. <A
HREF="#TBL-LIBC-STA-INTS"
>libc - Standard I/O Function Interfaces</A
></DT
><DT
>13-5. <A
HREF="#TBL-LIBC-STA-DATA"
>libc - Standard I/O Data Interfaces</A
></DT
><DT
>13-6. <A
HREF="#TBL-LIBC-SIG-INTS"
>libc - Signal Handling Function Interfaces</A
></DT
><DT
>13-7. <A
HREF="#TBL-LIBC-SIG-DATA"
>libc - Signal Handling Data Interfaces</A
></DT
><DT
>13-8. <A
HREF="#TBL-LIBC-LOC-INTS"
>libc - Localization Functions Function Interfaces</A
></DT
><DT
>13-9. <A
HREF="#TBL-LIBC-LOC-DATA"
>libc - Localization Functions Data Interfaces</A
></DT
><DT
>13-10. <A
HREF="#TBL-LIBC-SOC-INTS"
>libc - Socket Interface Function Interfaces</A
></DT
><DT
>13-11. <A
HREF="#TBL-LIBC-WID-INTS"
>libc - Wide Characters Function Interfaces</A
></DT
><DT
>13-12. <A
HREF="#TBL-LIBC-STR-INTS"
>libc - String Functions Function Interfaces</A
></DT
><DT
>13-13. <A
HREF="#TBL-LIBC-IPC-INTS"
>libc - IPC Functions Function Interfaces</A
></DT
><DT
>13-14. <A
HREF="#TBL-LIBC-REG-INTS"
>libc - Regular Expressions Function Interfaces</A
></DT
><DT
>13-15. <A
HREF="#TBL-LIBC-CHA-INTS"
>libc - Character Type Functions Function Interfaces</A
></DT
><DT
>13-16. <A
HREF="#TBL-LIBC-TIM-INTS"
>libc - Time Manipulation Function Interfaces</A
></DT
><DT
>13-17. <A
HREF="#TBL-LIBC-TIM-DATA"
>libc - Time Manipulation Data Interfaces</A
></DT
><DT
>13-18. <A
HREF="#TBL-LIBC-TER-INTS"
>libc - Terminal Interface Functions Function Interfaces</A
></DT
><DT
>13-19. <A
HREF="#TBL-LIBC-SYT-INTS"
>libc - System Database Interface Function Interfaces</A
></DT
><DT
>13-20. <A
HREF="#TBL-LIBC-LAN-INTS"
>libc - Language Support Function Interfaces</A
></DT
><DT
>13-21. <A
HREF="#TBL-LIBC-LAR-INTS"
>libc - Large File Support Function Interfaces</A
></DT
><DT
>13-22. <A
HREF="#TBL-LIBC-STB-INTS"
>libc - Standard Library Function Interfaces</A
></DT
><DT
>13-23. <A
HREF="#TBL-LIBC-STB-DATA"
>libc - Standard Library Data Interfaces</A
></DT
><DT
>13-24. <A
HREF="#LIB-LIBM-DEF"
>libm Definition</A
></DT
><DT
>13-25. <A
HREF="#TBL-LIBM-MAT-INTS"
>libm - Math Function Interfaces</A
></DT
><DT
>13-26. <A
HREF="#TBL-LIBM-MAT-DATA"
>libm - Math Data Interfaces</A
></DT
><DT
>13-27. <A
HREF="#LIB-LIBPTHREAD-DEF"
>libpthread Definition</A
></DT
><DT
>13-28. <A
HREF="#TBL-LIBPTHREAD-REA-INTS"
>libpthread - Realtime Threads Function Interfaces</A
></DT
><DT
>13-29. <A
HREF="#TBL-LIBPTHREAD-POS-INTS"
>libpthread - Posix Threads Function Interfaces</A
></DT
><DT
>13-30. <A
HREF="#TBL-LIBPTHREAD-THR-INTS"
>libpthread - Thread aware versions of libc interfaces Function Interfaces</A
></DT
><DT
>13-31. <A
HREF="#LIB-LIBGCC-S-DEF"
>libgcc_s Definition</A
></DT
><DT
>13-32. <A
HREF="#LIB-LIBDL-DEF"
>libdl Definition</A
></DT
><DT
>13-33. <A
HREF="#TBL-LIBDL-DYN-INTS"
>libdl - Dynamic Loader Function Interfaces</A
></DT
><DT
>13-34. <A
HREF="#LIB-LIBRT-DEF"
>librt Definition</A
></DT
><DT
>13-35. <A
HREF="#TBL-LIBRT-SHA-INTS"
>librt - Shared Memory Objects Function Interfaces</A
></DT
><DT
>13-36. <A
HREF="#TBL-LIBRT-CLO-INTS"
>librt - Clock Function Interfaces</A
></DT
><DT
>13-37. <A
HREF="#TBL-LIBRT-TIM-INTS"
>librt - Timers Function Interfaces</A
></DT
><DT
>13-38. <A
HREF="#LIB-LIBCRYPT-DEF"
>libcrypt Definition</A
></DT
><DT
>13-39. <A
HREF="#TBL-LIBCRYPT-ENC-INTS"
>libcrypt - Encryption Function Interfaces</A
></DT
><DT
>13-40. <A
HREF="#LIB-LIBPAM-DEF"
>libpam Definition</A
></DT
><DT
>13-41. <A
HREF="#TBL-LIBPAM-PLU-INTS"
>libpam - Pluggable Authentication API Function Interfaces</A
></DT
><DT
>14-1. <A
HREF="#LIB-LIBZ-DEF"
>libz Definition</A
></DT
><DT
>14-2. <A
HREF="#TBL-LIBZ-COM-INTS"
>libz - Compression Library Function Interfaces</A
></DT
><DT
>14-3. <A
HREF="#LIB-LIBNCURSES-DEF"
>libncurses Definition</A
></DT
><DT
>14-4. <A
HREF="#TBL-LIBNCURSES-CUR-INTS"
>libncurses - Curses Function Interfaces</A
></DT
><DT
>14-5. <A
HREF="#TBL-LIBNCURSES-CUR-DATA"
>libncurses - Curses Data Interfaces</A
></DT
><DT
>14-6. <A
HREF="#LIB-LIBUTIL-DEF"
>libutil Definition</A
></DT
><DT
>14-7. <A
HREF="#TBL-LIBUTIL-UTI-INTS"
>libutil - Utility Functions Function Interfaces</A
></DT
><DT
>15-1. <A
HREF="#TBL-CMDS"
>Commands And Utilities</A
></DT
><DT
>15-2. <A
HREF="#TBL-BUILTINS"
>Built In Utilities</A
></DT
><DT
>15-1. <A
HREF="#AEN23922"
>Escape Sequences</A
></DT
><DT
>21-1. <A
HREF="#TBL-REQUIREDUSERS"
>Required User &#38; Group Names</A
></DT
><DT
>21-2. <A
HREF="#TBL-OPTUSERS"
>Optional User &#38; Group Names</A
></DT
><DT
>22-1. <A
HREF="#AEN26186"
>RPM File Format</A
></DT
><DT
>22-2. <A
HREF="#AEN26256"
>Signature Format</A
></DT
><DT
>22-3. <A
HREF="#AEN26325"
>Index Type values</A
></DT
><DT
>22-4. <A
HREF="#AEN26406"
>Header Private Tag Values</A
></DT
><DT
>22-5. <A
HREF="#AEN26487"
>Signature Tag Values</A
></DT
><DT
>22-6. <A
HREF="#AEN26524"
>Signature Digest Tag Values</A
></DT
><DT
>22-7. <A
HREF="#AEN26561"
>Signature Signing Tag Values</A
></DT
><DT
>22-8. <A
HREF="#AEN26631"
>Package Info Tag Values</A
></DT
><DT
>22-9. <A
HREF="#AEN26910"
>Installation Tag Values</A
></DT
><DT
>22-10. <A
HREF="#AEN27025"
>File Info Tag Values</A
></DT
><DT
>22-11. <A
HREF="#AEN27238"
>File Flags</A
></DT
><DT
>22-12. <A
HREF="#AEN27342"
>Package Dependency Tag Values</A
></DT
><DT
>22-13. <A
HREF="#AEN27503"
>Index Type values</A
></DT
><DT
>22-14. <A
HREF="#AEN27547"
>Package Dependency Attributes</A
></DT
><DT
>22-15. <A
HREF="#AEN27619"
>Other Tag Values</A
></DT
><DT
>22-16. <A
HREF="#AEN27744"
>CPIO File Format</A
></DT
><DT
>A-1. <A
HREF="#AEN27947"
>libc Function Interfaces</A
></DT
><DT
>A-2. <A
HREF="#AEN29777"
>libc Data Interfaces</A
></DT
><DT
>A-3. <A
HREF="#AEN29801"
>libcrypt Function Interfaces</A
></DT
><DT
>A-4. <A
HREF="#AEN29821"
>libdl Function Interfaces</A
></DT
><DT
>A-5. <A
HREF="#AEN29851"
>libm Function Interfaces</A
></DT
><DT
>A-6. <A
HREF="#AEN30554"
>libm Data Interfaces</A
></DT
><DT
>A-7. <A
HREF="#AEN30570"
>libncurses Function Interfaces</A
></DT
><DT
>A-8. <A
HREF="#AEN31217"
>libncurses Data Interfaces</A
></DT
><DT
>A-9. <A
HREF="#AEN31248"
>libpam Function Interfaces</A
></DT
><DT
>A-10. <A
HREF="#AEN31296"
>libpthread Function Interfaces</A
></DT
><DT
>A-11. <A
HREF="#AEN31529"
>librt Function Interfaces</A
></DT
><DT
>A-12. <A
HREF="#AEN31568"
>libutil Function Interfaces</A
></DT
><DT
>A-13. <A
HREF="#AEN31593"
>libz Function Interfaces</A
></DT
></DL
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="OVERVIEW"
></A
>Foreword</H1
><P
>This is version 3.1 of the Linux Standard Base Core Specification.
This specification is part of a family of specifications under the general title
"Linux Standard Base". Developers of applications or implementations interested
in using the LSB trademark should see the Free Standards Group Certification
Policy for details.</P
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="INTRO"
></A
>Introduction</H1
><P
>The LSB defines a binary interface for application programs that are compiled
and packaged for LSB-conforming implementations on many different hardware
architectures. Since a binary specification shall include information specific
to the computer processor architecture for which it is intended, it is not
possible for a single document to specify the interface for all possible
LSB-conforming implementations. Therefore, the LSB is a family of
specifications, rather than a single one.</P
><P
>This document should be used in conjunction with the documents it references.
This document enumerates the system components it includes, but descriptions of
those components may be included entirely or partly in this document, partly in
other documents, or entirely in other reference documents. For example, the
section that describes system service routines includes a list of the system
routines supported in this interface, formal declarations of the data
structures they use that are visible to applications, and a pointer to the
underlying referenced specification for information about the syntax and
semantics of each call. Only those routines not described in standards
referenced by this document, or extensions to those standards, are described in
the detail. Information referenced in this way is as much a part of this
document as is the information explicitly included here.</P
><P
>The specification carries a version number of either the form
<TT
CLASS="LITERAL"
>x.y</TT
> or <TT
CLASS="LITERAL"
>x.y.z</TT
>.
This version number carries the following meaning:
<P
></P
><UL
><LI
><P
>The first number (<TT
CLASS="LITERAL"
>x</TT
>) is the major version number.
All versions with the same major version number should share
binary compatibility. Any addition or deletion of a new library
results in a new version number.  Interfaces marked as
<TT
CLASS="LITERAL"
>deprecated</TT
> may be removed from the
specification at a major version change.</P
></LI
><LI
><P
>The second number (<TT
CLASS="LITERAL"
>y</TT
>) is the minor version number.
Individual interfaces may be added if all certified implementations
already had that (previously undocumented) interface. Interfaces may be
marked as <TT
CLASS="LITERAL"
>deprecated</TT
> at a minor version change.
Other minor changes may be permitted at the discretion of the LSB workgroup.</P
></LI
><LI
><P
>The third number (<TT
CLASS="LITERAL"
>z</TT
>), if present, is the editorial level. Only
editorial changes should be included in such versions.</P
></LI
></UL
></P
><P
>Since this specification is a descriptive Application Binary Interface,
and not a source level API specification, it is not possible to make a
guarantee of 100% backward compatibility between major releases. However,
it is the intent that those parts of the binary interface that are visible
in the source level API will remain backward compatible from version to
version, except where a feature marked as "Deprecated" in one release
may be removed from a future release.</P
><P
>Implementors are strongly encouraged to make use of symbol versioning
to permit simultaneous support of applications conforming to different
releases of this specification.</P
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCINTRO"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>I. Introductory Elements</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#SCOPE"
>Scope</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#GENSCOPE"
>General</A
></DT
><DT
>1.2. <A
HREF="#MODSCOPE"
>Module Specific Scope</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#NORMATIVEREFS"
>References</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#NORMATIVEREFSSECT"
>Normative References</A
></DT
><DT
>2.2. <A
HREF="#INFORMATIVEREFS"
>Informative References/Bibliography</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#REQUIREMENTS"
>Requirements</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#RLIBRARIES"
>Relevant Libraries</A
></DT
><DT
>3.2. <A
HREF="#IMPLEMENTATION"
>LSB Implementation Conformance</A
></DT
><DT
>3.3. <A
HREF="#APPLICATION"
>LSB Application Conformance</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#DEF"
>Definitions</A
></DT
><DT
>5. <A
HREF="#TERMS"
>Terminology</A
></DT
><DT
>6. <A
HREF="#DOCCONV"
>Documentation Conventions</A
></DT
><DT
>7. <A
HREF="#POSIXCONFLICTS"
>Relationship To ISO/IEC 9945 POSIX</A
></DT
><DT
>8. <A
HREF="#RELTOFSG"
>Relationship To Other Free Standards Group Specifications</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SCOPE"
></A
>Chapter 1. Scope</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="GENSCOPE"
>1.1. General</A
></H2
><P
>The Linux Standard Base (LSB) defines a system interface for compiled
applications and a minimal environment for support of installation scripts.
Its purpose is to enable a uniform industry standard environment for
high-volume applications conforming to the LSB.</P
><P
>These specifications are composed of two basic parts: A common specification
("LSB-generic" or "generic LSB") describing those parts of the interface that
remain constant across all implementations of the LSB, and an
architecture-specific supplement ("LSB-arch" or "archLSB") describing the
parts of the interface that vary by processor architecture.
Together, the LSB-generic and the
architecture-specific supplement for a single hardware architecture provide a
complete interface specification for compiled application programs on systems
that share a common hardware architecture.</P
><P
>The LSB-generic document shall be used in conjunction with an
architecture-specific supplement. Whenever a section of the LSB-generic
specification
shall be supplemented by architecture-specific information, the LSB-generic
document
includes a reference to the architecture supplement. Architecture supplements
may also contain additional information that is not referenced in the
LSB-generic document.</P
><P
>The LSB contains both a set of Application Program Interfaces (APIs)
and Application Binary Interfaces (ABIs). APIs may appear in the
source code of portable applications, while the compiled binary of that
application may use the larger set of ABIs. A conforming implementation
shall provide all of the ABIs listed here. The compilation system may
replace (e.g. by macro definition) certain APIs with calls to one or
more of the underlying binary interfaces, and may insert calls to binary
interfaces as needed.</P
><P
>The LSB is primarily a binary interface
definition. Not all of the source level APIs available to applications
may be contained in this specification.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MODSCOPE"
>1.2. Module Specific Scope</A
></H2
><P
>This is the Core module of the Linux Standards Base (LSB).
This module provides the fundamental system interfaces, libraries,
and runtime environment upon which all conforming applications and
libraries depend.</P
><P
>Interfaces described in this module are mandatory except where explicitly
listed otherwise. Core interfaces may be supplemented by other modules;
all modules are built upon the core.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NORMATIVEREFS"
></A
>Chapter 2. References</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="NORMATIVEREFSSECT"
>2.1. Normative References</A
></H2
><P
>The following referenced documents are indispensable for the application of this
document. For dated references, only the edition cited applies. For undated references,
the latest edition of the referenced document (including any amendments) applies.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Where copies of a document are available on the World Wide Web, a Uniform Resource
Locator (URL) is given for informative purposes only. 
This may point to a more recent copy of the referenced
specification, or may be out of date. Reference copies of specifications at the revision
level indicated may be found at the Free Standards Group's 
<A
HREF="http://refspecs.freestandards.org"
TARGET="_top"
>Reference Specifications</A
> site.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="STD."
></A
><P
><B
>Table 2-1. Normative References</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Title</TH
><TH
>URL</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="STD.FHS"
></A
><TD
>Filesystem Hierarchy Standard</TD
><TD
>Filesystem Hierarchy Standard (FHS) 2.3</TD
><TD
><A
HREF="http://www.pathname.com/fhs/"
TARGET="_top"
>http://www.pathname.com/fhs/</A
></TD
></TR
><TR
><A
NAME="STD.FLTPNT"
></A
><TD
>IEC 60559/IEEE 754 Floating Point</TD
><TD
>IEC 60559:1989 Binary floating-point arithmetic for microprocessor systems</TD
><TD
><A
HREF="http://www.ieee.org/"
TARGET="_top"
>http://www.ieee.org/</A
></TD
></TR
><TR
><A
NAME="STD.ISOC99"
></A
><TD
>ISO C (1999)</TD
><TD
>ISO/IEC 9899: 1999, Programming Languages --C</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.SUSV3"
></A
><TD
>ISO POSIX (2003)</TD
><TD
><P
>ISO/IEC 9945-1:2003   Information technology -- Portable Operating System Interface (POSIX) -- Part 1: Base Definitions</P
><P
>ISO/IEC 9945-2:2003 Information technology -- Portable Operating System Interface (POSIX) -- Part 2: System Interfaces</P
><P
>ISO/IEC 9945-3:2003   Information technology -- Portable Operating System Interface (POSIX) -- Part 3: Shell and Utilities</P
><P
>ISO/IEC 9945-4:2003   Information technology -- Portable Operating System Interface (POSIX) -- Part 4: Rationale</P
><P
>Including Technical Cor. 1: 2004</P
></TD
><TD
><A
HREF="http://www.unix.org/version3/"
TARGET="_top"
>http://www.unix.org/version3/</A
></TD
></TR
><TR
><A
NAME="STD.CXXABI"
></A
><TD
>Itanium C++ ABI</TD
><TD
>Itanium C++ ABI (Revision 1.83)</TD
><TD
><A
HREF="http://refspecs.freestandards.org/cxxabi-1.83.html"
TARGET="_top"
>http://refspecs.freestandards.org/cxxabi-1.83.html</A
></TD
></TR
><TR
><A
NAME="STD.LFS"
></A
><TD
>Large File Support</TD
><TD
>Large File Support</TD
><TD
><A
HREF="http://www.UNIX-systems.org/version2/whatsnew/lfs20mar.html"
TARGET="_top"
>http://www.UNIX-systems.org/version2/whatsnew/lfs20mar.html</A
></TD
></TR
><TR
><A
NAME="STD.SUSV2"
></A
><TD
>SUSv2</TD
><TD
>CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</TD
><TD
><A
HREF="http://www.opengroup.org/publications/catalog/un.htm"
TARGET="_top"
>http://www.opengroup.org/publications/catalog/un.htm</A
></TD
></TR
><TR
><A
NAME="STD.SUS.XCU"
></A
><TD
>SUSv2 Commands and Utilities</TD
><TD
>The Single UNIX® Specification(SUS) Version 2, Commands and Utilities (XCU), Issue 5 (ISBN: 1-85912-191-8, C604)</TD
><TD
><A
HREF="http://www.opengroup.org/publications/catalog/un.htm"
TARGET="_top"
>http://www.opengroup.org/publications/catalog/un.htm</A
></TD
></TR
><TR
><A
NAME="STD.SVID.3"
></A
><TD
>SVID Issue 3</TD
><TD
>American Telephone and Telegraph Company, System V Interface Definition, Issue 3 ; Morristown, NJ, UNIX Press, 1989.(ISBN 0201566524)</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.SVID.4"
></A
><TD
>SVID Issue 4</TD
><TD
>System V Interface Definition,Fourth Edition</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.GABI41"
></A
><TD
>System V ABI</TD
><TD
>System V Application Binary Interface, Edition 4.1</TD
><TD
><A
HREF="http://www.caldera.com/developers/devspecs/gabi41.pdf"
TARGET="_top"
>http://www.caldera.com/developers/devspecs/gabi41.pdf</A
></TD
></TR
><TR
><A
NAME="STD.ABIUPDATE"
></A
><TD
>System V ABI Update</TD
><TD
>System V Application Binary Interface - DRAFT - 17 December 2003</TD
><TD
><A
HREF="http://www.caldera.com/developers/gabi/2003-12-17/contents.html"
TARGET="_top"
>http://www.caldera.com/developers/gabi/2003-12-17/contents.html</A
></TD
></TR
><TR
><A
NAME="STD.SUS.CURSES"
></A
><TD
>X/Open Curses</TD
><TD
>CAE Specification, May 1996, X/Open Curses, Issue 4, Version 2 (ISBN:  1-85912-171-3, C610), plus Corrigendum U018</TD
><TD
><A
HREF="http://www.opengroup.org/publications/catalog/un.htm"
TARGET="_top"
>http://www.opengroup.org/publications/catalog/un.htm</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATIVEREFS"
>2.2. Informative References/Bibliography</A
></H2
><P
>In addition, the specifications listed below provide essential background information
to implementors of this specification. These references are included for information
only.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN166"
></A
><P
><B
>Table 2-2. Other References</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Title</TH
><TH
>URL</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="STD.DWARF2"
></A
><TD
>DWARF Debugging Information Format, Revision 2.0.0</TD
><TD
>DWARF Debugging Information Format, Revision 2.0.0 (July 27, 1993)</TD
><TD
><A
HREF="http://refspecs.freestandards.org/dwarf/dwarf-2.0.0.pdf"
TARGET="_top"
>http://refspecs.freestandards.org/dwarf/dwarf-2.0.0.pdf</A
></TD
></TR
><TR
><A
NAME="STD.DWARF3"
></A
><TD
>DWARF Debugging Information Format, Revision 3.0.0 (Draft)</TD
><TD
>DWARF Debugging Information Format, Revision 3.0.0 (Draft)</TD
><TD
><A
HREF="http://refspecs.freestandards.org/dwarf/"
TARGET="_top"
>http://refspecs.freestandards.org/dwarf/</A
></TD
></TR
><TR
><A
NAME="STD.TR14652"
></A
><TD
>ISO/IEC TR14652</TD
><TD
>ISO/IEC Technical Report 14652:2002 Specification method for cultural conventions</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.ITUV42"
></A
><TD
>ITU-T V.42</TD
><TD
>International Telecommunication Union Recommendation V.42 (2002): Error-correcting procedures for DCEs using asynchronous-to-synchronous conversionITUV</TD
><TD
><A
HREF="http://www.itu.int/rec/recommendation.asp?type=folders&lang=e&parent=T-REC-V.42"
TARGET="_top"
>http://www.itu.int/rec/recommendation.asp?type=folders&#38;lang=e&#38;parent=T-REC-V.42</A
></TD
></TR
><TR
><A
NAME="STD.LI18NUX"
></A
><TD
>Li18nux Globalization Specification</TD
><TD
>LI18NUX 2000 Globalization Specification, Version 1.0 with Amendment 4</TD
><TD
><A
HREF="http://www.li18nux.org/docs/html/LI18NUX-2000-amd4.htm"
TARGET="_top"
>http://www.li18nux.org/docs/html/LI18NUX-2000-amd4.htm</A
></TD
></TR
><TR
><A
NAME="STD.DEVICES"
></A
><TD
>Linux Allocated Device Registry</TD
><TD
>LINUX ALLOCATED DEVICES</TD
><TD
><A
HREF="http://www.lanana.org/docs/device-list/devices.txt"
TARGET="_top"
>http://www.lanana.org/docs/device-list/devices.txt</A
></TD
></TR
><TR
><A
NAME="STD.PAM"
></A
><TD
>PAM</TD
><TD
>Open Software Foundation, Request For Comments: 86.0 , October 1995, V. Samar &#38; R.Schemers (SunSoft)</TD
><TD
><A
HREF="http://www.opengroup.org/tech/rfc/mirror-rfc/rfc86.0.txt"
TARGET="_top"
>http://www.opengroup.org/tech/rfc/mirror-rfc/rfc86.0.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1321"
></A
><TD
>RFC 1321: The MD5 Message-Digest Algorithm</TD
><TD
>IETF RFC 1321: The MD5 Message-Digest Algorithm</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1321.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1321.txt</A
></TD
></TR
><TR
><A
NAME="STD.RPC.XDR"
></A
><TD
>RFC 1831/1832 RPC &#38; XDR</TD
><TD
>IETF RFC 1831 &#38; 1832</TD
><TD
><A
HREF="http://www.ietf.org/"
TARGET="_top"
>http://www.ietf.org/</A
></TD
></TR
><TR
><A
NAME="STD.RFC1833"
></A
><TD
>RFC 1833: Binding Protocols for ONC RPC Version 2</TD
><TD
>IETF RFC 1833: Binding Protocols for ONC RPC Version 2</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1833.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1833.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1950"
></A
><TD
>RFC 1950: ZLIB Compressed Data Format Specication</TD
><TD
>IETF RFC 1950: ZLIB Compressed Data Format Specification</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1950.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1950.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1951"
></A
><TD
>RFC 1951: DEFLATE Compressed Data Format Specification</TD
><TD
>IETF RFC 1951: DEFLATE Compressed Data Format Specification version 1.3</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1951.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1951.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1952"
></A
><TD
>RFC 1952: GZIP File Format Specification</TD
><TD
>IETF RFC 1952: GZIP file format specification version 4.3</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1952.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1952.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC2440"
></A
><TD
>RFC 2440: OpenPGP Message Format</TD
><TD
>IETF RFC 2440: OpenPGP Message Format</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc2440.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2440.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC2821"
></A
><TD
>RFC 2821:Simple Mail Transfer Protocol</TD
><TD
>IETF RFC 2821: Simple Mail Transfer Protocol</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc2821.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2821.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC2822"
></A
><TD
>RFC 2822:Internet Message Format</TD
><TD
>IETF RFC 2822: Internet Message Format</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc2822.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2822.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC791"
></A
><TD
>RFC 791:Internet Protocol</TD
><TD
>IETF RFC 791: Internet Protocol Specification</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc791.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc791.txt</A
></TD
></TR
><TR
><A
NAME="STD.RPM"
></A
><TD
>RPM Package Format</TD
><TD
>RPM Package Format V3.0</TD
><TD
><A
HREF="http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html"
TARGET="_top"
>http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html</A
></TD
></TR
><TR
><A
NAME="STD.ZLIB"
></A
><TD
>zlib Manual</TD
><TD
>zlib 1.2 Manual</TD
><TD
><A
HREF="http://www.gzip.org/zlib/"
TARGET="_top"
>http://www.gzip.org/zlib/</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="REQUIREMENTS"
></A
>Chapter 3. Requirements</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="RLIBRARIES"
>3.1. Relevant Libraries</A
></H2
><P
>&#13;
The libraries listed in <A
HREF="#TBL-GLSB-STDLIB"
>Table 3-1</A
> shall
be available on a Linux Standard Base system, with the specified
runtime names. The libraries listed in <A
HREF="#TBL-LSBGENERIC-ARCHLIB"
>Table 3-2</A
>
are architecture specific, but shall be available on all LSB
conforming systems. This list may be supplemented or amended by the
architecture specific supplement.&#13;</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-GLSB-STDLIB"
></A
><P
><B
>Table 3-1. Standard Library Names</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Library</TH
><TH
>Runtime Name</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="LIB.LIBDL"
></A
><TD
>libdl</TD
><TD
>libdl.so.2</TD
></TR
><TR
><A
NAME="LIB.LIBCRYPT"
></A
><TD
>libcrypt</TD
><TD
>libcrypt.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBZ"
></A
><TD
>libz</TD
><TD
>libz.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBNCURSES"
></A
><TD
>libncurses</TD
><TD
>libncurses.so.5</TD
></TR
><TR
><A
NAME="LIB.LIBUTIL"
></A
><TD
>libutil</TD
><TD
>libutil.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBPTHREAD"
></A
><TD
>libpthread</TD
><TD
>libpthread.so.0</TD
></TR
><TR
><A
NAME="LIB.LIBRT"
></A
><TD
>librt</TD
><TD
>librt.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBPAM"
></A
><TD
>libpam</TD
><TD
>libpam.so.0</TD
></TR
><TR
><A
NAME="LIB.LIBGCC.S"
></A
><TD
>libgcc_s</TD
><TD
>libgcc_s.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LSBGENERIC-ARCHLIB"
></A
><P
><B
>Table 3-2. Standard Library Names defined in the Architecture Specific Supplement</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Library</TH
><TH
>Runtime Name</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="LIB.LIBM"
></A
><TD
>libm</TD
><TD
>See archLSB</TD
></TR
><TR
><A
NAME="LIB.LIBC"
></A
><TD
>libc</TD
><TD
>See archLSB</TD
></TR
><TR
><A
NAME="LIB.PROGINTERP"
></A
><TD
>proginterp</TD
><TD
>See archLSB</TD
></TR
></TBODY
></TABLE
></DIV
><P
>These libraries will be in an implementation-defined directory which
the dynamic linker shall search by default.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="IMPLEMENTATION"
>3.2. LSB Implementation Conformance</A
></H2
><P
>A conforming implementation is necessarily architecture specific, and must provide the interfaces specified by
both the generic LSB Core specification and its relevant architecture specific supplement.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>An implementation must provide <I
CLASS="EMPHASIS"
>at least</I
>
the interfaces specified in these specifications. It may also provide additional interfaces.</P
></BLOCKQUOTE
></DIV
></P
><P
>A conforming implementation shall satisfy the following requirements:</P
><P
><P
></P
><UL
><LI
><P
>A processor architecture represents a family of related processors
which may not have identical feature sets. The architecture
specific supplement to this specification for a given target
processor architecture describes a minimum acceptable processor.
The implementation shall provide all features of this processor,
whether in hardware or through emulation transparent
to the application.</P
></LI
><LI
><P
>The implementation shall be capable of executing compiled applications
having the format and using the system interfaces described in this
document.</P
></LI
><LI
><P
>The implementation shall provide libraries containing the interfaces
specified by this document, and shall provide a dynamic linking
mechanism that allows these interfaces to be attached to applications
at runtime. All the interfaces shall behave as specified in
this document.</P
></LI
><LI
><P
>The map of virtual memory provided by the implementation shall conform to the requirements of this document. </P
></LI
><LI
><P
>The implementation's low-level behavior with respect to function call linkage, system traps, signals, and other such activities shall conform to the formats described in this document. </P
></LI
><LI
><P
>The implementation shall provide all of the mandatory interfaces
in their entirety. </P
></LI
><LI
><P
>The implementation may provide one or more of the optional interfaces. Each optional interface that is provided shall be provided in its entirety. The product documentation shall state which optional interfaces are provided. </P
></LI
><LI
><P
>The implementation shall provide all files and utilities specified as part of this document in the format defined here and in other referenced documents. All commands and utilities shall behave as required by this document. The implementation shall also provide all mandatory components of an application's runtime environment that are included or referenced in this document. </P
></LI
><LI
><P
>The implementation, when provided with standard data formats and
values at a named interface, shall provide the behavior defined for
those values and data formats at that interface. However, a conforming
implementation may consist of components which are separately packaged
and/or sold. For example, a vendor of a conforming implementation
might sell the hardware, operating system, and windowing system as
separately packaged items.</P
></LI
><LI
><P
>The implementation may provide additional interfaces with different names. It may also provide additional behavior corresponding to data values outside the standard ranges, for standard named interfaces.</P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APPLICATION"
>3.3. LSB Application Conformance</A
></H2
><P
>A conforming application is necessarily architecture specific, and must conform to
both the generic LSB Core specification and its relevant architecture specific supplement.</P
><P
>A conforming application shall satisfy the following requirements: </P
><P
>&#13;<P
></P
><UL
><LI
><P
>Its executable files shall be either shell scripts or object files in the format defined for the Object File Format system interface.</P
></LI
><LI
><P
>Its object files shall participate in dynamic linking as defined in the Program Loading and Linking System interface.</P
></LI
><LI
><P
>It shall employ only the instructions, traps, and other low-level facilities defined in the Low-Level System interface as being for use by applications.</P
></LI
><LI
><P
>If it requires any optional interface defined in this document in order to be installed or to execute successfully, the requirement for that optional interface shall be stated in the application's documentation. </P
></LI
><LI
><P
>It shall not use any interface or data format that is not required to be provided by a conforming implementation, unless: 
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>If such an interface or data format is supplied by another application through direct invocation of that application during execution, that application shall be in turn an LSB conforming application.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The use of that interface or data format, as well as its source, shall be identified in the documentation of the application. </P
></LI
></UL
></P
></LI
><LI
><P
>It shall not use any values for a named interface that are reserved for vendor extensions. </P
></LI
></UL
>

A strictly conforming application shall not require or use any interface, facility, or implementation-defined extension that is not defined in this document in order to be installed or to execute successfully. </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DEF"
></A
>Chapter 4. Definitions</H1
><P
>For the purposes of this document, the following definitions, as specified in the <I
CLASS="CITETITLE"
>ISO/IEC Directives, Part 2, 2001, 4th Edition</I
>, apply:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN388"
></A
><SPAN
STYLE="white-space: nowrap"
>can</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>be able to; there is a possibility of; it is possible to</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN392"
></A
><SPAN
STYLE="white-space: nowrap"
>cannot</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>be unable to; there is no possibilty of; it is not possible to</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN396"
></A
><SPAN
STYLE="white-space: nowrap"
>may</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is permitted; is allowed; is permissible</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN400"
></A
><SPAN
STYLE="white-space: nowrap"
>need not</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>it is not required that; no...is required</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN404"
></A
><SPAN
STYLE="white-space: nowrap"
>shall</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is to; is required to; it is required that; has to; only...is permitted; it is necessary</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN408"
></A
><SPAN
STYLE="white-space: nowrap"
>shall not</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is not allowed [permitted] [acceptable] [permissible]; is required to be not; is required that...be not; is not to be</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN412"
></A
><SPAN
STYLE="white-space: nowrap"
>should</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>it is recommended that; ought to</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN416"
></A
><SPAN
STYLE="white-space: nowrap"
>should not</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>it is not recommended that; ought not to</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TERMS"
></A
>Chapter 5. Terminology</H1
><P
>For the purposes of this document, the following terms apply:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>archLSB</DT
><DD
><P
>The architectural part of the LSB Specification which describes 
the specific parts of the interface that are platform specific.
The archLSB is complementary to the gLSB.</P
></DD
><DT
>Binary Standard</DT
><DD
><P
>The total set of interfaces that are available to be used in the compiled
binary code of
a conforming application.</P
></DD
><DT
>gLSB</DT
><DD
><P
>The common part of the LSB Specification that describes those parts of the
interface that remain constant across all hardware implementations of the LSB.</P
></DD
><DT
>implementation-defined</DT
><DD
><P
>Describes a value or
behavior that is not defined by this document but is selected by an
implementor. The value or behavior may vary among implementations
that conform to this document. An application should not rely on the
existence of the value or behavior. An application that relies on such
a value or behavior cannot be assured to be portable across conforming
implementations.  The implementor shall document such a value or behavior
so that it can be used correctly by an application.</P
></DD
><DT
>Shell Script</DT
><DD
><P
>A file that is read by an interpreter (e.g., awk). The first line of the shell script includes a reference to its interpreter binary.</P
></DD
><DT
>Source Standard</DT
><DD
><P
>The set of interfaces that are available to be used in the source code of
a conforming application.</P
></DD
><DT
>undefined</DT
><DD
><P
>Describes the nature of a value or behavior not defined by this document
which results from use of an invalid program construct or invalid
data input.  The value or behavior may vary among implementations that
conform to this document. An application should not rely on the existence
or validity of the value or behavior. An application that relies on any
particular value or behavior cannot be assured to be portable across
conforming implementations.</P
></DD
><DT
>unspecified</DT
><DD
><P
>Describes the nature of a value or behavior not specified by this document
which results from use of a valid program construct or valid data input.
The value or behavior may vary among implementations that conform to this
document. An application should not rely on the existence or validity
of the value or behavior. An application that relies on any particular
value or behavior cannot be assured to be portable across conforming
implementations.</P
></DD
></DL
></DIV
><P
>Other terms and definitions used in this document shall have the same
meaning as defined in Chapter 3 of the Base Definitions volume of
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DOCCONV"
></A
>Chapter 6. Documentation Conventions</H1
><P
>Throughout this document, the following typographic conventions are used:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN462"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FUNCTION"
>function()</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the name of a function</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN467"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>command</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the name of a command or utility</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN472"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>CONSTANT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a constant value</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN477"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>parameter</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a parameter</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN482"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="VARNAME"
>variable</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a variable</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>Throughout this specification, 
several tables of interfaces are presented. Each entry in these tables
has the following format:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN489"
></A
><SPAN
STYLE="white-space: nowrap"
>name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the name of the interface</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN493"
></A
><SPAN
STYLE="white-space: nowrap"
>(symver)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An optional symbol version identifier, if required.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN497"
></A
><SPAN
STYLE="white-space: nowrap"
>[<TT
CLASS="REPLACEABLE"
><I
>refno</I
></TT
>]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A reference number indexing the table of referenced specifications
that follows this table.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>For example,
<DIV
CLASS="INFORMALTABLE"
><P
></P
><A
NAME="AEN503"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>forkpty(GLIBC_2.0) [SUSv3]</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
refers to the interface named <TT
CLASS="FUNCTION"
>forkpty()</TT
>
with symbol version <CODE
CLASS="CONSTANT"
>GLIBC_2.0</CODE
> that is defined in the
<TT
CLASS="LITERAL"
>SUSv3</TT
> reference.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Symbol versions are defined in the architecture specific supplements only.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="POSIXCONFLICTS"
></A
>Chapter 7. Relationship To ISO/IEC 9945 POSIX</H1
><P
>This specification includes many interfaces described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
Unless otherwise specified, such interfaces should behave exactly as described
in that specification.
Any conflict between the requirements described here and the <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
standard is unintentional, except as explicitly noted otherwise.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In addition to the differences noted inline in this specification,
PDTR 24715 has extracted the differences between this specification and <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
into a single place.
It is the long term plan of the Free Standards Group to converge the LSB Core Specification
with ISO/IEC 9945 POSIX.</P
></BLOCKQUOTE
></DIV
><P
>The LSB Specification Authority is responsible for deciding the meaning
of conformance to normative referenced standards in the LSB context.
Problem Reports regarding underlying or referenced standards in any
other context will be referred to the relevant maintenance body for 
that standard.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="RELTOFSG"
></A
>Chapter 8. Relationship To Other Free Standards Group Specifications</H1
><P
>The LSB is the base for several other specification projects under the umbrella
of the Free Standards Group (FSG). This specification is the foundation, and other
specifications build on the interfaces defined here. However, beyond those
specifications listed as Normative References, this specification has no
dependencies on other FSG projects.</P
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="ELF-GENERIC"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>II. Executable And Linking Format (ELF)</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>9. <A
HREF="#ELFINTRO"
>Introduction</A
></DT
><DT
>10. <A
HREF="#LOWLEVEL"
>Low Level System Information</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#OSINTERFACE"
>Operating System Interface</A
></DT
><DT
>10.2. <A
HREF="#MACHINEINTERFACE"
>Machine Interface</A
></DT
><DD
><DL
><DT
>10.2.1. <A
HREF="#DATAREPRESENTATION"
>Data Representation</A
></DT
></DL
></DD
></DL
></DD
><DT
>11. <A
HREF="#TOCOBJFORMAT"
>Object Format</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#OBJFMT"
>Object Files</A
></DT
><DT
>11.2. <A
HREF="#SECTIONS"
>Sections</A
></DT
><DD
><DL
><DT
>11.2.1. <A
HREF="#AEN583"
>Introduction</A
></DT
><DT
>11.2.2. <A
HREF="#ELFTYPES"
>Sections Types</A
></DT
></DL
></DD
><DT
>11.3. <A
HREF="#SPECIALSECTIONS"
>Special Sections</A
></DT
><DD
><DL
><DT
>11.3.1. <A
HREF="#ELFSPECIAL"
>Special Sections</A
></DT
></DL
></DD
><DT
>11.4. <A
HREF="#SYMMAP"
>Symbol Mapping</A
></DT
><DD
><DL
><DT
>11.4.1. <A
HREF="#AEN1046"
>Introduction</A
></DT
></DL
></DD
><DT
>11.5. <A
HREF="#DWARFEXT"
>DWARF Extensions</A
></DT
><DD
><DL
><DT
>11.5.1. <A
HREF="#DWARFEHENCODING"
>DWARF Exception Header Encoding</A
></DT
><DT
>11.5.2. <A
HREF="#DWARFCFIEXT"
>DWARF CFI Extensions</A
></DT
></DL
></DD
><DT
>11.6. <A
HREF="#EHFRAMECHPT"
>Exception Frames</A
></DT
><DD
><DL
><DT
>11.6.1. <A
HREF="#EHFRAME"
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section</A
></DT
><DT
>11.6.2. <A
HREF="#EHFRAMEHDR"
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section</A
></DT
></DL
></DD
><DT
>11.7. <A
HREF="#SYMVERSION"
>Symbol Versioning</A
></DT
><DD
><DL
><DT
>11.7.1. <A
HREF="#AEN1482"
>Introduction</A
></DT
><DT
>11.7.2. <A
HREF="#SYMVERTBL"
>Symbol Version Table</A
></DT
><DT
>11.7.3. <A
HREF="#SYMVERDEFS"
>Version Definitions</A
></DT
><DT
>11.7.4. <A
HREF="#SYMVERRQMTS"
>Version Requirements</A
></DT
><DT
>11.7.5. <A
HREF="#SYMSTARTSEQ"
>Startup Sequence</A
></DT
><DT
>11.7.6. <A
HREF="#SYMRESOLUTION"
>Symbol Resolution</A
></DT
></DL
></DD
><DT
>11.8. <A
HREF="#NOTEABITAG"
>ABI note tag</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#TOCDYNLNK"
>Dynamic Linking</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#DYNLNK"
>Program Loading and Dynamic Linking</A
></DT
><DT
>12.2. <A
HREF="#PROGHEADER"
>Program Header</A
></DT
><DT
>12.3. <A
HREF="#DYNAMICSECTION"
>Dynamic Entries</A
></DT
><DD
><DL
><DT
>12.3.1. <A
HREF="#AEN1759"
>Introduction</A
></DT
><DT
>12.3.2. <A
HREF="#DYNSECTENT"
>Dynamic Entries</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="ELFINTRO"
></A
>Chapter 9. Introduction</H1
><P
>Executable and Linking Format (ELF) defines the object format for compiled
applications. This specification supplements the information found in
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
> and is intended to document additions made
since the publication of that document.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOWLEVEL"
></A
>Chapter 10. Low Level System Information</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="OSINTERFACE"
>10.1. Operating System Interface</A
></H2
><P
>LSB-conforming applications shall assume that stack, heap and other allocated
memory regions will be non-executable. The application must take steps to
make them executable if needed.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MACHINEINTERFACE"
>10.2. Machine Interface</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="DATAREPRESENTATION"
>10.2.1. Data Representation</A
></H3
><P
>LSB-conforming applications shall use the data representation as defined in 
the Arcitecture specific ELF documents.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="FUNDAMENTALTYES"
>10.2.1.1. Fundamental Types</A
></H4
><P
>In addition to the fundamental types specified in the architecture specific supplement,
a 1 byte data type is defined here.
<DIV
CLASS="TABLE"
><A
NAME="AEN544"
></A
><P
><B
>Table 10-1. Scalar Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Type</TH
><TH
>C</TH
><TH
>C++</TH
><TH
><SAMP
CLASS="COMPUTEROUTPUT"
>sizeof</SAMP
></TH
><TH
>Alignment (bytes)</TH
><TH
>Architecture Representation</TH
></TR
></THEAD
><TBODY
><TR
><TD
ROWSPAN="3"
VALIGN="MIDDLE"
>Integral</TD
><TD
>_Bool</TD
><TD
>bool</TD
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
><SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
></TD
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
>1</TD
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
>byte</TD
></TR
></TBODY
></TABLE
></DIV
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TOCOBJFORMAT"
></A
>Chapter 11. Object Format</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="OBJFMT"
>11.1. Object Files</A
></H2
><P
>LSB-conforming implementations shall support the object file Executable and Linking Format (ELF), which is defined by the following documents:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
><A
HREF="#STD.GABI41"
>System V ABI</A
></P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
><A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
></P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>this specification</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>an architecture specific supplement to this specification</P
></LI
></UL
>
Conforming implementations may also support other unspecified object file formats.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTIONS"
>11.2. Sections</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN583"
>11.2.1. Introduction</A
></H3
><P
>As described in <A
HREF="#STD.GABI41"
>System V ABI</A
>,
an ELF object file contains a number of <I
CLASS="EMPHASIS"
>sections</I
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ELFTYPES"
>11.2.2. Sections Types</A
></H3
><P
>The section header table is an array of 
<TT
CLASS="STRUCTNAME"
>Elf32_Shdr</TT
> or 
<TT
CLASS="STRUCTNAME"
>Elf64_Shdr</TT
> structures as 
described in <A
HREF="#STD.GABI41"
>System V ABI</A
>. The 
<CODE
CLASS="STRUCTFIELD"
>sh_type</CODE
> member shall be either a value from
<A
HREF="#TBL.ABIUPDATE"
>Table 11-1</A
>, drawn from the System V 
ABI, or one of the additional values specified in <A
HREF="#TBL.LSB"
>Table 11-2</A
>.</P
><P
>A section header's <CODE
CLASS="STRUCTFIELD"
>sh_type</CODE
> member specifies the sections's semantics.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN599"
>11.2.2.1. ELF Section Types</A
></H4
><P
>The following section types are defined in the 
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and the
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>.
<DIV
CLASS="TABLE"
><A
NAME="TBL.ABIUPDATE"
></A
><P
><B
>Table 11-1. ELF Section Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Value</TH
><TH
ALIGN="CENTER"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="SECTTYPE.SHTDYNAMIC"
></A
><TD
>SHT_DYNAMIC</TD
><TD
>0x6</TD
><TD
>The section holds information for dynamic linking. Currently, an object file shall have only one dynamic section, but this restriction may be relaxed in the future. See `Dynamic Section' in Chapter 5 for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTDYNSYM"
></A
><TD
>SHT_DYNSYM</TD
><TD
>0xb</TD
><TD
>This section holds a minimal set of symbols adequate for dynamic linking. See 

also SHT_SYMTAB. Currently, an object file may have either a section of 

SHT_SYMTAB type or a section of SHT_DYNSYM type, but not both. This restriction 

may be relaxed in the future.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTFINIARRAY"
></A
><TD
>SHT_FINI_ARRAY</TD
><TD
>0xf</TD
><TD
>This section contains an array of pointers to termination functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless procedure with a void return.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTHASH"
></A
><TD
>SHT_HASH</TD
><TD
>0x5</TD
><TD
>The section holds a symbol hash table. Currently, an object file shall have only one hash table, but this restriction may be relaxed in the future. See `Hash Table' in the Chapter 5 for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTINITARRAY"
></A
><TD
>SHT_INIT_ARRAY</TD
><TD
>0xe</TD
><TD
>This section contains an array of pointers to initialization functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless procedure with a void return.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTNOBITS"
></A
><TD
>SHT_NOBITS</TD
><TD
>0x8</TD
><TD
>A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTNOTE"
></A
><TD
>SHT_NOTE</TD
><TD
>0x7</TD
><TD
>The section holds information that marks the file in some way. See `Note Section' in Chapter 5 for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTNULL"
></A
><TD
>SHT_NULL</TD
><TD
>0x0</TD
><TD
>This value marks the section header as inactive; it does not have an associated section. Other members of the section header have undefined values.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTPREINITARRAY"
></A
><TD
>SHT_PREINIT_ARRAY</TD
><TD
>0x10</TD
><TD
>This section contains an array of pointers to functions that are invoked before all other initialization functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless proceure with a void return.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTPROGBITS"
></A
><TD
>SHT_PROGBITS</TD
><TD
>0x1</TD
><TD
>The section holds information defined by the program, whose format and meaning are determined solely by the program.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTREL"
></A
><TD
>SHT_REL</TD
><TD
>0x9</TD
><TD
>The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files or type Elf64_Rel for the 64-bit class of object files. An object file may have multiple relocation sections. See "Relocation"</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTRELA"
></A
><TD
>SHT_RELA</TD
><TD
>0x4</TD
><TD
>The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files or type Elf64_Rela for the 64-bit class of object files. An object file may have multiple relocation sections. `Relocation' b</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTSTRTAB"
></A
><TD
>SHT_STRTAB</TD
><TD
>0x3</TD
><TD
>The section holds a string table. An object file may have multiple string table sections. See `String Table' below for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTSYMTAB"
></A
><TD
>SHT_SYMTAB</TD
><TD
>0x2</TD
><TD
>This section holds a symbol table. Currently, an object file may have either a 

section of SHT_SYMTAB type or a section of SHT_DYNSYM type, but not both. This 

restriction may be relaxed in the future. Typically, SHT_SYMTAB provides 

symbols for link editing, though it may also be used for dynamic linking. As a 

complete symbol table, it may contain many symbols unnecessary for dynamic 

linking.</TD
></TR
></TBODY
></TABLE
></DIV
>&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN669"
>11.2.2.2. Additional Section Types</A
></H4
><P
>The following additional section types are defined here.

<DIV
CLASS="TABLE"
><A
NAME="TBL.LSB"
></A
><P
><B
>Table 11-2. Additional Section Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Value</TH
><TH
ALIGN="CENTER"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="SECTTYPE.SHTGNUVERDEF"
></A
><TD
>SHT_GNU_verdef</TD
><TD
>0x6ffffffd</TD
><TD
>This section contains the symbol versions that are provided.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTGNUVERNEED"
></A
><TD
>SHT_GNU_verneed</TD
><TD
>0x6ffffffe</TD
><TD
>This section contains the symbol versions that are required.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTGNUVERSYM"
></A
><TD
>SHT_GNU_versym</TD
><TD
>0x6fffffff</TD
><TD
>This section contains the Symbol Version Table.</TD
></TR
></TBODY
></TABLE
></DIV
>&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPECIALSECTIONS"
>11.3. Special Sections</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="ELFSPECIAL"
>11.3.1. Special Sections</A
></H3
><P
>Various sections hold program and control information. Sections in the lists below are used by the system and have the indicated types and attributes.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN698"
>11.3.1.1. ELF Special Sections</A
></H4
><P
>The following sections are defined in the
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and the
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>.
<DIV
CLASS="TABLE"
><A
NAME="AEN703"
></A
><P
><B
>Table 11-3. ELF Special Sections</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Attributes</TH
></TR
></THEAD
><TBODY
><TR
><TD
>.bss</TD
><TD
>SHT_NOBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.comment</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.data</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.data1</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.debug</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.dynamic</TD
><TD
>SHT_DYNAMIC</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.dynstr</TD
><TD
>SHT_STRTAB</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.dynsym</TD
><TD
>SHT_DYNSYM</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.fini</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_EXECINSTR</TD
></TR
><TR
><TD
>.fini_array</TD
><TD
>SHT_FINI_ARRAY</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.hash</TD
><TD
>SHT_HASH</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.init</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_EXECINSTR</TD
></TR
><TR
><TD
>.init_array</TD
><TD
>SHT_INIT_ARRAY</TD
><TD
> SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.interp</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.line</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.note</TD
><TD
>SHT_NOTE</TD
><TD
>0</TD
></TR
><TR
><TD
>.preinit_array</TD
><TD
>SHT_PREINIT_ARRAY</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.rodata</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.rodata1</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.shstrtab</TD
><TD
>SHT_STRTAB</TD
><TD
>0</TD
></TR
><TR
><TD
>.strtab</TD
><TD
>SHT_STRTAB</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.symtab</TD
><TD
>SHT_SYMTAB</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.tbss</TD
><TD
>SHT_NOBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE+SHF_TLS</TD
></TR
><TR
><TD
>.tdata</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE+SHF_TLS</TD
></TR
><TR
><TD
>.text</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_EXECINSTR</TD
></TR
></TBODY
></TABLE
></DIV
>
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN813"
></A
><SPAN
STYLE="white-space: nowrap"
>.bss</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds data that contributes to the program's memory image. The 

program may treat this data as uninitialized. However, the system shall 

initialize this data with zeroes when the program begins to run.

The section occupies no file space, as indicated by the section type, SHT_NOBITS</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN817"
></A
><SPAN
STYLE="white-space: nowrap"
>.comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds version control information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN821"
></A
><SPAN
STYLE="white-space: nowrap"
>.data</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized data that contribute to the program's memory image.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN825"
></A
><SPAN
STYLE="white-space: nowrap"
>.data1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized data that contribute to the program's memory image.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN829"
></A
><SPAN
STYLE="white-space: nowrap"
>.debug</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds information for symbolic debugging. The contents are unspecified. All section names with the prefix .debug hold information for symbolic debugging. The contents of these sections are unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN833"
></A
><SPAN
STYLE="white-space: nowrap"
>.dynamic</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds dynamic linking information. The section's attributes will include the SHF_ALLOC bit. Whether the SHF_WRITE bit is set is processor specific. See Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN837"
></A
><SPAN
STYLE="white-space: nowrap"
>.dynstr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds strings needed for dynamic linking, most commonly the strings that represent the names associated with symbol table entries. See Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN841"
></A
><SPAN
STYLE="white-space: nowrap"
>.dynsym</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the dynamic linking symbol table, as described in `Symbol Table'. See Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN845"
></A
><SPAN
STYLE="white-space: nowrap"
>.fini</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN849"
></A
><SPAN
STYLE="white-space: nowrap"
>.fini_array</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds an array of function pointers that contributes to a single termination array for the executable or shared object containing the section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN853"
></A
><SPAN
STYLE="white-space: nowrap"
>.hash</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds a symbol hash table. See `Hash Table' in Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN857"
></A
><SPAN
STYLE="white-space: nowrap"
>.init</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds executable instructions that contribute to the process initialization code. When a program starts to run, the system arranges to execute the code in this section before calling the main program entry point (called main for C programs)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN861"
></A
><SPAN
STYLE="white-space: nowrap"
>.init_array</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds an array of function pointers that contributes to a single initialization array for the executable or shared object containing the section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN865"
></A
><SPAN
STYLE="white-space: nowrap"
>.interp</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the path name of a program interpreter. If the file has a loadable segment that includes relocation, the sections' attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. See Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN869"
></A
><SPAN
STYLE="white-space: nowrap"
>.line</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds line number information for symbolic debugging, which describes the correspondence between the source program and the machine code. The contents are unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN873"
></A
><SPAN
STYLE="white-space: nowrap"
>.note</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds information in the format that `Note Section' in Chapter 5 describes of the System V Application Binary Interface, Edition 4.1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN877"
></A
><SPAN
STYLE="white-space: nowrap"
>.preinit_array</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds an array of function pointers that contributes to a single pre-initialization array for the executable or shared object containing the section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN881"
></A
><SPAN
STYLE="white-space: nowrap"
>.rodata</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds read-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN885"
></A
><SPAN
STYLE="white-space: nowrap"
>.rodata1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section hold sread-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN889"
></A
><SPAN
STYLE="white-space: nowrap"
>.shstrtab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds section names.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN893"
></A
><SPAN
STYLE="white-space: nowrap"
>.strtab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds strings, most commonly the strings that represent the names associated with symbol table entries. If the file has a loadable segment that includes the symbol string table, the section's attributes will include the SHF_ALLOC bit; otherwi</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN897"
></A
><SPAN
STYLE="white-space: nowrap"
>.symtab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds a symbol table, as `Symbol Table'. in this chapter describes. If the file has a loadable segment that includes the symbol table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN901"
></A
><SPAN
STYLE="white-space: nowrap"
>.tbss</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds uninitialized thread-local data that contribute to the program's memory image. By definition, the system initializes the data with zeros when the data is instantiated for each new execution flow. The section occupies no file space, as indicated by the section type, SHT_NOBITS. Implementations need not support thread-local storage.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN905"
></A
><SPAN
STYLE="white-space: nowrap"
>.tdata</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized thread-local data that contributes to the program's memory image. A copy of its contents is instantiated by the system for each new execution flow. Implementations need not support thread-local storage.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN909"
></A
><SPAN
STYLE="white-space: nowrap"
>.text</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the `text,' or executable instructions, of a program.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN913"
>11.3.1.2. Additional Special Sections</A
></H4
><P
>Object files in an LSB conforming application may also contain one or more of 
the additional special sections described below.
<DIV
CLASS="TABLE"
><A
NAME="AEN916"
></A
><P
><B
>Table 11-4. Additional Special Sections</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Attributes</TH
></TR
></THEAD
><TBODY
><TR
><TD
>.ctors</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.data.rel.ro</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.dtors</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.eh_frame</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.eh_frame_hdr</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gcc_except_table</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gnu.version</TD
><TD
>SHT_GNU_versym</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gnu.version_d</TD
><TD
>SHT_GNU_verdef</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gnu.version_r</TD
><TD
>SHT_GNU_verneed</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.got.plt</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.jcr</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.note.ABI-tag</TD
><TD
>SHT_NOTE</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.stab</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.stabstr</TD
><TD
>SHT_STRTAB</TD
><TD
>0</TD
></TR
></TBODY
></TABLE
></DIV
>
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN982"
></A
><SPAN
STYLE="white-space: nowrap"
>.ctors</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains a list of global constructor function pointers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN986"
></A
><SPAN
STYLE="white-space: nowrap"
>.data.rel.ro</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized data that contribute to the program's memory image. This section may be made read-only after relocations have been applied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN990"
></A
><SPAN
STYLE="white-space: nowrap"
>.dtors</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains a list of global destructor function pointers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN994"
></A
><SPAN
STYLE="white-space: nowrap"
>.eh_frame</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains information necessary for frame unwinding during exception handling. See <A
HREF="#EHFRAME"
>Section 11.6.1</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN999"
></A
><SPAN
STYLE="white-space: nowrap"
>.eh_frame_hdr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains a pointer to the .eh_frame section which is accessible to the runtime support code of a C++ application. This section may also contain a binary search table which may be used by the runtime support code to more efficiently access records in the .eh_frame section. See <A
HREF="#EHFRAMEHDR"
>Section 11.6.2</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1004"
></A
><SPAN
STYLE="white-space: nowrap"
>.gcc_except_table</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds Language Specific Data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1008"
></A
><SPAN
STYLE="white-space: nowrap"
>.gnu.version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains the Symbol Version Table. See <A
HREF="#SYMVERTBL"
>Section 11.7.2</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1013"
></A
><SPAN
STYLE="white-space: nowrap"
>.gnu.version_d</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains the Version Definitions. See <A
HREF="#SYMVERDEFS"
>Section 11.7.3</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1018"
></A
><SPAN
STYLE="white-space: nowrap"
>.gnu.version_r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains the Version Requirements. See <A
HREF="#SYMVERRQMTS"
>Section 11.7.4</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1023"
></A
><SPAN
STYLE="white-space: nowrap"
>.got.plt</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the read-only portion of the GLobal Offset Table. This section may be made read-only after relocations have been applied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1027"
></A
><SPAN
STYLE="white-space: nowrap"
>.jcr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains information necessary for registering compiled

Java classes.  The contents are compiler-specific and used by compiler

initialization functions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1031"
></A
><SPAN
STYLE="white-space: nowrap"
>.note.ABI-tag</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specify ABI details. See <A
HREF="#NOTEABITAG"
>Section 11.8</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1036"
></A
><SPAN
STYLE="white-space: nowrap"
>.stab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains debugging information. The contents are not specified as part of the LSB.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1040"
></A
><SPAN
STYLE="white-space: nowrap"
>.stabstr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains strings associated with the debugging infomation contained in the .stab section.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYMMAP"
>11.4. Symbol Mapping</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1046"
>11.4.1. Introduction</A
></H3
><P
>Symbols in a source program are translated by the compilation system into
symbols that exist in the object file. </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1049"
>11.4.1.1. C Language</A
></H4
><P
>External C symbols shall be unchanged in an object file's symbol table.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DWARFEXT"
>11.5. DWARF Extensions</A
></H2
><P
>The LSB does not specify debugging information, however, some additional
sections contain information which is encoded using the the encoding as
specified by <A
HREF="#STD.DWARF2"
>DWARF Debugging Information Format, Revision 2.0.0</A
> with extensions defined here.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The extensions specified here also exist in <A
HREF="#STD.DWARF3"
>DWARF Debugging Information Format, Revision 3.0.0 (Draft)</A
>.
It is expected that future versions of the LSB will reference the final
version of that document, and that the definitions here will be taken
from that document instead of being specified here.</P
></BLOCKQUOTE
></DIV
>&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DWARFEHENCODING"
>11.5.1. DWARF Exception Header Encoding</A
></H3
><P
>The DWARF Exception Header Encoding is used to describe the type of data used
in the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
>  and
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section. The upper 4
bits indicate how the value is to be applied. The lower 4 bits indicate the
format of the data.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1064"
></A
><P
><B
>Table 11-5. DWARF Exception Header value format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DW_EH_PE_absptr</TD
><TD
>0x00</TD
><TD
>The Value is a literal pointer whose size is determined by the architecture.</TD
></TR
><TR
><TD
>DW_EH_PE_uleb128</TD
><TD
>0x01</TD
><TD
>Unsigned value is encoded using the Little Endian Base 128 (LEB128)
as defined by <A
HREF="#STD.DWARF2"
>DWARF Debugging Information Format, Revision 2.0.0</A
>.</TD
></TR
><TR
><TD
>DW_EH_PE_udata2</TD
><TD
>0x02</TD
><TD
>A 2 bytes unsigned value.</TD
></TR
><TR
><TD
>DW_EH_PE_udata4</TD
><TD
>0x03</TD
><TD
>A 4 bytes unsigned value.</TD
></TR
><TR
><TD
>DW_EH_PE_udata8</TD
><TD
>0x04</TD
><TD
>An 8 bytes unsigned value.</TD
></TR
><TR
><TD
>DW_EH_PE_sleb128</TD
><TD
>0x09</TD
><TD
>Signed value is encoded using the Little Endian Base 128 (LEB128)
as defined by <A
HREF="#STD.DWARF2"
>DWARF Debugging Information Format, Revision 2.0.0</A
>.</TD
></TR
><TR
><TD
>DW_EH_PE_sdata2</TD
><TD
>0x0A</TD
><TD
>A 2 bytes signed value.</TD
></TR
><TR
><TD
>DW_EH_PE_sdata4</TD
><TD
>0x0B</TD
><TD
>A 4 bytes signed value.</TD
></TR
><TR
><TD
>DW_EH_PE_sdata8</TD
><TD
>0x0C</TD
><TD
>An 8 bytes signed value.</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN1111"
></A
><P
><B
>Table 11-6. DWARF Exception Header application</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DW_EH_PE_pcrel</TD
><TD
>0x10</TD
><TD
>Value is relative to the current program counter.</TD
></TR
><TR
><TD
>DW_EH_PE_textrel</TD
><TD
>0x20</TD
><TD
>Value is relative to the beginning of the .text section.</TD
></TR
><TR
><TD
>DW_EH_PE_datarel</TD
><TD
>0x30</TD
><TD
>Value is relative to the beginning of the .got or .eh_frame_hdr section.</TD
></TR
><TR
><TD
>DW_EH_PE_funcrel</TD
><TD
>0x40</TD
><TD
>Value is relative to the beginning of the function.</TD
></TR
><TR
><TD
>DW_EH_PE_aligned</TD
><TD
>0x50</TD
><TD
>Value is aligned to an address unit sized boundary.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>One special encoding, 0xff (DW_EH_PE_omit), shall be used to indicate that no value ispresent.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DWARFCFIEXT"
>11.5.2. DWARF CFI Extensions</A
></H3
><P
>In addition to the Call Frame Instructions defined in section 6.4.2 of <A
HREF="#STD.DWARF2"
>DWARF Debugging Information Format, Revision 2.0.0</A
>,
the following additional Call Frame Instructions may also be used.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1145"
></A
><P
><B
>Table 11-7. Additional DWARF Call Frame Instructions</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DW_CFA_expression</TD
><TD
>0x10</TD
><TD
>The DW_CFA_expression instruction takes two operands: an unsigned LEB128 value representing a
register number, and a DW_FORM_block value representing a DWARF expression. The required action is to
establish the DWARF expression as the means by which the address in which the given register contents
are found may be computed. The value of the CFA is pushed on the DWARF evaluation stack prior to
execution of the DWARF expression. The DW_OP_call2, DW_OP_call4, DW_OP_call_ref and
DW_OP_push_object_address DWARF operators (see Section 2.4.1 of <A
HREF="#STD.DWARF2"
>DWARF Debugging Information Format, Revision 2.0.0</A
>) cannot be
used in such a DWARF expression.</TD
></TR
><TR
><TD
>DW_CFA_offset_extended_sf</TD
><TD
>0x11</TD
><TD
>The DW_CFA_offset_extended_sf instruction takes two operands: an unsigned LEB128 value representing a
register number and a signed LEB128 factored offset. This instruction is identical to
DW_CFA_offset_extended except that the second operand is signed.</TD
></TR
><TR
><TD
>DW_CFA_def_cfa_sf</TD
><TD
>0x12</TD
><TD
>The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128 value representing a register
number and a signed LEB128 factored offset. This instruction is identical to DW_CFA_def_cfa except that
the second operand is signed and factored.</TD
></TR
><TR
><TD
>DW_CFA_def_cfa_offset_sf</TD
><TD
>0x13</TD
><TD
>The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand representing a factored offset.
This instruction is identical to DW_CFA_def_cfa_offset except that the operand is signed and factored.</TD
></TR
><TR
><TD
>DW_CFA_GNU_args_size</TD
><TD
>0x2e</TD
><TD
>The DW_CFA_GNU_args_size instruction takes an unsigned LEB128 operand
representing an argument size. This instruction specifies the total of the
size of the arguments which have been pushed onto the stack.</TD
></TR
><TR
><TD
>DW_CFA_GNU_negative_offset_extended</TD
><TD
>0x2f</TD
><TD
>The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128 value representing a register
number and an unsigned LEB128 which represents the magnitude of the offset. This instruction is identical
to DW_CFA_offset_extended_sf except that the operand is subtracted to produce the offset. This
instructions is obsoleted by DW_CFA_offset_extended_sf.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="EHFRAMECHPT"
>11.6. Exception Frames</A
></H2
><P
>When using languages that support exceptions, such as C++, additional
information must be provided to the runtime environment that describes
the call frames that must be unwound during the processing of an exception.
This information is contained in the special sections
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> and
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_framehdr</SAMP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The format of the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section is similar
in format and purpose to the <SAMP
CLASS="COMPUTEROUTPUT"
>.debug_frame</SAMP
>
section which is specified in <A
HREF="#STD.DWARF3"
>DWARF Debugging Information Format, Revision 3.0.0 (Draft)</A
>.
Readers are advised that there are some subtle difference,
and care should be taken when comparing the two sections.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EHFRAME"
>11.6.1. The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section</A
></H3
><P
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section shall contain 1 or more
Call Frame Information (CFI) records. The number of records present shall be
determined by size of the section as contained in the section header.
Each CFI record contains a Common Information Entry (CIE) record followed by
1 or more Frame Description Entry (FDE) records. Both CIEs and FDEs shall
be aligned to an addressing unit sized boundary.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1194"
></A
><P
><B
>Table 11-8. Call Frame Information Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Common Information Entry Record</TD
></TR
><TR
><TD
>Frame Description Entry Record(s)</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1202"
>11.6.1.1. The Common Information Entry Format</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="AEN1204"
></A
><P
><B
>Table 11-9. Common Information Entry Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Length</TD
><TD
>Required</TD
></TR
><TR
><TD
>Extended Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>CIE ID</TD
><TD
>Required</TD
></TR
><TR
><TD
>Version</TD
><TD
>Required</TD
></TR
><TR
><TD
>Augmentation String</TD
><TD
>Required</TD
></TR
><TR
><TD
>Code Alignment Factor</TD
><TD
>Required</TD
></TR
><TR
><TD
>Data Alignment Factor</TD
><TD
>Required</TD
></TR
><TR
><TD
>Return Address Register</TD
><TD
>Required</TD
></TR
><TR
><TD
>Augmentation Data Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Augmentation Data</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Initial Instructions</TD
><TD
>Required</TD
></TR
><TR
><TD
>Padding</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="STRUCTFIELD"
>Length</CODE
></DT
><DD
><P
>A 4 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field itself. If
<CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0xffffffff, then the
length is contained in the <CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> field.
If <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0, then this CIE shall
be considered a terminator and processing shall end.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
></DT
><DD
><P
>A 8 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> fields. </P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>CIE ID</CODE
></DT
><DD
><P
>A 4 byte unsigned value that is used to distinguish CIE records from FDE
records.  This value shall always be 0, which indicates this record is a CIE.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Version</CODE
></DT
><DD
><P
>A 1 byte value that identifies the version number of the frame information
structure. This value shall be 1.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation String</CODE
></DT
><DD
><P
>This value is a NUL terminated string that identifies the augmentation to
the CIE or to the FDEs associated with this CIE. A zero length string
indicates that no augmentation data is present.  The augmentation string
is case sensitive and shall be interpreted as described below.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Code Alignment Factor</CODE
></DT
><DD
><P
>An unsigned LEB128 encoded value that is factored out of all advance location
instructions that are associated with this CIE or its FDEs. This value shall be
multiplied by the delta argument of an adavance location instruction to obtain
the new location value.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Data Alignment Factor</CODE
></DT
><DD
><P
>A signed LEB128 encoded value that is factored out of all offset instructions
that are associated with this CIE or its FDEs. This value shall be multiplied
by the register offset argument of an offset instruction to obtain
the new offset value.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Length</CODE
></DT
><DD
><P
>An unsigned LEB128 encoded value indicating the length in bytes of the
Augmentation Data. This field is only present if the Augmentation String
contains the character 'z'.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Data</CODE
></DT
><DD
><P
>A block of data whose contents are defined by the contents of the
Augmentation String as described below. This field is only present if the
Augmentation String contains the character 'z'. The size of this data is given
by the Augentation Length.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Initial Instructions</CODE
></DT
><DD
><P
>Initial set of Call Frame Instructions. The number of instructions is
determined by the remaining space in the CIE record.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Padding</CODE
></DT
><DD
><P
>Extra bytes to align the CIE structure to an addressing unit size boundary.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN1305"
>11.6.1.1.1. Augmentation String Format</A
></H5
><P
>The Agumentation String indicates the presence of some optional fields, and
how those fields should be intepreted. This string is case sensitive.  Each
character in the augmentation string in the CIE can be interpreted as below:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1309"
></A
><SPAN
STYLE="white-space: nowrap"
>'z'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'z' may be present as the first character of the string. If present, the
Augmentation Data field shall be present. The contents of the Augmentation Data
shall be intepreted according to other characters in the Augmentation String.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1313"
></A
><SPAN
STYLE="white-space: nowrap"
>'L'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'L' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, it
indicates the presence of one argument in the Augmentation Data of the CIE,
and a corresponding argument in the Augmentation Data of the FDE.
The argument in the Augmentation Data of the CIE is 1-byte and represents the
pointer encoding used for the argument in the Augmentation Data of the FDE,
which is the address of a language-specific data area (LSDA).
The size of the LSDA pointer is specified by the pointer encoding used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1317"
></A
><SPAN
STYLE="white-space: nowrap"
>'P'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'P' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, it
indicates the presence of two arguments in the Augmentation Data of the CIE.
The first argument is 1-byte and represents the pointer encoding used for the
second argument, which is the address of a 
<I
CLASS="FIRSTTERM"
>personality routine</I
> handler. 
The personality routine is used to handle language and 
vendor-specific tasks. The system unwind library interface accesses the 
language-specific exception handling semantics via the pointer to the 
personality routine. The personality routine does not have an ABI-specific 
name.
The size of the personality routine pointer is specified by the pointer encoding
used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1322"
></A
><SPAN
STYLE="white-space: nowrap"
>'R'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'R' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, The
Augmentation Data shall include a 1 byte argument that represents the pointer
encoding for the address pointers used in the FDE.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1326"
>11.6.1.2. The Frame Description Entry Format</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="AEN1328"
></A
><P
><B
>Table 11-10. Frame Description Entry Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Length</TD
><TD
>Required</TD
></TR
><TR
><TD
>Extended Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>CIE Pointer</TD
><TD
>Required</TD
></TR
><TR
><TD
>PC Begin</TD
><TD
>Required</TD
></TR
><TR
><TD
>PC Range</TD
><TD
>Required</TD
></TR
><TR
><TD
>Augmentation Data Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Augmentation Data</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Call Frame Instructions</TD
><TD
>Required</TD
></TR
><TR
><TD
>Padding</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="STRUCTFIELD"
>Length</CODE
></DT
><DD
><P
>A 4 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field itself. If
<CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0xffffffff, then the
length is contained the <CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> field.
If <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0, then this CIE shall
be considered a terminator and processing shall end.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
></DT
><DD
><P
>A 8 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field itself. </P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>CIE Pointer</CODE
></DT
><DD
><P
>A 4 byte unsigned value that when subtracted from the offset of the current FDE
yields the offset of the start of the associated CIE.  This value shall never be 0.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>PC Begin</CODE
></DT
><DD
><P
>An encoded value that indicates the address of the initial location
associated with this FDE. The encoding format is specified in the
Augmentation Data.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>PC Range</CODE
></DT
><DD
><P
>An absolute value that indicates the number of bytes of instructions 
associated with this FDE.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Length</CODE
></DT
><DD
><P
>An unsigned LEB128 encoded value indicating the length in bytes of the
Augmentation Data. This field is only present if the Augmentation String
in the associated CIE contains the character 'z'.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Data</CODE
></DT
><DD
><P
>A block of data whose contents are defined by the contents of the
Augmentation String in the associated CIE as described above.
This field is only present if the Augmentation String in the associated CIE
contains the character 'z'. The size of this data is given by the
Augentation Length.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Call Frame Instructions</CODE
></DT
><DD
><P
>A set of Call Frame Instructions.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Padding</CODE
></DT
><DD
><P
>Extra bytes to align the FDE structure to an addressing unit size boundary.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EHFRAMEHDR"
>11.6.2. The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section</A
></H3
><P
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section contains additional
information about the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section.
A pointer to the start of the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> data,
and optionally, a binary search table of pointers to the
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> records are found in this section.</P
><P
>Data in this section is encoded according to <A
HREF="#DWARFEHENCODING"
>Section 11.5.1</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1419"
></A
><P
><B
>Table 11-11. <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> Section Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Encoding</TH
><TH
>Field</TH
></TR
></THEAD
><TBODY
><TR
><TD
>unsigned byte</TD
><TD
>version</TD
></TR
><TR
><TD
>unsigned byte</TD
><TD
>eh_frame_ptr_enc</TD
></TR
><TR
><TD
>unsigned byte</TD
><TD
>fde_count_enc</TD
></TR
><TR
><TD
>unsigned byte</TD
><TD
>table_enc</TD
></TR
><TR
><TD
>encoded</TD
><TD
>eh_frame_ptr</TD
></TR
><TR
><TD
>encoded</TD
><TD
>fde_count</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>binary search table</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1450"
></A
><SPAN
STYLE="white-space: nowrap"
>version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version of the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> format. This
value shall be 1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1455"
></A
><SPAN
STYLE="white-space: nowrap"
>eh_frame_ptr_enc</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoding format of the eh_frame_ptr field.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1459"
></A
><SPAN
STYLE="white-space: nowrap"
>fde_count_enc</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoding format of the fde_count field.
A value of DW_EH_PE_omit indicates the binary search table is not present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1463"
></A
><SPAN
STYLE="white-space: nowrap"
>table_enc</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoding format of the entries in the binary search table.
A value of DW_EH_PE_omit indicates the binary search table is not present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1467"
></A
><SPAN
STYLE="white-space: nowrap"
>eh_frame_ptr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoded value of the pointer to the start of the
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1472"
></A
><SPAN
STYLE="white-space: nowrap"
>fde_count</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoded value of the count of entries in the binary search table.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1476"
></A
><SPAN
STYLE="white-space: nowrap"
>binary search table</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A binary search table containing fde_count entries. Each entry of the table
consist of two encoded values, the initial location, and the address.
The entries are sorted in an increasing order by the initial location value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYMVERSION"
>11.7. Symbol Versioning</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1482"
>11.7.1. Introduction</A
></H3
><P
>This chapter describes the Symbol Versioning mechanism. All ELF objects may
provide or depend on versioned symbols. Symbol Versioning is implemented by 3
section types: 
<TT
CLASS="SYMBOL"
>SHT_GNU_versym</TT
>, <TT
CLASS="SYMBOL"
>SHT_GNU_verdef</TT
>, and <TT
CLASS="SYMBOL"
>SHT_GNU_verneed</TT
>.</P
><P
>The prefix <TT
CLASS="SYMBOL"
>Elfxx</TT
> in the following descriptions and code fragments stands for 
either "<TT
CLASS="SYMBOL"
>Elf32</TT
>" or "<TT
CLASS="SYMBOL"
>Elf64</TT
>", depending on the architecture.</P
><P
>Versions are described by strings. The structures that are used for symbol
versions also contain a member that holds the ELF hashing values of the
strings. This allows for more efficient processing.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMVERTBL"
>11.7.2. Symbol Version Table</A
></H3
><P
>The special section <TT
CLASS="SYMBOL"
>.gnu.version</TT
>
which has a section type of <TT
CLASS="SYMBOL"
>SHT_GNU_versym</TT
>
shall contain the Symbol Version Table. This section shall have the same number 
of entries as the Dynamic Symbol Table in the <TT
CLASS="SYMBOL"
>.dynsym</TT
> section.</P
><P
>The <TT
CLASS="SYMBOL"
>.gnu.version</TT
> section shall contain an array of elements of type 
<TT
CLASS="SYMBOL"
>Elfxx_Half</TT
>.
Each entry specifies the version defined for or required by the corresponding 
symbol in the Dynamic Symbol Table.</P
><P
>The values in the Symbol Version Table are specific to the object in which they 
are located. These values are identifiers that are provided by the the 
<CODE
CLASS="STRUCTFIELD"
>vna_other</CODE
> member of the 
<TT
CLASS="STRUCTNAME"
>Elfxx_Vernaux</TT
> structure or the 
<CODE
CLASS="STRUCTFIELD"
>vd_ndx</CODE
> member of the 
<TT
CLASS="STRUCTNAME"
>Elfxx_Verdef</TT
> structure.</P
><P
>The values 0 and 1 are reserved.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1513"
></A
><SPAN
STYLE="white-space: nowrap"
>0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The symbol is local, not available outside the object.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1517"
></A
><SPAN
STYLE="white-space: nowrap"
>1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The symbol is defined in this object and is globally available.</P
></TD
></TR
></TBODY
></TABLE
><P
>All other values are used to identify version strings located in one of the
other Symbol Version sections. The value itself is not the version associated
with the symbol. The string identified by the value defines the version of
the symbol.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMVERDEFS"
>11.7.3. Version Definitions</A
></H3
><P
>The special section <TT
CLASS="SYMBOL"
>.gnu.version_d</TT
> which has a section type of 
<TT
CLASS="SYMBOL"
>SHT_GNU_verdef </TT
>
shall contain symbol version definitions. The number of entries in this section 
shall be contained in the <TT
CLASS="SYMBOL"
>DT_VERDEFNUM</TT
> entry of the Dynamic Section 
<TT
CLASS="SYMBOL"
>.dynamic</TT
>. 
The <TT
CLASS="SYMBOL"
>sh_link</TT
> member of the section header (see figure 4-8 in the 
<A
HREF="#STD.GABI41"
>System V ABI</A
>) 
shall point to the section that contains the strings referenced by this section.</P
><P
>The section shall contain an array of <TT
CLASS="SYMBOL"
>Elfxx_Verdef</TT
> structures, as described in 
<A
HREF="#VERDEFENTRIES"
>Figure 11-1</A
>, optionally followed by an array of <TT
CLASS="SYMBOL"
>Elfxx_Verdaux</TT
> structures, as 
defined in <A
HREF="#VERDEFEXTS"
>Figure 11-2</A
>.</P
><DIV
CLASS="FIGURE"
><A
NAME="VERDEFENTRIES"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Half    vd_version;
	Elfxx_Half    vd_flags;
	Elfxx_Half    vd_ndx;
	Elfxx_Half    vd_cnt;
	Elfxx_Word    vd_hash;
	Elfxx_Word    vd_aux;
	Elfxx_Word    vd_next;
} Elfxx_Verdef;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 11-1. Version Definition Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1540"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_version</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version revision. This field shall be set to <TT
CLASS="LITERAL"
>1</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1546"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_flags</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version information flag bitmask.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1551"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_ndx</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version index numeric value referencing the SHT_GNU_versym section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1556"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_cnt</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of associated verdaux array entries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1561"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_hash</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version name hash value (ELF hash function).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1566"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_aux</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset in bytes to a corresponding entry in an array
of <TT
CLASS="SYMBOL"
>Elfxx_Verdaux</TT
> structures as defined in
<A
HREF="#VERDEFEXTS"
>Figure 11-2</A
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1573"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next verdef entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="FIGURE"
><A
NAME="VERDEFEXTS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Word    vda_name;
	Elfxx_Word    vda_next;
} Elfxx_Verdaux;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 11-2. Version Definition Auxiliary Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1582"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vda_name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the version or dependency name string in the section header, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1587"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vda_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next verdaux entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMVERRQMTS"
>11.7.4. Version Requirements</A
></H3
><P
>The special section <TT
CLASS="SYMBOL"
>.gnu.version_r</TT
> which has a section type of 
<TT
CLASS="SYMBOL"
>SHT_GNU_verneed</TT
>
shall contain required symbol version definitions. The number of entries in 
this section shall be contained in the <TT
CLASS="SYMBOL"
>DT_VERNEEDNUM</TT
> entry of the Dynamic 
Section <TT
CLASS="SYMBOL"
>.dynamic</TT
>. 
The <CODE
CLASS="STRUCTFIELD"
>sh_link</CODE
> member of the section header (see figure 4-8 in 
<A
HREF="#STD.GABI41"
>System V ABI</A
>)
shall point to the section that contains the strings referenced by this section.</P
><P
>The section shall contain an array of <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> structures, as described in 
<A
HREF="#VERNEEDFIG"
>Figure 11-3</A
>, optionally followed by an array of 
<TT
CLASS="SYMBOL"
>Elfxx_Vernaux</TT
> structures, as 
defined in <A
HREF="#VERNEEDEXTFIG"
>Figure 11-4</A
>.</P
><DIV
CLASS="FIGURE"
><A
NAME="VERNEEDFIG"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Half    vn_version;
	Elfxx_Half    vn_cnt;
	Elfxx_Word    vn_file;
	Elfxx_Word    vn_aux;
	Elfxx_Word    vn_next;
} Elfxx_Verneed;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 11-3. Version Needed Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1610"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_version</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version of structure. This value is currently set to 1, and will be reset if the versioning implementation is incompatibly altered.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1615"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_cnt</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of associated verneed array entries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1620"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_file</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the file name string in the section header, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1625"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_aux</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to a corresponding entry in the vernaux array, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1630"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next verneed entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="FIGURE"
><A
NAME="VERNEEDEXTFIG"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Word    vna_hash;
	Elfxx_Half    vna_flags;
	Elfxx_Half    vna_other;
	Elfxx_Word    vna_name;
	Elfxx_Word    vna_next;
} Elfxx_Vernaux;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 11-4. Version Needed Auxiliary Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1639"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_hash</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Dependency name hash value (ELF hash function).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1644"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_flags</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Dependency information flag bitmask.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1649"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_other</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Object file version identifier used in the .gnu.version symbol version array. Bit number 15 controls whether or not the object is hidden; if this bit is set, the object cannot be used and the static linker will ignore the symbol's presence in the object.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1654"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the dependency name string in the section header, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1659"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next vernaux entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMSTARTSEQ"
>11.7.5. Startup Sequence</A
></H3
><P
>When loading a sharable object the system shall analyze version definition data 
from the loaded object to assure that it meets the version requirements of the 
calling object. This step is referred to as definition testing. The dynamic 
loader shall retrieve the entries in the caller's <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> array and 
attempt to find matching definition information in the loaded <TT
CLASS="SYMBOL"
>Elfxx_Verdef</TT
>
table.</P
><P
>Each object and dependency shall be tested in turn. If a symbol definition is 
missing and the <TT
CLASS="SYMBOL"
>vna_flags</TT
> bit for <TT
CLASS="SYMBOL"
>VER_FLG_WEAK</TT
> is not set, the loader shall 
return an error and exit. If the <TT
CLASS="SYMBOL"
>vna_flags</TT
> bit for <TT
CLASS="SYMBOL"
>VER_FLG_WEAK</TT
> is set in the 
<TT
CLASS="SYMBOL"
>Elfxx_Vernaux</TT
> entry, and the loader shall issue a warning and continue 
operation.</P
><P
>When the versions referenced by undefined symbols in the loaded object are 
found, version availability is certified. The test completes without error and 
the object shall be made available.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMRESOLUTION"
>11.7.6. Symbol Resolution</A
></H3
><P
>When symbol versioning is used in an object, relocations extend 
definition testing beyond the simple match of symbol
name strings: the version of the reference shall also equal the name of
the definition. </P
><P
>The same index that is used in the symbol table can be
referenced in the <TT
CLASS="SYMBOL"
>SHT_GNU_versym</TT
> section, and the value of this index is
then used to acquire name data. The corresponding requirement string is
retrieved from the <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> array, and likewise, the corresponding
definition string from the <TT
CLASS="SYMBOL"
>Elfxx_Verdef</TT
> table.</P
><P
>If the high order bit (bit number 15)
of the version symbolis set, the object cannot be used
and the static linker shall ignore the symbol's presence in the object.</P
><P
>When an object with a reference and an object with the definition are being 
linked, the following rules shall govern the result:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>The object with the reference and the object with the definitions both use 
versioning. All described matching is processed in this case. A fatal error 
shall be triggered when no matching definition can be found in the object whose 
name is the one referenced by the <CODE
CLASS="STRUCTFIELD"
>vn_name</CODE
> element in the 
<TT
CLASS="STRUCTNAME"
>Elfxx_Verneed</TT
> entry.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The object with the reference does not use versioning, while the object with 
the definitions does. In this instance, only the definitions with index numbers 
1 and 2 will be used in the reference match, the same identified by the static 
linker as the base definition. In cases where the static linker was not used, 
such as in calls to <TT
CLASS="FUNCTION"
>dlopen()</TT
>, a version that does not have the base definition 
index shall be acceptable if it is the only version for which the symbol is 
defined.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The object with the reference uses versioning, but the object with the 
definitions specifies none. A matching symbol shall be accepted in this case. A 
fatal error shall be triggered if a corruption in the required symbols list 
obscures an outdated object file and causes a match on the object filename in 
the <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> entry.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>Neither the object with the reference nor the object with the definitions use 
versioning. The behavior in this instance shall default to pre-existing symbol 
rules.</P
></LI
></UL
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="NOTEABITAG"
>11.8. ABI note tag</A
></H2
><P
>Every executable shall contain a section named
<SAMP
CLASS="COMPUTEROUTPUT"
>.note.ABI-tag</SAMP
> of type
<SAMP
CLASS="COMPUTEROUTPUT"
>SHT_NOTE</SAMP
>.  This section is structured
as a note section as documented in the ELF spec.  The section shall
contain at least the following entry.  The
<SAMP
CLASS="COMPUTEROUTPUT"
>name</SAMP
> field
(<SAMP
CLASS="COMPUTEROUTPUT"
>namesz</SAMP
>/<SAMP
CLASS="COMPUTEROUTPUT"
>name</SAMP
>)
contains the string "<SAMP
CLASS="COMPUTEROUTPUT"
>GNU</SAMP
>".  The
<SAMP
CLASS="COMPUTEROUTPUT"
>type</SAMP
> field shall be 1.  The
<SAMP
CLASS="COMPUTEROUTPUT"
>descsz</SAMP
> field shall be at least 16,
and the first 16 bytes of the <SAMP
CLASS="COMPUTEROUTPUT"
>desc</SAMP
>
field shall be as follows.</P
><P
>The first 32-bit word of the <SAMP
CLASS="COMPUTEROUTPUT"
>desc</SAMP
>
field shall be 0 (this signifies a Linux executable).  The second,
third, and fourth 32-bit words of the
<SAMP
CLASS="COMPUTEROUTPUT"
>desc</SAMP
> field contain the earliest
compatible kernel version.  For example, if the 3 words are 2, 2, and
5, this signifies a 2.2.5 kernel.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TOCDYNLNK"
></A
>Chapter 12. Dynamic Linking</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="DYNLNK"
>12.1. Program Loading and Dynamic Linking</A
></H2
><P
>LSB-conforming implementations shall support the object file information and
system actions that create running programs as specified in the
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>
and as further required by this specification and its architecture specific supplement.</P
><P
>Any shared object that is loaded shall contain sufficient DT_NEEDED records to
satisfy the symbols on the shared library.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROGHEADER"
>12.2. Program Header</A
></H2
><P
>In addition to the Segment Types defined in the
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>
the following Segment Types shall also be supported.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1726"
></A
><P
><B
>Table 12-1. Linux Segment Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Value</TH
></TR
></THEAD
><TBODY
><TR
><TD
>PT_GNU_EH_FRAME</TD
><TD
>0x6474e550</TD
></TR
><TR
><TD
>PT_GNU_STACK</TD
><TD
>0x6474e551</TD
></TR
><TR
><TD
>PT_GNU_RELRO</TD
><TD
>0x6474e552</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1744"
></A
><SPAN
STYLE="white-space: nowrap"
>PT_GNU_EH_FRAME</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The array element specifies the location and size of the exception handling
information as defined by the .eh_frame_hdr section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1748"
></A
><SPAN
STYLE="white-space: nowrap"
>PT_GNU_STACK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <CODE
CLASS="STRUCTFIELD"
>p_flags</CODE
> member specifies the permissions on the segment containing the stack
and is used to indicate wether the stack should be executable. The absense of
this header indicates that the stack will be executable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1753"
></A
><SPAN
STYLE="white-space: nowrap"
>PT_GNU_RELRO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The array element specifies the location and size of a segment which may be made read-only after relocation shave been processed.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DYNAMICSECTION"
>12.3. Dynamic Entries</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1759"
>12.3.1. Introduction</A
></H3
><P
>As described in <A
HREF="#STD.GABI41"
>System V ABI</A
>, if an object file CHAPTERicipates in dynamic 
linking, its program header table shall have an element of type <TT
CLASS="SYMBOL"
>PT_DYNAMIC</TT
>. 
This `segment' contains the <TT
CLASS="SYMBOL"
>.dynamic</TT
> section. A special symbol, 
<TT
CLASS="SYMBOL"
>_DYNAMIC</TT
>, 
labels the section, which contains an array of the following structures. 
<DIV
CLASS="FIGURE"
><A
NAME="AEN1766"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elf32_Sword	d_tag;
   	union {
   		Elf32_Word	d_val;
   		Elf32_Addr	d_ptr;
	} d_un;
} Elf32_Dyn;

extern Elf32_Dyn	_DYNAMIC[];

typedef struct {
	Elf64_Sxword	d_tag;
   	union {
   		Elf64_Xword	d_val;
   		Elf64_Addr	d_ptr;
	} d_un;
} Elf64_Dyn;

extern Elf64_Dyn	_DYNAMIC[];</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-1. Dynamic Structure</B
></P
></DIV
></P
><P
>For each object with this type, <CODE
CLASS="STRUCTFIELD"
>d_tag</CODE
>
controls the interpretation of <CODE
CLASS="STRUCTFIELD"
>d_un</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DYNSECTENT"
>12.3.2. Dynamic Entries</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1775"
>12.3.2.1. ELF Dynamic Entries</A
></H4
><P
>The following dynamic entries are defined in the 
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1781"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_BIND_NOW</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Process relocations of object</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1785"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_DEBUG</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>For debugging; unspecified</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1789"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FINI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of termination function</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1793"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_HASH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of symbol hash table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1797"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_HIPROC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>End of processor-specific</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1801"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_INIT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of init function</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1805"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_JMPREL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of PLT relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1809"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_LOPROC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Start of processor-specific</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1813"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_NEEDED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Name of needed library</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1817"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_NULL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Marks end of dynamic section</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1821"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_PLTREL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Type of reloc in PLT</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1825"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_PLTRELSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of PLT relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1829"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_REL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of Rel relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1833"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELA</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of Rela relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1837"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELAENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of one Rela reloc</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1841"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELASZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Total size of Rela relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1845"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of one Rel reloc</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1849"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Total size of Rel relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1853"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RPATH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Library search path</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1857"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SONAME</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Name of shared object</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1861"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_STRSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of string table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1865"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_STRTAB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of string table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1869"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMBOLIC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Start symbol search here</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1873"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of one symbol table entry</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1877"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMTAB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of symbol table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1881"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_TEXTREL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Reloc might modify .text</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1885"
>12.3.2.2. Additional Dynamic Entries</A
></H4
><P
>An LSB conforming object may also use the following additional Dynamic Entry
types.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1889"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_ADDRRNGHI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_ADDRRNGLO through DT_ADDRRNGHI are reserved for definition by an archLSB.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1893"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_ADDRRNGLO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_ADDRRNGLO through DT_ADDRRNGHI are reserved for definition by an archLSB.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1897"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_AUXILIARY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shared object to load before self</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1901"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FILTER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shared object to get values from</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1905"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FINI_ARRAY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The address of an array of pointers to termination functions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1909"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FINI_ARRAYSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of DT_FINI_ARRAY</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1913"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_HIOS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_LOOS through DT_HIOS are reserved for definition by specific operating systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1917"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_INIT_ARRAY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The address of an array of pointers to initialization functions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1921"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_INIT_ARRAYSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of DT_INIT_ARRAY</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1925"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_LOOS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_LOOS through DT_HIOS are reserved for definition by specific operating systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1929"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_NUM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of dynamic entry tags defined (excepting reserved ranges).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1933"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_POSFLAG_1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Flags for DT_* entries, effecting the following DT_* entry</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1937"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELCOUNT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>All Elf32_Rel R_*_RELATIVE relocations have been placed into a single block and this entry specifies the number of entries in that block. This permits ld.so.1 to streamline the processing of RELATIVE relocations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1941"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RUNPATH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>null-terminated library search path string</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1945"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMINENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Entry size of syminfo</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1949"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMINFO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of the Syminfo table.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1953"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMINSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of syminfo table (in bytes)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1957"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VALRNGHI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Entries which fall between DT_VALRNGHI &#38; DT_VALRNGLO use the Dyn.d_un.d_val field of the Elf*_Dyn structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1961"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VALRNGLO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Entries which fall between DT_VALRNGHI &#38; DT_VALRNGLO use the Dyn.d_un.d_val field of the Elf*_Dyn structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1965"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERDEF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of version definition table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1969"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERDEFNUM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of version definitions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1973"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERNEED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of table with needed versions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1977"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERNEEDNUM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of needed versions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1981"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERSYM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of the table provided by the .gnu.version section.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCBASELIB"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>III. Base Libraries</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>13. <A
HREF="#BASELIB"
>Base Libraries</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#AEN1989"
>Introduction</A
></DT
><DT
>13.2. <A
HREF="#PROGINTERP"
>Program Interpreter</A
></DT
><DT
>13.3. <A
HREF="#LIBC"
>Interfaces for libc</A
></DT
><DD
><DL
><DT
>13.3.1. <A
HREF="#AEN2044"
>RPC</A
></DT
><DT
>13.3.2. <A
HREF="#AEN2301"
>System Calls</A
></DT
><DT
>13.3.3. <A
HREF="#AEN2881"
>Standard I/O</A
></DT
><DT
>13.3.4. <A
HREF="#AEN3195"
>Signal Handling</A
></DT
><DT
>13.3.5. <A
HREF="#AEN3364"
>Localization Functions</A
></DT
><DT
>13.3.6. <A
HREF="#AEN3485"
>Socket Interface</A
></DT
><DT
>13.3.7. <A
HREF="#AEN3609"
>Wide Characters</A
></DT
><DT
>13.3.8. <A
HREF="#AEN4002"
>String Functions</A
></DT
><DT
>13.3.9. <A
HREF="#AEN4296"
>IPC Functions</A
></DT
><DT
>13.3.10. <A
HREF="#AEN4358"
>Regular Expressions</A
></DT
><DT
>13.3.11. <A
HREF="#AEN4386"
>Character Type Functions</A
></DT
><DT
>13.3.12. <A
HREF="#AEN4544"
>Time Manipulation</A
></DT
><DT
>13.3.13. <A
HREF="#AEN4648"
>Terminal Interface Functions</A
></DT
><DT
>13.3.14. <A
HREF="#AEN4724"
>System Database Interface</A
></DT
><DT
>13.3.15. <A
HREF="#AEN4902"
>Language Support</A
></DT
><DT
>13.3.16. <A
HREF="#AEN4924"
>Large File Support</A
></DT
><DT
>13.3.17. <A
HREF="#AEN5031"
>Standard Library</A
></DT
></DL
></DD
><DT
>13.4. <A
HREF="#LIBC-DDEFS"
>Data Definitions for libc</A
></DT
><DD
><DL
><DT
>13.4.1. <A
HREF="#AEN5733"
>arpa/inet.h</A
></DT
><DT
>13.4.2. <A
HREF="#AEN5737"
>assert.h</A
></DT
><DT
>13.4.3. <A
HREF="#AEN5747"
>ctype.h</A
></DT
><DT
>13.4.4. <A
HREF="#AEN5751"
>dirent.h</A
></DT
><DT
>13.4.5. <A
HREF="#AEN5755"
>err.h</A
></DT
><DT
>13.4.6. <A
HREF="#AEN5759"
>errno.h</A
></DT
><DT
>13.4.7. <A
HREF="#AEN5771"
>fcntl.h</A
></DT
><DT
>13.4.8. <A
HREF="#AEN5775"
>fmtmsg.h</A
></DT
><DT
>13.4.9. <A
HREF="#AEN5779"
>fnmatch.h</A
></DT
><DT
>13.4.10. <A
HREF="#AEN5783"
>ftw.h</A
></DT
><DT
>13.4.11. <A
HREF="#AEN5787"
>getopt.h</A
></DT
><DT
>13.4.12. <A
HREF="#AEN5791"
>glob.h</A
></DT
><DT
>13.4.13. <A
HREF="#AEN5795"
>grp.h</A
></DT
><DT
>13.4.14. <A
HREF="#AEN5799"
>iconv.h</A
></DT
><DT
>13.4.15. <A
HREF="#AEN5803"
>inttypes.h</A
></DT
><DT
>13.4.16. <A
HREF="#AEN5807"
>langinfo.h</A
></DT
><DT
>13.4.17. <A
HREF="#AEN5811"
>libgen.h</A
></DT
><DT
>13.4.18. <A
HREF="#AEN5815"
>libintl.h</A
></DT
><DT
>13.4.19. <A
HREF="#AEN5819"
>limits.h</A
></DT
><DT
>13.4.20. <A
HREF="#AEN5823"
>locale.h</A
></DT
><DT
>13.4.21. <A
HREF="#AEN5827"
>monetary.h</A
></DT
><DT
>13.4.22. <A
HREF="#AEN5831"
>net/if.h</A
></DT
><DT
>13.4.23. <A
HREF="#AEN5835"
>netdb.h</A
></DT
><DT
>13.4.24. <A
HREF="#AEN5839"
>netinet/in.h</A
></DT
><DT
>13.4.25. <A
HREF="#AEN5843"
>netinet/ip.h</A
></DT
><DT
>13.4.26. <A
HREF="#AEN5847"
>netinet/tcp.h</A
></DT
><DT
>13.4.27. <A
HREF="#AEN5851"
>netinet/udp.h</A
></DT
><DT
>13.4.28. <A
HREF="#AEN5855"
>nl_types.h</A
></DT
><DT
>13.4.29. <A
HREF="#AEN5859"
>poll.h</A
></DT
><DT
>13.4.30. <A
HREF="#AEN5863"
>pty.h</A
></DT
><DT
>13.4.31. <A
HREF="#AEN5867"
>pwd.h</A
></DT
><DT
>13.4.32. <A
HREF="#AEN5871"
>regex.h</A
></DT
><DT
>13.4.33. <A
HREF="#AEN5875"
>rpc/auth.h</A
></DT
><DT
>13.4.34. <A
HREF="#AEN5879"
>rpc/clnt.h</A
></DT
><DT
>13.4.35. <A
HREF="#AEN5883"
>rpc/pmap_clnt.h</A
></DT
><DT
>13.4.36. <A
HREF="#AEN5887"
>rpc/rpc_msg.h</A
></DT
><DT
>13.4.37. <A
HREF="#AEN5891"
>rpc/svc.h</A
></DT
><DT
>13.4.38. <A
HREF="#AEN5895"
>rpc/types.h</A
></DT
><DT
>13.4.39. <A
HREF="#AEN5899"
>rpc/xdr.h</A
></DT
><DT
>13.4.40. <A
HREF="#AEN5903"
>sched.h</A
></DT
><DT
>13.4.41. <A
HREF="#AEN5907"
>search.h</A
></DT
><DT
>13.4.42. <A
HREF="#AEN5911"
>setjmp.h</A
></DT
><DT
>13.4.43. <A
HREF="#AEN5915"
>signal.h</A
></DT
><DT
>13.4.44. <A
HREF="#AEN5919"
>stddef.h</A
></DT
><DT
>13.4.45. <A
HREF="#AEN5923"
>stdio.h</A
></DT
><DT
>13.4.46. <A
HREF="#AEN5927"
>stdlib.h</A
></DT
><DT
>13.4.47. <A
HREF="#AEN5931"
>string.h</A
></DT
><DT
>13.4.48. <A
HREF="#AEN5935"
>sys/file.h</A
></DT
><DT
>13.4.49. <A
HREF="#AEN5939"
>sys/ioctl.h</A
></DT
><DT
>13.4.50. <A
HREF="#AEN5943"
>sys/ipc.h</A
></DT
><DT
>13.4.51. <A
HREF="#AEN5947"
>sys/mman.h</A
></DT
><DT
>13.4.52. <A
HREF="#AEN5951"
>sys/msg.h</A
></DT
><DT
>13.4.53. <A
HREF="#AEN5955"
>sys/param.h</A
></DT
><DT
>13.4.54. <A
HREF="#AEN5959"
>sys/poll.h</A
></DT
><DT
>13.4.55. <A
HREF="#AEN5963"
>sys/resource.h</A
></DT
><DT
>13.4.56. <A
HREF="#AEN5967"
>sys/sem.h</A
></DT
><DT
>13.4.57. <A
HREF="#AEN5971"
>sys/shm.h</A
></DT
><DT
>13.4.58. <A
HREF="#AEN5975"
>sys/socket.h</A
></DT
><DT
>13.4.59. <A
HREF="#AEN5979"
>sys/stat.h</A
></DT
><DT
>13.4.60. <A
HREF="#AEN5983"
>sys/statvfs.h</A
></DT
><DT
>13.4.61. <A
HREF="#AEN5987"
>sys/time.h</A
></DT
><DT
>13.4.62. <A
HREF="#AEN5991"
>sys/timeb.h</A
></DT
><DT
>13.4.63. <A
HREF="#AEN5995"
>sys/times.h</A
></DT
><DT
>13.4.64. <A
HREF="#AEN5999"
>sys/types.h</A
></DT
><DT
>13.4.65. <A
HREF="#AEN6003"
>sys/uio.h</A
></DT
><DT
>13.4.66. <A
HREF="#AEN6007"
>sys/un.h</A
></DT
><DT
>13.4.67. <A
HREF="#AEN6011"
>sys/utsname.h</A
></DT
><DT
>13.4.68. <A
HREF="#AEN6015"
>sys/wait.h</A
></DT
><DT
>13.4.69. <A
HREF="#AEN6019"
>syslog.h</A
></DT
><DT
>13.4.70. <A
HREF="#AEN6023"
>termios.h</A
></DT
><DT
>13.4.71. <A
HREF="#AEN6027"
>time.h</A
></DT
><DT
>13.4.72. <A
HREF="#AEN6031"
>ucontext.h</A
></DT
><DT
>13.4.73. <A
HREF="#AEN6035"
>ulimit.h</A
></DT
><DT
>13.4.74. <A
HREF="#AEN6039"
>unistd.h</A
></DT
><DT
>13.4.75. <A
HREF="#AEN6043"
>utime.h</A
></DT
><DT
>13.4.76. <A
HREF="#AEN6047"
>utmp.h</A
></DT
><DT
>13.4.77. <A
HREF="#AEN6051"
>utmpx.h</A
></DT
><DT
>13.4.78. <A
HREF="#AEN6055"
>wchar.h</A
></DT
><DT
>13.4.79. <A
HREF="#AEN6059"
>wctype.h</A
></DT
><DT
>13.4.80. <A
HREF="#AEN6063"
>wordexp.h</A
></DT
></DL
></DD
><DT
>13.5. <A
HREF="#LIBCMAN"
>Interface Definitions for libc</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB--IO-FEOF-3"
>_IO_feof</A
>&nbsp;--&nbsp;alias for feof</DT
><DT
><A
HREF="#BASELIB--IO-GETC-3"
>_IO_getc</A
>&nbsp;--&nbsp;alias for getc</DT
><DT
><A
HREF="#BASELIB--IO-PUTC-3"
>_IO_putc</A
>&nbsp;--&nbsp;alias for putc</DT
><DT
><A
HREF="#BASELIB--IO-PUTS-3"
>_IO_puts</A
>&nbsp;--&nbsp;alias for puts</DT
><DT
><A
HREF="#BASELIB---ASSERT-FAIL-1"
>__assert_fail</A
>&nbsp;--&nbsp;abort the program after false assertion</DT
><DT
><A
HREF="#BASELIB---CTYPE-B-LOC"
>__ctype_b_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b array for ctype functions</DT
><DT
><A
HREF="#BASELIB---CTYPE-GET-MB-CUR-MAX-1"
>__ctype_get_mb_cur_max</A
>&nbsp;--&nbsp;maximum length of a multibyte character in the current locale</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOLOWER-LOC"
>__ctype_tolower_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b_tolower array for ctype tolower() function</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOUPPER-LOC"
>__ctype_toupper_loc</A
>&nbsp;--&nbsp;accessor function for <TT
CLASS="FUNCTION"
>__ctype_b_toupper()</TT
>
array for ctype <TT
CLASS="FUNCTION"
>toupper()</TT
> function</DT
><DT
><A
HREF="#BASELIB---CXA-ATEXIT"
>__cxa_atexit</A
>&nbsp;--&nbsp;register a function to be called by exit or when a shared library is unloaded</DT
><DT
><A
HREF="#BASELIB-DAYLIGHT-1"
>__daylight</A
>&nbsp;--&nbsp;daylight savings time flag</DT
><DT
><A
HREF="#BASELIB---ENVIRON"
>__environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB-ERRNO-LOCATION-1"
>__errno_location</A
>&nbsp;--&nbsp;address of errno variable</DT
><DT
><A
HREF="#BASELIB---FPENDING"
>__fpending</A
>&nbsp;--&nbsp;returns in bytes the amount of output pending on a stream</DT
><DT
><A
HREF="#BASELIB---GETPAGESIZE"
>__getpagesize</A
>&nbsp;--&nbsp;alias for getpagesize - get current page size </DT
><DT
><A
HREF="#BASELIB---GETPGID-1"
>__getpgid</A
>&nbsp;--&nbsp;get the process group id</DT
><DT
><A
HREF="#BASELIB-H-ERRNO-LOCATION-1"
>__h_errno_location</A
>&nbsp;--&nbsp;address of h_errno variable</DT
><DT
><A
HREF="#BASELIB---ISINF"
>__isinf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFF"
>__isinff</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFL"
>__isinfl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNAN"
>__isnan</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANF"
>__isnanf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANL"
>__isnanl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMAX-1"
>__libc_current_sigrtmax</A
>&nbsp;--&nbsp;return number of available real-time signal with lowest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMIN-1"
>__libc_current_sigrtmin</A
>&nbsp;--&nbsp;return number of available real-time signal with highest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-START-MAIN-"
>__libc_start_main</A
>&nbsp;--&nbsp;initialization routine</DT
><DT
><A
HREF="#LIBUTIL---LXSTAT-2"
>__lxstat</A
>&nbsp;--&nbsp;inline wrapper around call to lxstat</DT
><DT
><A
HREF="#BASELIB---MEMPCPY"
>__mempcpy</A
>&nbsp;--&nbsp;copy given number of bytes of source to destination</DT
><DT
><A
HREF="#BASELIB---RAWMEMCHR"
>__rawmemchr</A
>&nbsp;--&nbsp;scan memory</DT
><DT
><A
HREF="#BASELIB--REGISTER-ATFORK"
>__register_atfork</A
>&nbsp;--&nbsp;alias for register_atfork</DT
><DT
><A
HREF="#BASELIB---SIGSETJMP-1"
>__sigsetjmp</A
>&nbsp;--&nbsp;save stack context for non-local goto</DT
><DT
><A
HREF="#LIBUTIL---STPCPY-2"
>__stpcpy</A
>&nbsp;--&nbsp;alias for stpcpy</DT
><DT
><A
HREF="#BASELIB---STRDUP-1"
>__strdup</A
>&nbsp;--&nbsp;alias for strdup</DT
><DT
><A
HREF="#BASELIB---STRTOD-INTERNAL-1"
>__strtod_internal</A
>&nbsp;--&nbsp;underlying function for strtod</DT
><DT
><A
HREF="#BASELIB-STRTOF-INTERNAL-1"
>__strtof_internal</A
>&nbsp;--&nbsp;underlying function for strtof</DT
><DT
><A
HREF="#BASELIB---STRTOK-R-1"
>__strtok_r</A
>&nbsp;--&nbsp;alias for strtok_r</DT
><DT
><A
HREF="#BASELIB---STRTOL-INTERNAL-1"
>__strtol_internal</A
>&nbsp;--&nbsp;alias for strtol</DT
><DT
><A
HREF="#BASELIB---STRTOLD-INTERNAL-1"
>__strtold_internal</A
>&nbsp;--&nbsp;underlying function for strtold</DT
><DT
><A
HREF="#BASELIB---STRTOLL-INTERNAL-1"
>__strtoll_internal</A
>&nbsp;--&nbsp;underlying function for strtoll</DT
><DT
><A
HREF="#BASELIB-STRTOUL-INTERNAL-1"
>__strtoul_internal</A
>&nbsp;--&nbsp;underlying function for strtoul</DT
><DT
><A
HREF="#BASELIB---STRTOULL-INTERNAL-1"
>__strtoull_internal</A
>&nbsp;--&nbsp;underlying function for strtoull</DT
><DT
><A
HREF="#BASELIB---SYSCONF"
>__sysconf</A
>&nbsp;--&nbsp;get configuration information at runtime</DT
><DT
><A
HREF="#BASELIB---SYSV-SIGNAL-1"
>__sysv_signal</A
>&nbsp;--&nbsp;signal handling</DT
><DT
><A
HREF="#BASELIB-TIMEZONE-1"
>__timezone</A
>&nbsp;--&nbsp;global variable containing timezone</DT
><DT
><A
HREF="#BASELIB-TZNAME-1"
>__tzname</A
>&nbsp;--&nbsp;global variable containing the timezone</DT
><DT
><A
HREF="#BASELIB---WCSTOD-INTERNAL-1"
>__wcstod_internal</A
>&nbsp;--&nbsp;underlying function for wcstod</DT
><DT
><A
HREF="#BASELIB---WCSTOF-INTERNAL-1"
>__wcstof_internal</A
>&nbsp;--&nbsp;underlying function for wcstof</DT
><DT
><A
HREF="#BASELIB---WCSTOL-INTERNAL-1"
>__wcstol_internal</A
>&nbsp;--&nbsp;underlying function for wcstol</DT
><DT
><A
HREF="#BASELIB---WCSTOLD-INTERNAL-1"
>__wcstold_internal</A
>&nbsp;--&nbsp;underlying function for wcstold</DT
><DT
><A
HREF="#BASELIB---WCSTOUL-INTERNAL-1"
>__wcstoul_internal</A
>&nbsp;--&nbsp;underlying function for wcstoul</DT
><DT
><A
HREF="#BASELIB---XMKNOD-1"
>__xmknod</A
>&nbsp;--&nbsp;make block or character special file</DT
><DT
><A
HREF="#BASELIB-XSTAT-1"
>__xstat</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB-XSTAT64-1"
>__xstat64</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB--ENVIRON"
>_environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB--NL-MSG-CAT-CNTR"
>_nl_msg_cat_cntr</A
>&nbsp;--&nbsp;new catalog load counter</DT
><DT
><A
HREF="#BASELIB--SYS-ERRLIST"
>_sys_errlist</A
>&nbsp;--&nbsp;array containing the "C" locale strings used by strerror()</DT
><DT
><A
HREF="#BASELIB--SYS-SIGLIST"
>_sys_siglist</A
>&nbsp;--&nbsp;array containing the names of the signal names</DT
><DT
><A
HREF="#BASELIB-ACCT-3"
>acct</A
>&nbsp;--&nbsp;switch process accounting on or off</DT
><DT
><A
HREF="#BASELIB-ADJTIME-2"
>adjtime</A
>&nbsp;--&nbsp;correct the time to allow synchronization of the system clock</DT
><DT
><A
HREF="#BASELIB-ASPRINTF"
>asprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-BIND-TEXTDOMAIN-CODESET"
>bind_textdomain_codeset</A
>&nbsp;--&nbsp;specify encoding for message retrieval</DT
><DT
><A
HREF="#BASELIB-BINDRESVPORT-3"
>bindresvport</A
>&nbsp;--&nbsp;bind socket to privileged IP port</DT
><DT
><A
HREF="#BASELIB-BINDTEXTDOMAIN"
>bindtextdomain</A
>&nbsp;--&nbsp;specify the location of a message catalog</DT
><DT
><A
HREF="#BASELIB-CFMAKERAW-3"
>cfmakeraw</A
>&nbsp;--&nbsp;get and set terminal attributes</DT
><DT
><A
HREF="#BASELIB-CFSETSPEED-3"
>cfsetspeed</A
>&nbsp;--&nbsp;set terminal input and output data rate</DT
><DT
><A
HREF="#BASELIB-DAEMON-3"
>daemon</A
>&nbsp;--&nbsp;run in the background</DT
><DT
><A
HREF="#BASELIB-DCGETTEXT"
>dcgettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog</DT
><DT
><A
HREF="#BASELIB-DCNGETTEXT"
>dcngettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog
with plural</DT
><DT
><A
HREF="#BASELIB-DGETTEXT"
>dgettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current LC_MESSAGES locale</DT
><DT
><A
HREF="#BASELIB-DNGETTEXT"
>dngettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current locale</DT
><DT
><A
HREF="#BASELIB-DUPLOCALE-3"
>duplocale</A
>&nbsp;--&nbsp;provide new handle for selection of locale</DT
><DT
><A
HREF="#BASELIB-ERR-3"
>err</A
>&nbsp;--&nbsp;display formatted error messages</DT
><DT
><A
HREF="#BASELIB-ERROR-N"
>error</A
>&nbsp;--&nbsp;print error message</DT
><DT
><A
HREF="#BASELIB-ERRX-3"
>errx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-FCNTL-3"
>fcntl</A
>&nbsp;--&nbsp;file control</DT
><DT
><A
HREF="#BASELIB-FFLUSH-UNLOCKED-1"
>fflush_unlocked</A
>&nbsp;--&nbsp;non thread safe fflush</DT
><DT
><A
HREF="#BASELIB-FGETWC-UNLOCKED-1"
>fgetwc_unlocked</A
>&nbsp;--&nbsp;non thread safe fgetwc</DT
><DT
><A
HREF="#BASELIB-FLOCK-2"
>flock</A
>&nbsp;--&nbsp;apply or remove an advisory lock on an open file</DT
><DT
><A
HREF="#BASELIB-FREELOCALE-3"
>freelocale</A
>&nbsp;--&nbsp;free a locale object</DT
><DT
><A
HREF="#BASELIB-FSCANF"
>fscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-FWSCANF"
>fwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-GETGROUPLIST-3"
>getgrouplist</A
>&nbsp;--&nbsp;get network group entry</DT
><DT
><A
HREF="#BASELIB-GETLOADAVG-3"
>getloadavg</A
>&nbsp;--&nbsp;get system load averages</DT
><DT
><A
HREF="#LIBUTIL-GETOPT-3"
>getopt</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-3"
>getopt_long</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-ONLY-3"
>getopt_long_only</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETSOCKOPT-1"
>getsockopt</A
>&nbsp;--&nbsp;get socket options</DT
><DT
><A
HREF="#BASELIB-GETTEXT"
>gettext</A
>&nbsp;--&nbsp;search message catalogs for a string</DT
><DT
><A
HREF="#BASELIB-GETUTENT-3"
>getutent</A
>&nbsp;--&nbsp;access user accounting database entries	</DT
><DT
><A
HREF="#BASELIB-GETUTENT-R-3"
>getutent_r</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-GLOB64"
>glob64</A
>&nbsp;--&nbsp;find pathnames matching a pattern  (Large File Support)</DT
><DT
><A
HREF="#BASELIB-GLOBFREE64"
>globfree64</A
>&nbsp;--&nbsp;free memory from glob64() (Large File Support)</DT
><DT
><A
HREF="#BASELIB-INITGROUPS-3"
>initgroups</A
>&nbsp;--&nbsp;initialize the supplementary group access list</DT
><DT
><A
HREF="#BASELIB-IOCTL-2"
>ioctl</A
>&nbsp;--&nbsp;control device</DT
><DT
><A
HREF="#BASELIB-SOCKIO-2"
>sockio</A
>&nbsp;--&nbsp;socket ioctl commands</DT
><DT
><A
HREF="#BASELIB-TTYIO-2"
>ttyio</A
>&nbsp;--&nbsp;tty ioctl commands</DT
><DT
><A
HREF="#BASELIB-KILL-3"
>kill</A
>&nbsp;--&nbsp;send a signal</DT
><DT
><A
HREF="#BASELIB-LINK-1"
>link</A
>&nbsp;--&nbsp;create a link to a file</DT
><DT
><A
HREF="#BASELIB-MBSNRTOWCS-3"
>mbsnrtowcs</A
>&nbsp;--&nbsp;convert a multibyte string to a wide character string</DT
><DT
><A
HREF="#BASELIB-MEMMEM-3"
>memmem</A
>&nbsp;--&nbsp;locate bytes</DT
><DT
><A
HREF="#BASELIB-MEMRCHR"
>memrchr</A
>&nbsp;--&nbsp;scan memory for a character</DT
><DT
><A
HREF="#BASELIB-NEWLOCALE-3"
>newlocale</A
>&nbsp;--&nbsp;allocate a locale object</DT
><DT
><A
HREF="#BASELIB-NGETTEXT"
>ngettext</A
>&nbsp;--&nbsp;search message catalogs for plural string</DT
><DT
><A
HREF="#BASELIB-PMAP-GETPORT-3"
>pmap_getport</A
>&nbsp;--&nbsp;find the port number assigned to a service registered with a
portmapper.</DT
><DT
><A
HREF="#BASELIB-PMAP-SET-3"
>pmap_set</A
>&nbsp;--&nbsp;establishes mapping to machine's RPC Bind service.</DT
><DT
><A
HREF="#BASELIB-PMAP-UNSET-3"
>pmap_unset</A
>&nbsp;--&nbsp;
destroys RPC Binding&#13;</DT
><DT
><A
HREF="#BASELIB-PSIGNAL-3"
>psignal</A
>&nbsp;--&nbsp;print signal message</DT
><DT
><A
HREF="#BASELIB-REGEXEC-2"
>regexec</A
>&nbsp;--&nbsp;regular expression matching</DT
><DT
><A
HREF="#BASELIB-SCANF"
>scanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SETBUFFER-3"
>setbuffer</A
>&nbsp;--&nbsp;stream buffering operation</DT
><DT
><A
HREF="#BASELIB-SETGROUPS-2"
>setgroups</A
>&nbsp;--&nbsp;set list of supplementary group IDs</DT
><DT
><A
HREF="#BASELIB-SETHOSTNAME-2"
>sethostname</A
>&nbsp;--&nbsp;set host name</DT
><DT
><A
HREF="#BASELIB-SETSOCKOPT-2"
>setsockopt</A
>&nbsp;--&nbsp;set socket options</DT
><DT
><A
HREF="#BASELIB-SETUTENT-3"
>setutent</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-SIGANDSET"
>sigandset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical AND</DT
><DT
><A
HREF="#BASELIB-SIGISEMPTYSET"
>sigisemptyset</A
>&nbsp;--&nbsp;check for empty signal set</DT
><DT
><A
HREF="#BASELIB-SIGORSET"
>sigorset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical OR</DT
><DT
><A
HREF="#BASELIB-SIGRETURN-2"
>sigreturn</A
>&nbsp;--&nbsp;return from signal handler and cleanup stack frame</DT
><DT
><A
HREF="#BASELIB-SSCANF"
>sscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-STIME-2"
>stime</A
>&nbsp;--&nbsp;set time</DT
><DT
><A
HREF="#BASELIB-STPCPY-3"
>stpcpy</A
>&nbsp;--&nbsp;copy a string returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-STPNCPY-3"
>stpncpy</A
>&nbsp;--&nbsp;copy a fixed-size string, returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-STRCASESTR"
>strcasestr</A
>&nbsp;--&nbsp;locate a substring ignoring case</DT
><DT
><A
HREF="#BASELIB-STRERROR-R"
>strerror_r</A
>&nbsp;--&nbsp;reentrant version of strerror</DT
><DT
><A
HREF="#BASELIB-STRNDUP"
>strndup</A
>&nbsp;--&nbsp;return a malloc'd copy of at most the specified number of bytes of a string </DT
><DT
><A
HREF="#BASELIB-STRNLEN-3"
>strnlen</A
>&nbsp;--&nbsp;determine the length of a fixed-size string</DT
><DT
><A
HREF="#BASELIB-STRPTIME-3"
>strptime</A
>&nbsp;--&nbsp;parse a time string</DT
><DT
><A
HREF="#BASELIB-STRSEP-3"
>strsep</A
>&nbsp;--&nbsp;extract token from string</DT
><DT
><A
HREF="#BASELIB-STRSIGNAL-3"
>strsignal</A
>&nbsp;--&nbsp;return string describing signal</DT
><DT
><A
HREF="#BASELIB-STRTOQ-3"
>strtoq</A
>&nbsp;--&nbsp;convert string value to a long or quad_t integer</DT
><DT
><A
HREF="#BASELIB-STRTOUQ-3"
>strtouq</A
>&nbsp;--&nbsp;convert a string to an unsigned long long</DT
><DT
><A
HREF="#BASELIB-SVC-REGISTER-3"
>svc_register</A
>&nbsp;--&nbsp;register Remote Procedure Call interface</DT
><DT
><A
HREF="#BASELIB-SVC-RUN-3"
>svc_run</A
>&nbsp;--&nbsp;waits for RPC requests to arrive and calls service procedure</DT
><DT
><A
HREF="#BASELIB-SVC-SENDREPLY-3"
>svc_sendreply</A
>&nbsp;--&nbsp;called by RPC service's dispatch routine</DT
><DT
><A
HREF="#BASELIB-SVCTCP-CREATE-3"
>svctcp_create</A
>&nbsp;--&nbsp;create a TCP/IP-based RPC service transport</DT
><DT
><A
HREF="#BASELIB-SVCUDP-CREATE-3"
>svcudp_create</A
>&nbsp;--&nbsp;		create a UDP-based RPC service transport
		</DT
><DT
><A
HREF="#BASELIB-SWSCANF"
>swscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SYSTEM-3"
>system</A
>&nbsp;--&nbsp;execute a shell command</DT
><DT
><A
HREF="#BASELIB-TEXTDOMAIN"
>textdomain</A
>&nbsp;--&nbsp;set the current default message domain</DT
><DT
><A
HREF="#BASELIB-UNLINK-3"
>unlink</A
>&nbsp;--&nbsp;remove a directory entry</DT
><DT
><A
HREF="#BASELIB-USELOCALE-3"
>uselocale</A
>&nbsp;--&nbsp;set locale for thread</DT
><DT
><A
HREF="#BASELIB-UTMPNAME-3"
>utmpname</A
>&nbsp;--&nbsp;set user accounting database</DT
><DT
><A
HREF="#BASELIB-VASPRINTF"
>vasprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-VDPRINTF"
>vdprintf</A
>&nbsp;--&nbsp;write formatted output to a file descriptor</DT
><DT
><A
HREF="#BASELIB-VERRX-3"
>verrx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-VFSCANF"
>vfscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VFWSCANF"
>vfwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSCANF"
>vscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSSCANF"
>vsscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSWSCANF"
>vswscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSYSLOG-3"
>vsyslog</A
>&nbsp;--&nbsp;log to system log</DT
><DT
><A
HREF="#BASELIB-VWSCANF"
>vwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-WAIT4-2"
>wait4</A
>&nbsp;--&nbsp;wait for process termination, BSD style</DT
><DT
><A
HREF="#BASELIB-WAITPID-3"
>waitpid</A
>&nbsp;--&nbsp;wait for child process</DT
><DT
><A
HREF="#BASELIB-WARN-3"
>warn</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WARNX-3"
>warnx</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WCPCPY-3"
>wcpcpy</A
>&nbsp;--&nbsp;copy a wide character string, returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-WCPNCPY-3"
>wcpncpy</A
>&nbsp;--&nbsp;copy a fixed-size string of wide characters, returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-WCSCASECMP-3"
>wcscasecmp</A
>&nbsp;--&nbsp;compare two wide-character strings, ignoring case</DT
><DT
><A
HREF="#BASELIB-WCSDUP-3"
>wcsdup</A
>&nbsp;--&nbsp;duplicate a wide-character string</DT
><DT
><A
HREF="#BASELIB-WCSNCASECMP-3"
>wcsncasecmp</A
>&nbsp;--&nbsp;compare two fixed-size wide-character strings, ignoring case</DT
><DT
><A
HREF="#BASELIB-WCSNLEN-3"
>wcsnlen</A
>&nbsp;--&nbsp;determine the length of a fixed-size wide-character string</DT
><DT
><A
HREF="#BASELIB-WCSNRTOMBS-3"
>wcsnrtombs</A
>&nbsp;--&nbsp;convert a wide character string to a multi-byte string</DT
><DT
><A
HREF="#BASELIB-WCSTOQ"
>wcstoq</A
>&nbsp;--&nbsp;convert wide string to long long int representation</DT
><DT
><A
HREF="#BASELIB-WCSTOUQ"
>wcstouq</A
>&nbsp;--&nbsp;convert wide string to unsigned long long int representation</DT
><DT
><A
HREF="#BASELIB-WSCANF"
>wscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-XDR-U-INT-3"
>xdr_u_int</A
>&nbsp;--&nbsp;library routines for external data representation</DT
></DL
></DD
><DT
>13.6. <A
HREF="#LIBM"
>Interfaces for libm</A
></DT
><DD
><DL
><DT
>13.6.1. <A
HREF="#AEN13422"
>Math</A
></DT
></DL
></DD
><DT
>13.7. <A
HREF="#LIBM-DDEFS"
>Data Definitions for libm</A
></DT
><DD
><DL
><DT
>13.7.1. <A
HREF="#AEN14725"
>complex.h</A
></DT
><DT
>13.7.2. <A
HREF="#AEN14729"
>fenv.h</A
></DT
><DT
>13.7.3. <A
HREF="#AEN14733"
>math.h</A
></DT
></DL
></DD
><DT
>13.8. <A
HREF="#LIBMMAN"
>Interface Definitions for libm</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB---FPCLASSIFY"
>__fpclassify</A
>&nbsp;--&nbsp;Classify real floating type</DT
><DT
><A
HREF="#BASELIB---FPCLASSIFYF"
>__fpclassifyf</A
>&nbsp;--&nbsp;Classify real floating type</DT
></DL
></DD
><DT
>13.9. <A
HREF="#LIBPTHREAD"
>Interfaces for libpthread</A
></DT
><DD
><DL
><DT
>13.9.1. <A
HREF="#AEN14812"
>Realtime Threads</A
></DT
><DT
>13.9.2. <A
HREF="#AEN14865"
>Advanced Realtime Threads</A
></DT
><DT
>13.9.3. <A
HREF="#AEN14871"
>Posix Threads</A
></DT
><DT
>13.9.4. <A
HREF="#AEN15219"
>Thread aware versions of libc interfaces</A
></DT
></DL
></DD
><DT
>13.10. <A
HREF="#LIBPTHREAD-DDEFS"
>Data Definitions for libpthread</A
></DT
><DD
><DL
><DT
>13.10.1. <A
HREF="#AEN15264"
>pthread.h</A
></DT
><DT
>13.10.2. <A
HREF="#AEN15268"
>semaphore.h</A
></DT
></DL
></DD
><DT
>13.11. <A
HREF="#LIBPTHREADMAN"
>Interface Definitions for libpthread</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-POP"
>_pthread_cleanup_pop</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-PUSH"
>_pthread_cleanup_push</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
></DL
></DD
><DT
>13.12. <A
HREF="#LIBGCC-S"
>Interfaces for libgcc_s</A
></DT
><DD
><DL
><DT
>13.12.1. <A
HREF="#AEN15341"
>Unwind Library</A
></DT
></DL
></DD
><DT
>13.13. <A
HREF="#LIBGCC-S-DDEFS"
>Data Definitions for libgcc_s</A
></DT
><DD
><DL
><DT
>13.13.1. <A
HREF="#AEN15353"
>unwind.h</A
></DT
></DL
></DD
><DT
>13.14. <A
HREF="#LIBDL"
>Interfaces for libdl</A
></DT
><DD
><DL
><DT
>13.14.1. <A
HREF="#AEN15377"
>Dynamic Loader</A
></DT
></DL
></DD
><DT
>13.15. <A
HREF="#LIBDL-DDEFS"
>Data Definitions for libdl</A
></DT
><DD
><DL
><DT
>13.15.1. <A
HREF="#AEN15419"
>dlfcn.h</A
></DT
></DL
></DD
><DT
>13.16. <A
HREF="#LIBDLMAN"
>Interface Definitions for libdl</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB-DLADDR-3"
>dladdr</A
>&nbsp;--&nbsp;find the shared object containing a given address</DT
><DT
><A
HREF="#BASELIB-DLOPEN-1"
>dlopen</A
>&nbsp;--&nbsp;open dynamic object</DT
><DT
><A
HREF="#BASELIB-DLSYM-1"
>dlsym</A
>&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DT
></DL
></DD
><DT
>13.17. <A
HREF="#LIBRT"
>Interfaces for librt</A
></DT
><DD
><DL
><DT
>13.17.1. <A
HREF="#AEN15598"
>Shared Memory Objects</A
></DT
><DT
>13.17.2. <A
HREF="#AEN15620"
>Clock</A
></DT
><DT
>13.17.3. <A
HREF="#AEN15656"
>Timers</A
></DT
></DL
></DD
><DT
>13.18. <A
HREF="#LIBCRYPT"
>Interfaces for libcrypt</A
></DT
><DD
><DL
><DT
>13.18.1. <A
HREF="#AEN15710"
>Encryption</A
></DT
></DL
></DD
><DT
>13.19. <A
HREF="#LIBPAM"
>Interfaces for libpam</A
></DT
><DD
><DL
><DT
>13.19.1. <A
HREF="#AEN15759"
>Pluggable Authentication API</A
></DT
></DL
></DD
><DT
>13.20. <A
HREF="#LIBPAM-DDEFS"
>Data Definitions for libpam</A
></DT
><DD
><DL
><DT
>13.20.1. <A
HREF="#AEN15835"
>security/pam_appl.h</A
></DT
></DL
></DD
><DT
>13.21. <A
HREF="#LIBPAMMAN"
>Interface Definitions for libpam</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB-PAM-ACCT-MGMT"
>pam_acct_mgmt</A
>&nbsp;--&nbsp;establish the status of a user's account</DT
><DT
><A
HREF="#BASELIB-PAM-AUTHENTICATE"
>pam_authenticate</A
>&nbsp;--&nbsp;authenticate the user</DT
><DT
><A
HREF="#BASELIB-PAM-CHAUTHTOK"
>pam_chauthtok</A
>&nbsp;--&nbsp;change the authentication token for a given user</DT
><DT
><A
HREF="#BASELIB-PAM-CLOSE-SESSION"
>pam_close_session</A
>&nbsp;--&nbsp;indicate that an authenticated session has ended</DT
><DT
><A
HREF="#BASELIB-PAM-END"
>pam_end</A
>&nbsp;--&nbsp;terminate the use of the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-FAIL-DELAY"
>pam_fail_delay</A
>&nbsp;--&nbsp;specify delay time to use on authentication error</DT
><DT
><A
HREF="#BASELIB-PAM-GET-ITEM"
>pam_get_item</A
>&nbsp;--&nbsp;obtain the value of the indicated item.</DT
><DT
><A
HREF="#BASELIB-PAM-GETENVLIST"
>pam_getenvlist</A
>&nbsp;--&nbsp;returns a pointer to the complete PAM environment.</DT
><DT
><A
HREF="#BASELIB-PAM-OPEN-SESSION"
>pam_open_session</A
>&nbsp;--&nbsp;indicate session has started</DT
><DT
><A
HREF="#BASELIB-PAM-SET-ITEM"
>pam_set_item</A
>&nbsp;--&nbsp;(re)set the value of an item.</DT
><DT
><A
HREF="#BASELIB-PAM-SETCRED"
>pam_setcred</A
>&nbsp;--&nbsp;set the module-specific credentials of the user</DT
><DT
><A
HREF="#BASELIB-PAM-START"
>pam_start</A
>&nbsp;--&nbsp;initialize the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-STRERROR"
>pam_strerror</A
>&nbsp;--&nbsp;returns a string describing the PAM error</DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BASELIB"
></A
>Chapter 13. Base Libraries</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1989"
>13.1. Introduction</A
></H2
><P
>An LSB-conforming implementation shall support the following
base libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.
<P
></P
><UL
><LI
><P
>libc</P
></LI
><LI
><P
>libm</P
></LI
><LI
><P
>libgcc_s</P
></LI
><LI
><P
>libdl</P
></LI
><LI
><P
>librt</P
></LI
><LI
><P
>libcrypt</P
></LI
><LI
><P
>libpam</P
></LI
></UL
></P
><P
>There are three main parts to the definition of each of these
libraries.</P
><P
>The "Interfaces" section defines the required library name and version,
and the required public symbols (interfaces and global data), as well
as symbol versions, if any.</P
><P
>The "Interface Definitions" section provides complete or partial
definitions of certain interfaces where either this specification is
the source specification, or where there are variations from the source
specification. If an interface definition requires one or more header 
files, one of those headers shall include the function 
prototype for the interface.</P
><P
>For source definitions of interfaces which include a reference to a
header file, the contents of such header files form a
part of the specification.  The "Data Definitions" section provides the
binary-level details for the header files from the source specifications,
such as values for macros and enumerated types, as well as structure layouts,
sizes and padding, etc.  These data definitions, although presented in the form
of header files for convenience, should not be taken a representing complete
header files, as they are a supplement to the source
specifications.  Application developers should follow the guidelines
of the source specifications when determining which header files need
to be included to completely resolve all references.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>While the Data Definitions supplement the source specifications,
this specification itself does not require conforming implementations
to supply any header files.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROGINTERP"
>13.2. Program Interpreter</A
></H2
><P
>The Program Interpreter is specified in the appropriate
architecture specific supplement.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBC"
>13.3. Interfaces for libc</A
></H2
><P
><A
HREF="#LIB-LIBC-DEF"
>Table 13-1</A
> defines the library name and shared object name
for the libc library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBC-DEF"
></A
><P
><B
>Table 13-1. libc Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libc</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>See archLSB.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBC.1"
></A
>[LFS] <A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.2"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.3"
></A
>[SUSv2] <A
HREF="#STD.SUSV2"
>SUSv2</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.4"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.5"
></A
>[SVID.3] <A
HREF="#STD.SVID.3"
>SVID Issue 3</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.6"
></A
>[SVID.4] <A
HREF="#STD.SVID.4"
>SVID Issue 4</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2044"
>13.3.1. RPC</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2047"
>13.3.1.1. Interfaces for RPC</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for RPC specified in <A
HREF="#TBL-LIBC-RPC-INTS"
>Table 13-2</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-RPC-INTS"
></A
><P
><B
>Table 13-2. libc - RPC Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>authnone_create <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
><TD
>clnt_create <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
><TD
>clnt_pcreateerror <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
><TD
>clnt_perrno <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>clnt_perror <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
><TD
>clnt_spcreateerror <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
><TD
>clnt_sperrno <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
><TD
>clnt_sperror <A
HREF="#REFSTD.LIBC.6"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>key_decryptsession <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>pmap_getport <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pmap_set <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pmap_unset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>svc_getreqset <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svc_register <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>svc_run <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>svc_sendreply <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>svcerr_auth <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svcerr_decode <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svcerr_noproc <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svcerr_noprog <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>svcerr_progvers <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svcerr_systemerr <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svcerr_weakauth <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>svctcp_create <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>svcudp_create <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>xdr_accepted_reply <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_array <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_bool <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdr_bytes <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_callhdr <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_callmsg <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_char <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdr_double <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_enum <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_float <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_free <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdr_int <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_long <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_opaque <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_opaque_auth <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdr_pointer <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_reference <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_rejected_reply <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_replymsg <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdr_short <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_string <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_u_char <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_u_int <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>xdr_u_long <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_u_short <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_union <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_vector <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdr_void <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdr_wrapstring <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdrmem_create <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>xdrrec_create <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
></TR
><TR
><TD
>xdrrec_eof <A
HREF="#REFSTD.LIBC.5"
>[SVID.3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2301"
>13.3.2. System Calls</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2304"
>13.3.2.1. Interfaces for System Calls</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for System Calls specified in <A
HREF="#TBL-LIBC-SYS-INTS"
>Table 13-3</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SYS-INTS"
></A
><P
><B
>Table 13-3. libc - System Calls Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__fxstat <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__getpgid <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__lxstat <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xmknod <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__xstat <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>access <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>acct <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>alarm <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>brk <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>chdir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>chmod <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>chown <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>chroot <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>clock <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>close <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>closedir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>creat <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>dup <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>dup2 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>execl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>execle <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>execlp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>execv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>execve <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>execvp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>exit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fchdir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fchmod <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fchown <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fcntl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fdatasync <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>flock <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>fork <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fstatvfs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fsync <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ftime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ftruncate <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getcontext <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getegid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>geteuid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getgid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getgroups <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getitimer <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getloadavg <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>getpagesize <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>getpgid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpgrp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getppid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpriority <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getrlimit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getrusage <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getsid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getuid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getwd <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>initgroups <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>ioctl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>kill <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>killpg <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>lchown <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>link <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>lockf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>lseek <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mkdir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>mkfifo <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mlock <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mlockall <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mmap <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>mprotect <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>msync <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>munlock <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>munlockall <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>munmap <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>nanosleep <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>nice <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>open <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>opendir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>pathconf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>pause <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>pipe <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>poll <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>read <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>readdir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>readdir_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>readlink <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>readv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>rename <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>rmdir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sbrk <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>sched_get_priority_max <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sched_get_priority_min <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sched_getparam <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sched_getscheduler <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sched_rr_get_interval <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sched_setparam <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sched_setscheduler <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sched_yield <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>select <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setcontext <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setegid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>seteuid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setgid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setitimer <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setpgid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setpgrp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setpriority <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setregid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setreuid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setrlimit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setrlimit64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>setsid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setuid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sleep <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>statvfs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>stime <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>symlink <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sync <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sysconf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>time <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>times <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>truncate <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ulimit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>umask <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>uname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>unlink <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>utime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>utimes <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>vfork <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wait <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wait4 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>waitpid <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>write <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>writev <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2881"
>13.3.3. Standard I/O</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2884"
>13.3.3.1. Interfaces for Standard I/O</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Standard I/O specified in <A
HREF="#TBL-LIBC-STA-INTS"
>Table 13-4</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STA-INTS"
></A
><P
><B
>Table 13-4. libc - Standard I/O Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_IO_feof <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_IO_getc <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_IO_putc <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_IO_puts <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>asprintf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>clearerr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ctermid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fclose <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fdopen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>feof <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ferror <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fflush <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fflush_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fgetc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fgetpos <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fgets <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fgetwc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fileno <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>flockfile <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fopen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fputc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fputs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fread <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>freopen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fseek <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fseeko <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fsetpos <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ftell <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ftello <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fwrite <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getc_unlocked <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getchar <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getchar_unlocked <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getw <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>pclose <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>popen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>printf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>putc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>putc_unlocked <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>putchar <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>putchar_unlocked <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>puts <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>putw <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>remove <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>rewind <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>rewinddir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>scanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>seekdir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setbuf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setbuffer <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setvbuf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>snprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>telldir <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tempnam <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ungetc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>vasprintf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vdprintf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vfprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>vprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>vsnprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>vsprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Standard I/O specified in <A
HREF="#TBL-LIBC-STA-DATA"
>Table 13-5</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STA-DATA"
></A
><P
><B
>Table 13-5. libc - Standard I/O Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>stderr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>stdin <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>stdout <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3195"
>13.3.4. Signal Handling</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3198"
>13.3.4.1. Interfaces for Signal Handling</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Signal Handling specified in <A
HREF="#TBL-LIBC-SIG-INTS"
>Table 13-6</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SIG-INTS"
></A
><P
><B
>Table 13-6. libc - Signal Handling Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__libc_current_sigrtmax <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__libc_current_sigrtmin <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__sigsetjmp <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__sysv_signal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>bsd_signal <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>psignal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>raise <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigaction <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sigaddset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigaltstack <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigandset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sigdelset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sigemptyset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigfillset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sighold <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigignore <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>siginterrupt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigisemptyset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sigismember <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>siglongjmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>signal <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigorset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sigpause <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigpending <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sigprocmask <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigqueue <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigrelse <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigreturn <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>sigset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigsuspend <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigtimedwait <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sigwait <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sigwaitinfo <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Signal Handling specified in <A
HREF="#TBL-LIBC-SIG-DATA"
>Table 13-7</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SIG-DATA"
></A
><P
><B
>Table 13-7. libc - Signal Handling Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_sys_siglist <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3364"
>13.3.5. Localization Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3367"
>13.3.5.1. Interfaces for Localization Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Localization Functions specified in <A
HREF="#TBL-LIBC-LOC-INTS"
>Table 13-8</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LOC-INTS"
></A
><P
><B
>Table 13-8. libc - Localization Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>bind_textdomain_codeset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>bindtextdomain <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>catclose <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>catgets <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>catopen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>dcgettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>dcngettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>dgettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>dngettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>duplocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>freelocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>iconv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iconv_close <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iconv_open <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>localeconv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>newlocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>ngettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>nl_langinfo <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setlocale <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>textdomain <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>uselocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Localization Functions specified in <A
HREF="#TBL-LIBC-LOC-DATA"
>Table 13-9</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LOC-DATA"
></A
><P
><B
>Table 13-9. libc - Localization Functions Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_nl_msg_cat_cntr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3485"
>13.3.6. Socket Interface</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3488"
>13.3.6.1. Interfaces for Socket Interface</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Socket Interface specified in <A
HREF="#TBL-LIBC-SOC-INTS"
>Table 13-10</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SOC-INTS"
></A
><P
><B
>Table 13-10. libc - Socket Interface Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__h_errno_location <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>accept <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>bind <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>bindresvport <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>connect <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>gethostid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>gethostname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpeername <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getsockname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getsockopt <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>if_freenameindex <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>if_indextoname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>if_nameindex <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>if_nametoindex <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>listen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>recv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>recvfrom <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>recvmsg <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>send <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sendmsg <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sendto <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setsockopt <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>shutdown <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sockatmark <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>socket <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>socketpair <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3609"
>13.3.7. Wide Characters</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3612"
>13.3.7.1. Interfaces for Wide Characters</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Wide Characters specified in <A
HREF="#TBL-LIBC-WID-INTS"
>Table 13-11</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-WID-INTS"
></A
><P
><B
>Table 13-11. libc - Wide Characters Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__wcstod_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstof_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstol_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstold_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcstoul_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>btowc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fgetwc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fgetws <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fputwc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fputws <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fwide <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fwprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fwscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getwc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getwchar <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mblen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>mbrlen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mbrtowc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mbsinit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mbsnrtowcs <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>mbsrtowcs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mbstowcs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mbtowc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>putwc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>putwchar <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>swprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>swscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>towctrans <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>towlower <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>towupper <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ungetwc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>vfwprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>vfwscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vswprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>vswscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vwprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>vwscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcpcpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcpncpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcrtomb <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcscasecmp <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcscat <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcschr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcscmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcscoll <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcscpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcscspn <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsdup <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>wcsftime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcslen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsncasecmp <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcsncat <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcsncmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsncpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsnlen <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcsnrtombs <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>wcspbrk <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsrchr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsrtombs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcsspn <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcsstr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstod <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstof <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstoimax <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcstok <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstol <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstold <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstoll <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcstombs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstoq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcstoul <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstoull <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcstoumax <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcstouq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcswcs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcswidth <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wcsxfrm <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wctob <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wctomb <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wctrans <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wctype <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wcwidth <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wmemchr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wmemcmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wmemcpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wmemmove <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wmemset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>wprintf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4002"
>13.3.8. String Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4005"
>13.3.8.1. Interfaces for String Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for String Functions specified in <A
HREF="#TBL-LIBC-STR-INTS"
>Table 13-12</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STR-INTS"
></A
><P
><B
>Table 13-12. libc - String Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__mempcpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__rawmemchr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__stpcpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strdup <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strtod_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtof_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtok_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtol_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strtold_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtoll_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtoul_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtoull_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>bcmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>bcopy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>bzero <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ffs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>index <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>memccpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>memchr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>memcmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>memcpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>memmove <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>memrchr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>memset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>rindex <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>stpcpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>stpncpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strcasecmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strcasestr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strcat <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strchr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strcmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strcoll <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strcpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strcspn <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strdup <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strerror <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strerror_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strfmon <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strftime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strlen <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strncasecmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strncat <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strncmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strncpy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strndup <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strnlen <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strpbrk <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strptime <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strrchr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strsep <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strsignal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>strspn <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strstr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtof <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtoimax <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strtok <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtok_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtold <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtoll <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strtoq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strtoull <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtoumax <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtouq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>strxfrm <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>swab <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4296"
>13.3.9. IPC Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4299"
>13.3.9.1. Interfaces for IPC Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for IPC Functions specified in <A
HREF="#TBL-LIBC-IPC-INTS"
>Table 13-13</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-IPC-INTS"
></A
><P
><B
>Table 13-13. libc - IPC Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ftok <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>msgctl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>msgget <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>msgrcv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>msgsnd <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>semctl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>semget <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>semop <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>shmat <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>shmctl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>shmdt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>shmget <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4358"
>13.3.10. Regular Expressions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4361"
>13.3.10.1. Interfaces for Regular Expressions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Regular Expressions specified in <A
HREF="#TBL-LIBC-REG-INTS"
>Table 13-14</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-REG-INTS"
></A
><P
><B
>Table 13-14. libc - Regular Expressions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>regcomp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>regerror <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>regexec <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>regfree <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4386"
>13.3.11. Character Type Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4389"
>13.3.11.1. Interfaces for Character Type Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Character Type Functions specified in <A
HREF="#TBL-LIBC-CHA-INTS"
>Table 13-15</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-CHA-INTS"
></A
><P
><B
>Table 13-15. libc - Character Type Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__ctype_b_loc(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ctype_get_mb_cur_max <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ctype_tolower_loc(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ctype_toupper_loc(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>_tolower <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>_toupper <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isalnum <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isalpha <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>isascii <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iscntrl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isdigit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isgraph <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>islower <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isprint <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ispunct <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isspace <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>isupper <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswalnum <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswalpha <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswblank <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>iswcntrl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswctype <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswdigit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswgraph <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>iswlower <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswprint <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswpunct <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswspace <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>iswupper <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>iswxdigit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isxdigit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>toascii <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>tolower <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>toupper <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4544"
>13.3.12. Time Manipulation</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4547"
>13.3.12.1. Interfaces for Time Manipulation</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Time Manipulation specified in <A
HREF="#TBL-LIBC-TIM-INTS"
>Table 13-16</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-TIM-INTS"
></A
><P
><B
>Table 13-16. libc - Time Manipulation Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>adjtime <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>asctime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>asctime_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ctime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ctime_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>difftime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>gmtime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>gmtime_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>localtime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>localtime_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mktime <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tzset <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ualarm <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Time Manipulation specified in <A
HREF="#TBL-LIBC-TIM-DATA"
>Table 13-17</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-TIM-DATA"
></A
><P
><B
>Table 13-17. libc - Time Manipulation Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__daylight <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__timezone <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__tzname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>daylight <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>timezone <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tzname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4648"
>13.3.13. Terminal Interface Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4651"
>13.3.13.1. Interfaces for Terminal Interface Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Terminal Interface Functions specified in <A
HREF="#TBL-LIBC-TER-INTS"
>Table 13-18</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-TER-INTS"
></A
><P
><B
>Table 13-18. libc - Terminal Interface Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>cfgetispeed <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>cfgetospeed <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>cfmakeraw <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>cfsetispeed <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cfsetospeed <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>cfsetspeed <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>tcdrain <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tcflow <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>tcflush <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tcgetattr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tcgetpgrp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tcgetsid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>tcsendbreak <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tcsetattr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tcsetpgrp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4724"
>13.3.14. System Database Interface</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4727"
>13.3.14.1. Interfaces for System Database Interface</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for System Database Interface specified in <A
HREF="#TBL-LIBC-SYT-INTS"
>Table 13-19</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SYT-INTS"
></A
><P
><B
>Table 13-19. libc - System Database Interface Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>endgrent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>endprotoent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>endpwent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>endservent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>endutent <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>endutxent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getgrent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getgrgid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getgrgid_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getgrnam <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getgrnam_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getgrouplist <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>gethostbyaddr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>gethostbyname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getprotobyname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getprotobynumber <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getprotoent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpwent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpwnam <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpwnam_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getpwuid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getpwuid_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getservbyname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getservbyport <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getservent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getutent <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getutent_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getutxent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getutxid <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getutxline <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>pututxline <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setgrent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setgroups <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setprotoent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setpwent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setservent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setutent <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setutxent <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>utmpname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4902"
>13.3.15. Language Support</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4905"
>13.3.15.1. Interfaces for Language Support</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Language Support specified in <A
HREF="#TBL-LIBC-LAN-INTS"
>Table 13-20</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LAN-INTS"
></A
><P
><B
>Table 13-20. libc - Language Support Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__libc_start_main <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__register_atfork(GLIBC_2.3.2) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4924"
>13.3.16. Large File Support</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4927"
>13.3.16.1. Interfaces for Large File Support</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Large File Support specified in <A
HREF="#TBL-LIBC-LAR-INTS"
>Table 13-21</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LAR-INTS"
></A
><P
><B
>Table 13-21. libc - Large File Support Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__fxstat64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__lxstat64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xstat64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>creat64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>fgetpos64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fopen64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>freopen64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fseeko64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>fsetpos64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fstatvfs64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>ftello64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>ftruncate64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>ftw64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>getrlimit64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>lockf64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>mkstemp64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>mmap64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>nftw64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>readdir64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>statvfs64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>tmpfile64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>truncate64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5031"
>13.3.17. Standard Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5034"
>13.3.17.1. Interfaces for Standard Library</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Standard Library specified in <A
HREF="#TBL-LIBC-STB-INTS"
>Table 13-22</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STB-INTS"
></A
><P
><B
>Table 13-22. libc - Standard Library Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Exit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>__assert_fail <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__cxa_atexit <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__errno_location <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fpending <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__getpagesize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isinf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isinff <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__isinfl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isnan <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isnanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isnanl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__sysconf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_exit <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>_longjmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>_setjmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>a64l <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>abort <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>abs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>atof <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>atoi <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>atol <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>atoll <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>basename <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>bsearch <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>calloc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>closelog <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>confstr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cuserid <A
HREF="#REFSTD.LIBC.3"
>[SUSv2]</A
></TD
><TD
>daemon <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>dirname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>div <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>drand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ecvt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>erand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>err <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>error <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>errx <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fcvt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fmtmsg <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fnmatch <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>fpathconf <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>free <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>freeaddrinfo <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ftrylockfile <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ftw <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>funlockfile <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>gai_strerror <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>gcvt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getaddrinfo <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getcwd <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getdate <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getenv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getlogin <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getlogin_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>getnameinfo <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getopt <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getopt_long <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getopt_long_only <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getsubopt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>gettimeofday <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>glob <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>glob64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>globfree <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>globfree64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>grantpt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>hcreate <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>hdestroy <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>hsearch <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>htonl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>htons <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>imaxabs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>imaxdiv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>inet_addr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>inet_ntoa <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>inet_ntop <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>inet_pton <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>initstate <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>insque <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>isatty <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>isblank <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>jrand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>l64a <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>labs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>lcong48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ldiv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>lfind <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>llabs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>lldiv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>longjmp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>lrand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>lsearch <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>makecontext <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>malloc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>memmem <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>mkstemp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>mktemp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>mrand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>nftw <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>nrand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ntohl <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ntohs <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>openlog <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>perror <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>posix_memalign <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>posix_openpt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ptsname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>putenv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>qsort <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>rand <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>rand_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>random <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>realloc <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>realpath <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>remque <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>seed48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setenv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>sethostname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setlogmask <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>setstate <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>srand <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>srand48 <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>srandom <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtod <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>strtol <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>strtoul <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>swapcontext <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>syslog <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>system <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>tdelete <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tfind <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tmpfile <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>tmpnam <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>tsearch <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ttyname <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>ttyname_r <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>twalk <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>unlockpt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>unsetenv <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>usleep <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>verrx <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vfscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vsscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>vsyslog <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>warn <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>warnx <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wordexp <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>wordfree <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Standard Library specified in <A
HREF="#TBL-LIBC-STB-DATA"
>Table 13-23</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STB-DATA"
></A
><P
><B
>Table 13-23. libc - Standard Library Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__environ <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_environ <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_sys_errlist <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>environ <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getdate_err <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>optarg <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>opterr <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>optind <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>optopt <A
HREF="#REFSTD.LIBC.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBC-DDEFS"
>13.4. Data Definitions for libc</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libc.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5733"
>13.4.1. arpa/inet.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern uint32_t htonl(uint32_t);
extern uint16_t htons(uint16_t);
extern in_addr_t inet_addr(const char *);
extern char *inet_ntoa(struct in_addr);
extern const char *inet_ntop(int, const void *, char *, socklen_t);
extern int inet_pton(int, const char *, void *);
extern uint32_t ntohl(uint32_t);
extern uint16_t ntohs(uint16_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5737"
>13.4.2. assert.h</A
></H3
><P
>The <TT
CLASS="FILENAME"
>assert.h</TT
> header shall define the
<TT
CLASS="FUNCTION"
>assert()</TT
> macro. It refers to the macro
<CODE
CLASS="CONSTANT"
>NDEBUG</CODE
>, which is not defined in this
header.
If <CODE
CLASS="CONSTANT"
>NDEBUG</CODE
> is defined before the inclusion of
this header, the <TT
CLASS="FUNCTION"
>assert()</TT
> macro shall be defined
as described below, otherwise the macro shall behave as described
in <TT
CLASS="FUNCTION"
>assert()</TT
> in ISO/IEC 9945 POSIX.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void __assert_fail(const char *, const char *, unsigned int,
			  const char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5747"
>13.4.3. ctype.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum {
    _ISupper, _ISlower, _ISalpha, _ISdigit, _ISxdigit, _ISspace, _ISprint,
	_ISgraph, _ISblank, _IScntrl, _ISpunct, _ISalnum
};
extern int _tolower(int);
extern int _toupper(int);
extern int isalnum(int);
extern int isalpha(int);
extern int isascii(int);
extern int iscntrl(int);
extern int isdigit(int);
extern int isgraph(int);
extern int islower(int);
extern int isprint(int);
extern int ispunct(int);
extern int isspace(int);
extern int isupper(int);
extern int isxdigit(int);
extern int toascii(int);
extern int tolower(int);
extern int toupper(int);
extern int isblank(int);
extern const unsigned short **__ctype_b_loc(void);
extern const int32_t **__ctype_toupper_loc(void);
extern const int32_t **__ctype_tolower_loc(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5751"
>13.4.4. dirent.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct __dirstream DIR;

struct dirent {
    long int d_ino;
    off_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
struct dirent64 {
    uint64_t d_ino;
    int64_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
extern void rewinddir(DIR *);
extern void seekdir(DIR *, long int);
extern long int telldir(DIR *);
extern int closedir(DIR *);
extern DIR *opendir(const char *);
extern struct dirent *readdir(DIR *);
extern struct dirent64 *readdir64(DIR *);
extern int readdir_r(DIR *, struct dirent *, struct dirent **);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5755"
>13.4.5. err.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void err(int, const char *, ...);
extern void errx(int, const char *, ...);
extern void warn(const char *, ...);
extern void warnx(const char *, ...);
extern void error(int, int, const char *, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5759"
>13.4.6. errno.h</A
></H3
><P
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> requires that each error value 
shall be unique, with permission for
<SPAN
CLASS="ERRORCODE"
>EAGAIN</SPAN
> and <SPAN
CLASS="ERRORCODE"
>EWOULDBLOCK</SPAN
>
possibly having the same value. This specification also requires
that <SPAN
CLASS="ERRORCODE"
>ENOTSUP</SPAN
> and <SPAN
CLASS="ERRORCODE"
>EOPNOTSUPP</SPAN
>
have the same value.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>A defect report against <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> has been filed
to request that specification also permit these two symbols to have the
same value.</P
></BLOCKQUOTE
></DIV
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define errno	(*__errno_location())

#define EPERM	1
#define ECHILD	10
#define ENETDOWN	100
#define ENETUNREACH	101
#define ENETRESET	102
#define ECONNABORTED	103
#define ECONNRESET	104
#define ENOBUFS	105
#define EISCONN	106
#define ENOTCONN	107
#define ESHUTDOWN	108
#define ETOOMANYREFS	109
#define EAGAIN	11
#define ETIMEDOUT	110
#define ECONNREFUSED	111
#define EHOSTDOWN	112
#define EHOSTUNREACH	113
#define EALREADY	114
#define EINPROGRESS	115
#define ESTALE	116
#define EUCLEAN	117
#define ENOTNAM	118
#define ENAVAIL	119
#define ENOMEM	12
#define EISNAM	120
#define EREMOTEIO	121
#define EDQUOT	122
#define ENOMEDIUM	123
#define EMEDIUMTYPE	124
#define ECANCELED	125
#define EACCES	13
#define EFAULT	14
#define ENOTBLK	15
#define EBUSY	16
#define EEXIST	17
#define EXDEV	18
#define ENODEV	19
#define ENOENT	2
#define ENOTDIR	20
#define EISDIR	21
#define EINVAL	22
#define ENFILE	23
#define EMFILE	24
#define ENOTTY	25
#define ETXTBSY	26
#define EFBIG	27
#define ENOSPC	28
#define ESPIPE	29
#define ESRCH	3
#define EROFS	30
#define EMLINK	31
#define EPIPE	32
#define EDOM	33
#define ERANGE	34
#define EDEADLK	35
#define ENAMETOOLONG	36
#define ENOLCK	37
#define ENOSYS	38
#define ENOTEMPTY	39
#define EINTR	4
#define ELOOP	40
#define ENOMSG	42
#define EIDRM	43
#define ECHRNG	44
#define EL2NSYNC	45
#define EL3HLT	46
#define EL3RST	47
#define ELNRNG	48
#define EUNATCH	49
#define EIO	5
#define ENOANO	55
#define EBADRQC	56
#define EBADSLT	57
#define EBFONT	59
#define ENXIO	6
#define ENOSTR	60
#define ENODATA	61
#define ETIME	62
#define ENOSR	63
#define ENONET	64
#define ENOPKG	65
#define EREMOTE	66
#define ENOLINK	67
#define EADV	68
#define ESRMNT	69
#define E2BIG	7
#define ECOMM	70
#define EPROTO	71
#define EMULTIHOP	72
#define EDOTDOT	73
#define EBADMSG	74
#define EOVERFLOW	75
#define ENOTUNIQ	76
#define EBADFD	77
#define EREMCHG	78
#define ELIBACC	79
#define ENOEXEC	8
#define ELIBBAD	80
#define ELIBSCN	81
#define ELIBMAX	82
#define ELIBEXEC	83
#define EILSEQ	84
#define ERESTART	85
#define ESTRPIPE	86
#define EUSERS	87
#define ENOTSOCK	88
#define EDESTADDRREQ	89
#define EBADF	9
#define EMSGSIZE	90
#define EPROTOTYPE	91
#define ENOPROTOOPT	92
#define EPROTONOSUPPORT	93
#define ESOCKTNOSUPPORT	94
#define EOPNOTSUPP	95
#define EPFNOSUPPORT	96
#define EAFNOSUPPORT	97
#define EADDRINUSE	98
#define EADDRNOTAVAIL	99
#define EWOULDBLOCK	EAGAIN
#define ENOTSUP	EOPNOTSUPP

extern int *__errno_location(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5771"
>13.4.7. fcntl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define O_RDONLY	00
#define O_ACCMODE	0003
#define O_WRONLY	01
#define O_CREAT	0100
#define O_TRUNC	01000
#define O_SYNC	010000
#define O_RDWR	02
#define O_EXCL	0200
#define O_APPEND	02000
#define O_ASYNC	020000
#define O_NOCTTY	0400
#define O_NDELAY	04000
#define O_NONBLOCK	04000
#define FD_CLOEXEC	1

struct flock {
    short l_type;
    short l_whence;
    off_t l_start;
    off_t l_len;
    pid_t l_pid;
};
struct flock64 {
    short l_type;
    short l_whence;
    loff_t l_start;
    loff_t l_len;
    pid_t l_pid;
};

#define F_DUPFD	0
#define F_RDLCK	0
#define F_GETFD	1
#define F_WRLCK	1
#define F_SETFD	2
#define F_UNLCK	2
#define F_GETFL	3
#define F_SETFL	4
#define F_GETLK	5
#define F_SETLK	6
#define F_SETLKW	7
#define F_SETOWN	8
#define F_GETOWN	9

extern int lockf64(int, int, off64_t);
extern int fcntl(int, int, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5775"
>13.4.8. fmtmsg.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MM_HARD	1
#define MM_NRECOV	128
#define MM_UTIL	16
#define MM_SOFT	2
#define MM_OPSYS	32
#define MM_FIRM	4
#define MM_RECOVER	64
#define MM_APPL	8

#define MM_NOSEV	0
#define MM_HALT	1
#define MM_ERROR	2

#define MM_NULLLBL	((char *) 0)

extern int fmtmsg(long int, const char *, int, const char *, const char *,
		  const char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5779"
>13.4.9. fnmatch.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FNM_PATHNAME	(1&#60;&#60;0)
#define FNM_NOESCAPE	(1&#60;&#60;1)
#define FNM_PERIOD	(1&#60;&#60;2)
#define FNM_NOMATCH	1

extern int fnmatch(const char *, const char *, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5783"
>13.4.10. ftw.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FTW_D	FTW_D
#define FTW_DNR	FTW_DNR
#define FTW_DP	FTW_DP
#define FTW_F	FTW_F
#define FTW_NS	FTW_NS
#define FTW_SL	FTW_SL
#define FTW_SLN	FTW_SLN

enum {
    FTW_F, FTW_D, FTW_DNR, FTW_NS, FTW_SL, FTW_DP, FTW_SLN
};

enum {
    FTW_PHYS, FTW_MOUNT, FTW_CHDIR, FTW_DEPTH
};

struct FTW {
    int base;
    int level;
};

typedef int (*__ftw_func_t) (char *__filename, struct stat * __status,
			     int __flag);
typedef int (*__ftw64_func_t) (char *__filename, struct stat64 * __status,
			       int __flag);
typedef int (*__nftw_func_t) (char *__filename, struct stat * __status,
			      int __flag, struct FTW * __info);
typedef int (*__nftw64_func_t) (char *__filename, struct stat64 * __status,
				int __flag, struct FTW * __info);
extern int ftw(const char *, __ftw_func_t, int);
extern int ftw64(const char *, __ftw64_func_t, int);
extern int nftw(const char *, __nftw_func_t, int, int);
extern int nftw64(const char *, __nftw64_func_t, int, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5787"
>13.4.11. getopt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define no_argument	0
#define required_argument	1
#define optional_argument	2

struct option {
    char *name;
    int has_arg;
    int *flag;
    int val;
};
extern int getopt_long(int, char *const, const char *,
		       const struct option *, int *);
extern int getopt_long_only(int, char *const, const char *,
			    const struct option *, int *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5791"
>13.4.12. glob.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define GLOB_ERR	(1&#60;&#60;0)
#define GLOB_MARK	(1&#60;&#60;1)
#define GLOB_BRACE	(1&#60;&#60;10)
#define GLOB_NOMAGIC	(1&#60;&#60;11)
#define GLOB_TILDE	(1&#60;&#60;12)
#define GLOB_ONLYDIR	(1&#60;&#60;13)
#define GLOB_TILDE_CHECK	(1&#60;&#60;14)
#define GLOB_NOSORT	(1&#60;&#60;2)
#define GLOB_DOOFFS	(1&#60;&#60;3)
#define GLOB_NOCHECK	(1&#60;&#60;4)
#define GLOB_APPEND	(1&#60;&#60;5)
#define GLOB_NOESCAPE	(1&#60;&#60;6)
#define GLOB_PERIOD	(1&#60;&#60;7)
#define GLOB_MAGCHAR	(1&#60;&#60;8)
#define GLOB_ALTDIRFUNC	(1&#60;&#60;9)

#define GLOB_NOSPACE	1
#define GLOB_ABORTED	2
#define GLOB_NOMATCH	3
#define GLOB_NOSYS	4

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob_t;

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent64 *(*gl_readdir64) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob64_t;
extern int glob(const char *, int,
		int (*__errfunc) (const char *p1, int p2)
		, glob_t *);
extern int glob64(const char *, int,
		  int (*__errfunc) (const char *p1, int p2)
		  , glob64_t *);
extern void globfree(glob_t *);
extern void globfree64(glob64_t *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5795"
>13.4.13. grp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct group {
    char *gr_name;
    char *gr_passwd;
    gid_t gr_gid;
    char **gr_mem;
};

extern void endgrent(void);
extern struct group *getgrent(void);
extern struct group *getgrgid(gid_t);
extern struct group *getgrnam(char *);
extern int initgroups(const char *, gid_t);
extern void setgrent(void);
extern int setgroups(size_t, const gid_t *);
extern int getgrgid_r(gid_t, struct group *, char *, size_t,
		      struct group **);
extern int getgrnam_r(const char *, struct group *, char *, size_t,
		      struct group **);
extern int getgrouplist(const char *, gid_t, gid_t *, int *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5799"
>13.4.14. iconv.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef void *iconv_t;
extern size_t iconv(iconv_t, char **, size_t *, char **, size_t *);
extern int iconv_close(iconv_t);
extern iconv_t iconv_open(char *, char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5803"
>13.4.15. inttypes.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef lldiv_t imaxdiv_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;

extern intmax_t strtoimax(const char *, char **, int);
extern uintmax_t strtoumax(const char *, char **, int);
extern intmax_t wcstoimax(const wchar_t *, wchar_t * *, int);
extern uintmax_t wcstoumax(const wchar_t *, wchar_t * *, int);
extern intmax_t imaxabs(intmax_t);
extern imaxdiv_t imaxdiv(intmax_t, intmax_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5807"
>13.4.16. langinfo.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ABDAY_1	0x20000
#define ABDAY_2	0x20001
#define ABDAY_3	0x20002
#define ABDAY_4	0x20003
#define ABDAY_5	0x20004
#define ABDAY_6	0x20005
#define ABDAY_7	0x20006

#define DAY_1	0x20007
#define DAY_2	0x20008
#define DAY_3	0x20009
#define DAY_4	0x2000A
#define DAY_5	0x2000B
#define DAY_6	0x2000C
#define DAY_7	0x2000D

#define ABMON_1	0x2000E
#define ABMON_2	0x2000F
#define ABMON_3	0x20010
#define ABMON_4	0x20011
#define ABMON_5	0x20012
#define ABMON_6	0x20013
#define ABMON_7	0x20014
#define ABMON_8	0x20015
#define ABMON_9	0x20016
#define ABMON_10	0x20017
#define ABMON_11	0x20018
#define ABMON_12	0x20019

#define MON_1	0x2001A
#define MON_2	0x2001B
#define MON_3	0x2001C
#define MON_4	0x2001D
#define MON_5	0x2001E
#define MON_6	0x2001F
#define MON_7	0x20020
#define MON_8	0x20021
#define MON_9	0x20022
#define MON_10	0x20023
#define MON_11	0x20024
#define MON_12	0x20025

#define AM_STR	0x20026
#define PM_STR	0x20027

#define D_T_FMT	0x20028
#define D_FMT	0x20029
#define T_FMT	0x2002A
#define T_FMT_AMPM	0x2002B

#define ERA	0x2002C
#define ERA_D_FMT	0x2002E
#define ALT_DIGITS	0x2002F
#define ERA_D_T_FMT	0x20030
#define ERA_T_FMT	0x20031

#define CODESET	14

#define CRNCYSTR	0x4000F

#define RADIXCHAR	0x10000
#define THOUSEP	0x10001
#define YESEXPR	0x50000
#define NOEXPR	0x50001
#define YESSTR	0x50002
#define NOSTR	0x50003

extern char *nl_langinfo(nl_item);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5811"
>13.4.17. libgen.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern char *basename(const char *);
extern char *dirname(char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5815"
>13.4.18. libintl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern char *bindtextdomain(const char *, const char *);
extern char *dcgettext(const char *, const char *, int);
extern char *dgettext(const char *, const char *);
extern char *gettext(const char *);
extern char *textdomain(const char *);
extern char *bind_textdomain_codeset(const char *, const char *);
extern char *dcngettext(const char *, const char *, const char *,
			unsigned long int, int);
extern char *dngettext(const char *, const char *, const char *,
		       unsigned long int);
extern char *ngettext(const char *, const char *, unsigned long int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5819"
>13.4.19. limits.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LLONG_MIN	(-LLONG_MAX-1LL)
#define ULLONG_MAX	18446744073709551615ULL
#define OPEN_MAX	256
#define PATH_MAX	4096
#define LLONG_MAX	9223372036854775807LL
#define SSIZE_MAX	LONG_MAX

#define MB_LEN_MAX	16

#define SCHAR_MIN	(-128)
#define SCHAR_MAX	127
#define UCHAR_MAX	255
#define CHAR_BIT	8

#define SHRT_MIN	(-32768)
#define SHRT_MAX	32767
#define USHRT_MAX	65535

#define INT_MIN	(-INT_MAX-1)
#define INT_MAX	2147483647
#define __INT_MAX__	2147483647
#define UINT_MAX	4294967295U

#define LONG_MIN	(-LONG_MAX-1L)

#define PTHREAD_KEYS_MAX	1024
#define PTHREAD_THREADS_MAX	16384
#define PTHREAD_DESTRUCTOR_ITERATIONS	4</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5823"
>13.4.20. locale.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};

#define LC_GLOBAL_LOCALE	((locale_t) -1L)
#define LC_CTYPE	0
#define LC_NUMERIC	1
#define LC_TELEPHONE	10
#define LC_MEASUREMENT	11
#define LC_IDENTIFICATION	12
#define LC_TIME	2
#define LC_COLLATE	3
#define LC_MONETARY	4
#define LC_MESSAGES	5
#define LC_ALL	6
#define LC_PAPER	7
#define LC_NAME	8
#define LC_ADDRESS	9

typedef struct __locale_struct {
    struct locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
} *__locale_t;

typedef struct __locale_struct *locale_t;

#define LC_ADDRESS_MASK	(1 &#60;&#60; LC_ADDRESS)
#define LC_COLLATE_MASK	(1 &#60;&#60; LC_COLLATE)
#define LC_IDENTIFICATION_MASK	(1 &#60;&#60; LC_IDENTIFICATION)
#define LC_MEASUREMENT_MASK	(1 &#60;&#60; LC_MEASUREMENT)
#define LC_MESSAGES_MASK	(1 &#60;&#60; LC_MESSAGES)
#define LC_MONETARY_MASK	(1 &#60;&#60; LC_MONETARY)
#define LC_NAME_MASK	(1 &#60;&#60; LC_NAME)
#define LC_NUMERIC_MASK	(1 &#60;&#60; LC_NUMERIC)
#define LC_PAPER_MASK	(1 &#60;&#60; LC_PAPER)
#define LC_TELEPHONE_MASK	(1 &#60;&#60; LC_TELEPHONE)
#define LC_TIME_MASK	(1 &#60;&#60; LC_TIME)
#define LC_CTYPE_MASK	(1&#60;&#60;LC_CTYPE)
#define LC_ALL_MASK	\
        (LC_CTYPE_MASK| LC_NUMERIC_MASK| LC_TIME_MASK| LC_COLLATE_MASK| LC_MONETARY_MASK|\
         LC_MESSAGES_MASK| LC_PAPER_MASK| LC_NAME_MASK| LC_ADDRESS_MASK| LC_TELEPHONE_MASK|\
         LC_MEASUREMENT_MASK| LC_IDENTIFICATION_MASK)

extern struct lconv *localeconv(void);
extern char *setlocale(int, const char *);
extern locale_t uselocale(locale_t);
extern void freelocale(locale_t);
extern locale_t duplocale(locale_t);
extern locale_t newlocale(int, const char *, locale_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5827"
>13.4.21. monetary.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t strfmon(char *, size_t, const char *, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5831"
>13.4.22. net/if.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IF_NAMESIZE	16

#define IFF_UP	0x01
#define IFF_BROADCAST	0x02
#define IFF_DEBUG	0x04
#define IFF_LOOPBACK	0x08
#define IFF_POINTOPOINT	0x10
#define IFF_PROMISC	0x100
#define IFF_MULTICAST	0x1000
#define IFF_NOTRAILERS	0x20
#define IFF_RUNNING	0x40
#define IFF_NOARP	0x80

struct if_nameindex {
    unsigned int if_index;
    char *if_name;
};

struct ifaddr {
    struct sockaddr ifa_addr;
    union {
	struct sockaddr ifu_broadaddr;
	struct sockaddr ifu_dstaddr;
    } ifa_ifu;
    void *ifa_ifp;
    void *ifa_next;
};

#define IFNAMSIZ	IF_NAMESIZE

struct ifreq {
    union {
	char ifrn_name[IFNAMSIZ];
    } ifr_ifrn;
    union {
	struct sockaddr ifru_addr;
	struct sockaddr ifru_dstaddr;
	struct sockaddr ifru_broadaddr;
	struct sockaddr ifru_netmask;
	struct sockaddr ifru_hwaddr;
	short ifru_flags;
	int ifru_ivalue;
	int ifru_mtu;
	char ifru_slave[IFNAMSIZ];
	char ifru_newname[IFNAMSIZ];
	caddr_t ifru_data;
	struct ifmap ifru_map;
    } ifr_ifru;
};

struct ifconf {
    int ifc_len;
    union {
	caddr_t ifcu_buf;
	struct ifreq *ifcu_req;
    } ifc_ifcu;
};
extern void if_freenameindex(struct if_nameindex *);
extern char *if_indextoname(unsigned int, char *);
extern struct if_nameindex *if_nameindex(void);
extern unsigned int if_nametoindex(const char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5835"
>13.4.23. netdb.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NETDB_INTERNAL	-1
#define NETDB_SUCCESS	0
#define HOST_NOT_FOUND	1
#define IPPORT_RESERVED	1024
#define NI_MAXHOST	1025
#define TRY_AGAIN	2
#define NO_RECOVERY	3
#define NI_MAXSERV	32
#define NO_DATA	4
#define h_addr	h_addr_list[0]
#define NO_ADDRESS	NO_DATA

struct servent {
    char *s_name;
    char **s_aliases;
    int s_port;
    char *s_proto;
};
struct hostent {
    char *h_name;
    char **h_aliases;
    int h_addrtype;
    int h_length;
    char **h_addr_list;
};
struct protoent {
    char *p_name;
    char **p_aliases;
    int p_proto;
};
struct netent {
    char *n_name;
    char **n_aliases;
    int n_addrtype;
    unsigned int n_net;
};

#define AI_PASSIVE	0x0001
#define AI_CANONNAME	0x0002
#define AI_NUMERICHOST	0x0004

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
};

#define NI_NUMERICHOST	1
#define NI_DGRAM	16
#define NI_NUMERICSERV	2
#define NI_NOFQDN	4
#define NI_NAMEREQD	8

#define EAI_BADFLAGS	-1
#define EAI_MEMORY	-10
#define EAI_SYSTEM	-11
#define EAI_NONAME	-2
#define EAI_AGAIN	-3
#define EAI_FAIL	-4
#define EAI_NODATA	-5
#define EAI_FAMILY	-6
#define EAI_SOCKTYPE	-7
#define EAI_SERVICE	-8
#define EAI_ADDRFAMILY	-9

extern void endprotoent(void);
extern void endservent(void);
extern void freeaddrinfo(struct addrinfo *);
extern const char *gai_strerror(int);
extern int getaddrinfo(const char *, const char *, const struct addrinfo *,
		       struct addrinfo **);
extern struct hostent *gethostbyaddr(const void *, socklen_t, int);
extern struct hostent *gethostbyname(const char *);
extern struct protoent *getprotobyname(const char *);
extern struct protoent *getprotobynumber(int);
extern struct protoent *getprotoent(void);
extern struct servent *getservbyname(const char *, const char *);
extern struct servent *getservbyport(int, const char *);
extern struct servent *getservent(void);
extern void setprotoent(int);
extern void setservent(int);
extern int *__h_errno_location(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5839"
>13.4.24. netinet/in.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPPROTO_IP	0
#define IPPROTO_ICMP	1
#define IPPROTO_UDP	17
#define IPPROTO_IGMP	2
#define IPPROTO_RAW	255
#define IPPROTO_IPV6	41
#define IPPROTO_ICMPV6	58
#define IPPROTO_TCP	6

typedef uint16_t in_port_t;

struct in_addr {
    uint32_t s_addr;
};
typedef uint32_t in_addr_t;

#define INADDR_NONE	((in_addr_t) 0xffffffff)
#define INADDR_BROADCAST	(0xffffffff)
#define INADDR_ANY	0

struct in6_addr {
    union {
	uint8_t u6_addr8[16];
	uint16_t u6_addr16[8];
	uint32_t u6_addr32[4];
    } in6_u;
};

#define IN6ADDR_ANY_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
#define IN6ADDR_LOOPBACK_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

#define INET_ADDRSTRLEN	16

struct sockaddr_in {
    sa_family_t sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    unsigned char sin_zero[8];
};

#define INET6_ADDRSTRLEN	46

struct sockaddr_in6 {
    unsigned short sin6_family;
    uint16_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
};

#define SOL_IP	0
#define IP_TOS	1
#define IPV6_UNICAST_HOPS	16
#define IPV6_MULTICAST_IF	17
#define IPV6_MULTICAST_HOPS	18
#define IPV6_MULTICAST_LOOP	19
#define IP_TTL	2
#define IPV6_JOIN_GROUP	20
#define IPV6_LEAVE_GROUP	21
#define IPV6_V6ONLY	26
#define IP_MULTICAST_IF	32
#define IP_MULTICAST_TTL	33
#define IP_MULTICAST_LOOP	34
#define IP_ADD_MEMBERSHIP	35
#define IP_DROP_MEMBERSHIP	36
#define IP_OPTIONS	4

struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;
    int ipv6mr_interface;
};
struct ip_mreq {
    struct in_addr imr_multiaddr;
    struct in_addr imr_interface;
};
extern int bindresvport(int, struct sockaddr_in *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5843"
>13.4.25. netinet/ip.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPTOS_LOWCOST	0x02
#define IPTOS_RELIABILITY	0x04
#define IPTOS_THROUGHPUT	0x08
#define IPTOS_LOWDELAY	0x10
#define IPTOS_TOS_MASK	0x1e
#define IPTOS_MINCOST	IPTOS_LOWCOST

#define IPTOS_PREC_MASK	0xe0</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5847"
>13.4.26. netinet/tcp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define TCP_NODELAY	1
#define SOL_TCP	6</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5851"
>13.4.27. netinet/udp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SOL_UDP	17</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5855"
>13.4.28. nl_types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NL_CAT_LOCALE	1
#define NL_SETD	1

typedef void *nl_catd;

typedef int nl_item;
extern int catclose(nl_catd);
extern char *catgets(nl_catd, int, int, const char *);
extern nl_catd catopen(const char *, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5859"
>13.4.29. poll.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int poll(struct pollfd *, nfds_t, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5863"
>13.4.30. pty.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int openpty(int *, int *, char *, struct termios *,
		   struct winsize *);
extern int forkpty(int *, char *, struct termios *, struct winsize *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5867"
>13.4.31. pwd.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct passwd {
    char *pw_name;
    char *pw_passwd;
    uid_t pw_uid;
    gid_t pw_gid;
    char *pw_gecos;
    char *pw_dir;
    char *pw_shell;
};
extern void endpwent(void);
extern struct passwd *getpwent(void);
extern struct passwd *getpwnam(char *);
extern struct passwd *getpwuid(uid_t);
extern void setpwent(void);
extern int getpwnam_r(char *, struct passwd *, char *, size_t,
		      struct passwd **);
extern int getpwuid_r(uid_t, struct passwd *, char *, size_t,
		      struct passwd **);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5871"
>13.4.32. regex.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef unsigned long int reg_syntax_t;

typedef struct re_pattern_buffer {
    unsigned char *buffer;
    unsigned long int allocated;
    unsigned long int used;
    reg_syntax_t syntax;
    char *fastmap;
    char *translate;
    size_t re_nsub;
    unsigned int can_be_null:1;
    unsigned int regs_allocated:2;
    unsigned int fastmap_accurate:1;
    unsigned int no_sub:1;
    unsigned int not_bol:1;
    unsigned int not_eol:1;
    unsigned int newline_anchor:1;
} regex_t;
typedef int regoff_t;
typedef struct {
    regoff_t rm_so;
    regoff_t rm_eo;
} regmatch_t;

#define REG_ICASE	(REG_EXTENDED&#60;&#60;1)
#define REG_NEWLINE	(REG_ICASE&#60;&#60;1)
#define REG_NOSUB	(REG_NEWLINE&#60;&#60;1)
#define REG_EXTENDED	1

#define REG_NOTEOL	(1&#60;&#60;1)
#define REG_NOTBOL	1

typedef enum {
    REG_ENOSYS, REG_NOERROR, REG_NOMATCH, REG_BADPAT, REG_ECOLLATE,
	REG_ECTYPE, REG_EESCAPE, REG_ESUBREG, REG_EBRACK, REG_EPAREN,
	REG_EBRACE, REG_BADBR, REG_ERANGE, REG_ESPACE, REG_BADRPT,
	REG_EEND, REG_ESIZE, REG_ERPAREN
} reg_errcode_t;
extern int regcomp(regex_t *, const char *, int);
extern size_t regerror(int, const regex_t *, char *, size_t);
extern int regexec(const regex_t *, const char *, size_t, regmatch_t, int);
extern void regfree(regex_t *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5875"
>13.4.33. rpc/auth.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum auth_stat {
    AUTH_OK, AUTH_BADCRED = 1, AUTH_REJECTEDCRED = 2, AUTH_BADVERF =
	3, AUTH_REJECTEDVERF = 4, AUTH_TOOWEAK = 5, AUTH_INVALIDRESP =
	6, AUTH_FAILED = 7
};

union des_block {
    struct {
	u_int32_t high;
	u_int32_t low;
    } key;
    char c[8];
};

struct opaque_auth {
    enum_t oa_flavor;
    caddr_t oa_base;
    u_int oa_length;
};

typedef struct AUTH {
    struct opaque_auth ah_cred;
    struct opaque_auth ah_verf;
    union des_block ah_key;
    struct auth_ops *ah_ops;
    caddr_t ah_private;
} AUTH;

struct auth_ops {
    void (*ah_nextverf) (struct AUTH *);
    int (*ah_marshal) (struct AUTH *, XDR *);
    int (*ah_validate) (struct AUTH *, struct opaque_auth *);
    int (*ah_refresh) (struct AUTH *);
    void (*ah_destroy) (struct AUTH *);
};
extern struct AUTH *authnone_create(void);
extern int key_decryptsession(char *, union des_block *);
extern bool_t xdr_opaque_auth(XDR *, struct opaque_auth *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5879"
>13.4.34. rpc/clnt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define clnt_control(cl,rq,in)	((*(cl)-&#62;cl_ops-&#62;cl_control)(cl,rq,in))
#define clnt_abort(rh)	((*(rh)-&#62;cl_ops-&#62;cl_abort)(rh))
#define clnt_destroy(rh)	((*(rh)-&#62;cl_ops-&#62;cl_destroy)(rh))
#define clnt_freeres(rh,xres,resp)	((*(rh)-&#62;cl_ops-&#62;cl_freeres)(rh,xres,resp))
#define clnt_geterr(rh,errp)	((*(rh)-&#62;cl_ops-&#62;cl_geterr)(rh, errp))
#define NULLPROC	((u_long)0)
#define CLSET_TIMEOUT	1
#define CLGET_XID	10
#define CLSET_XID	11
#define CLGET_VERS	12
#define CLSET_VERS	13
#define CLGET_PROG	14
#define CLSET_PROG	15
#define CLGET_TIMEOUT	2
#define CLGET_SERVER_ADDR	3
#define CLSET_RETRY_TIMEOUT	4
#define CLGET_RETRY_TIMEOUT	5
#define CLGET_FD	6
#define CLGET_SVC_ADDR	7
#define CLSET_FD_CLOSE	8
#define CLSET_FD_NCLOSE	9
#define clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)-&#62;cl_ops-&#62;cl_call)(rh, proc, xargs, argsp, xres, resp, secs))

enum clnt_stat {
    RPC_SUCCESS, RPC_CANTENCODEARGS = 1, RPC_CANTDECODERES =
	2, RPC_CANTSEND = 3, RPC_CANTRECV = 4, RPC_TIMEDOUT =
	5, RPC_VERSMISMATCH = 6, RPC_AUTHERROR = 7, RPC_PROGUNAVAIL =
	8, RPC_PROGVERSMISMATCH = 9, RPC_PROCUNAVAIL =
	10, RPC_CANTDECODEARGS = 11, RPC_SYSTEMERROR =
	12, RPC_NOBROADCAST = 21, RPC_UNKNOWNHOST = 13, RPC_UNKNOWNPROTO =
	17, RPC_UNKNOWNADDR = 19, RPC_RPCBFAILURE =
	14, RPC_PROGNOTREGISTERED = 15, RPC_N2AXLATEFAILURE =
	22, RPC_FAILED = 16, RPC_INTR = 18, RPC_TLIERROR =
	20, RPC_UDERROR = 23, RPC_INPROGRESS = 24, RPC_STALERACHANDLE = 25
};
struct rpc_err {
    enum clnt_stat re_status;
    union {
	int RE_errno;
	enum auth_stat RE_why;
	struct {
	    u_long low;
	    u_long high;
	} RE_vers;
	struct {
	    long int s1;
	    long int s2;
	} RE_lb;
    } ru;
};

typedef struct CLIENT {
    struct AUTH *cl_auth;
    struct clnt_ops *cl_ops;
    caddr_t cl_private;
} CLIENT;

struct clnt_ops {
    enum clnt_stat (*cl_call) (struct CLIENT *, u_long, xdrproc_t, caddr_t,
			       xdrproc_t, caddr_t, struct timeval);
    void (*cl_abort) (void);
    void (*cl_geterr) (struct CLIENT *, struct rpc_err *);
     bool_t(*cl_freeres) (struct CLIENT *, xdrproc_t, caddr_t);
    void (*cl_destroy) (struct CLIENT *);
     bool_t(*cl_control) (struct CLIENT *, int, char *);
};
extern struct CLIENT *clnt_create(const char *, const u_long, const u_long,
				  const char *);
extern void clnt_pcreateerror(const char *);
extern void clnt_perrno(enum clnt_stat);
extern void clnt_perror(struct CLIENT *, const char *);
extern char *clnt_spcreateerror(const char *);
extern char *clnt_sperrno(enum clnt_stat);
extern char *clnt_sperror(struct CLIENT *, const char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5883"
>13.4.35. rpc/pmap_clnt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern u_short pmap_getport(struct sockaddr_in *, const u_long,
			    const u_long, u_int);
extern bool_t pmap_set(const u_long, const u_long, int, u_short);
extern bool_t pmap_unset(u_long, u_long);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5887"
>13.4.36. rpc/rpc_msg.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum msg_type {
    CALL, REPLY = 1
};
enum reply_stat {
    MSG_ACCEPTED, MSG_DENIED = 1
};
enum accept_stat {
    SUCCESS, PROG_UNAVAIL = 1, PROG_MISMATCH = 2, PROC_UNAVAIL =
	3, GARBAGE_ARGS = 4, SYSTEM_ERR = 5
};
enum reject_stat {
    RPC_MISMATCH, AUTH_ERROR = 1
};

struct accepted_reply {
    struct opaque_auth ar_verf;
    enum accept_stat ar_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} AR_versions;
	struct {
	    caddr_t where;
	    xdrproc_t proc;
	} AR_results;
    } ru;
};

struct rejected_reply {
    enum reject_stat rj_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} RJ_versions;
	enum auth_stat RJ_why;
    } ru;
};

struct reply_body {
    enum reply_stat rp_stat;
    union {
	struct accepted_reply RP_ar;
	struct rejected_reply RP_dr;
    } ru;
};

struct call_body {
    unsigned long int cb_rpcvers;
    unsigned long int cb_prog;
    unsigned long int cb_vers;
    unsigned long int cb_proc;
    struct opaque_auth cb_cred;
    struct opaque_auth cb_verf;
};

struct rpc_msg {
    unsigned long int rm_xid;
    enum msg_type rm_direction;
    union {
	struct call_body RM_cmb;
	struct reply_body RM_rmb;
    } ru;
};
extern bool_t xdr_callhdr(XDR *, struct rpc_msg *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5891"
>13.4.37. rpc/svc.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RPC_ANYSOCK	-1
#define svc_freeargs(xprt,xargs, argsp)	\
	(*(xprt)-&#62;xp_ops-&#62;xp_freeargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt,xargs, argsp)	\
	(*(xprt)-&#62;xp_ops-&#62;xp_getargs)((xprt), (xargs), (argsp))

enum xprt_stat {
    XPRT_DIED, XPRT_MOREREQS, XPRT_IDLE
};

typedef struct SVCXPRT {
    int xp_sock;
    u_short xp_port;
    struct xp_ops *xp_ops;
    int xp_addrlen;
    struct sockaddr_in xp_raddr;
    struct opaque_auth xp_verf;
    caddr_t xp_p1;
    caddr_t xp_p2;
    char xp_pad[256];
} SVCXPRT;

struct svc_req {
    rpcprog_t rq_prog;
    rpcvers_t rq_vers;
    rpcproc_t rq_proc;
    struct opaque_auth rq_cred;
    caddr_t rq_clntcred;
    SVCXPRT *rq_xprt;
};

typedef void (*__dispatch_fn_t) (struct svc_req *, SVCXPRT *);

struct xp_ops {
    bool_t(*xp_recv) (SVCXPRT * __xprt, struct rpc_msg * __msg);
    enum xprt_stat (*xp_stat) (SVCXPRT * __xprt);
     bool_t(*xp_getargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			  caddr_t args_ptr);
     bool_t(*xp_reply) (SVCXPRT * __xprt, struct rpc_msg * __msg);
     bool_t(*xp_freeargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			   caddr_t args_ptr);
    void (*xp_destroy) (SVCXPRT * __xprt);
};
extern void svc_getreqset(fd_set *);
extern bool_t svc_register(SVCXPRT *, rpcprog_t, rpcvers_t,
			   __dispatch_fn_t, rpcprot_t);
extern void svc_run(void);
extern bool_t svc_sendreply(SVCXPRT *, xdrproc_t, caddr_t);
extern void svcerr_auth(SVCXPRT *, enum auth_stat);
extern void svcerr_decode(SVCXPRT *);
extern void svcerr_noproc(SVCXPRT *);
extern void svcerr_noprog(SVCXPRT *);
extern void svcerr_progvers(SVCXPRT *, rpcvers_t, rpcvers_t);
extern void svcerr_systemerr(SVCXPRT *);
extern void svcerr_weakauth(SVCXPRT *);
extern SVCXPRT *svctcp_create(int, u_int, u_int);
extern SVCXPRT *svcudp_create(int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5895"
>13.4.38. rpc/types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef int bool_t;
typedef int enum_t;
typedef unsigned long int rpcprog_t;
typedef unsigned long int rpcvers_t;
typedef unsigned long int rpcproc_t;
typedef unsigned long int rpcprot_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5899"
>13.4.39. rpc/xdr.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum xdr_op {
    XDR_ENCODE, XDR_DECODE, XDR_FREE
};
typedef struct XDR {
    enum xdr_op x_op;
    struct xdr_ops *x_ops;
    caddr_t x_public;
    caddr_t x_private;
    caddr_t x_base;
    int x_handy;
} XDR;

struct xdr_ops {
    bool_t(*x_getlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_putlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_getbytes) (XDR * __xdrs, caddr_t __addr, u_int __len);
    bool_t(*x_putbytes) (XDR * __xdrs, char *__addr, u_int __len);
    u_int(*x_getpostn) (XDR * __xdrs);
    bool_t(*x_setpostn) (XDR * __xdrs, u_int __pos);
    int32_t *(*x_inline) (XDR * __xdrs, int __len);
    void (*x_destroy) (XDR * __xdrs);
     bool_t(*x_getint32) (XDR * __xdrs, int32_t * __ip);
     bool_t(*x_putint32) (XDR * __xdrs, int32_t * __ip);
};

typedef bool_t(*xdrproc_t) (XDR *, void *, ...);

struct xdr_discrim {
    int value;
    xdrproc_t proc;
};
extern bool_t xdr_array(XDR *, caddr_t *, u_int *, u_int, u_int,
			xdrproc_t);
extern bool_t xdr_bool(XDR *, bool_t *);
extern bool_t xdr_bytes(XDR *, char **, u_int *, u_int);
extern bool_t xdr_char(XDR *, char *);
extern bool_t xdr_double(XDR *, double *);
extern bool_t xdr_enum(XDR *, enum_t *);
extern bool_t xdr_float(XDR *, float *);
extern void xdr_free(xdrproc_t, char *);
extern bool_t xdr_int(XDR *, int *);
extern bool_t xdr_long(XDR *, long int *);
extern bool_t xdr_opaque(XDR *, caddr_t, u_int);
extern bool_t xdr_pointer(XDR *, char **, u_int, xdrproc_t);
extern bool_t xdr_reference(XDR *, caddr_t *, u_int, xdrproc_t);
extern bool_t xdr_short(XDR *, short *);
extern bool_t xdr_string(XDR *, char **, u_int);
extern bool_t xdr_u_char(XDR *, u_char *);
extern bool_t xdr_u_int(XDR *, u_int *);
extern bool_t xdr_u_long(XDR *, u_long *);
extern bool_t xdr_u_short(XDR *, u_short *);
extern bool_t xdr_union(XDR *, enum_t *, char *,
			const struct xdr_discrim *, xdrproc_t);
extern bool_t xdr_vector(XDR *, char *, u_int, u_int, xdrproc_t);
extern bool_t xdr_void(void);
extern bool_t xdr_wrapstring(XDR *, char **);
extern void xdrmem_create(XDR *, caddr_t, u_int, enum xdr_op);
extern void xdrrec_create(XDR *, u_int, u_int, caddr_t,
			  int (*__readit) (char *p1, char *p2, int p3)
			  , int (*__writeit) (char *p1, char *p2, int p3)
    );
extern typedef int bool_t xdrrec_eof(XDR *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5903"
>13.4.40. sched.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SCHED_OTHER	0
#define SCHED_FIFO	1
#define SCHED_RR	2

struct sched_param {
    int sched_priority;
};
extern int sched_get_priority_max(int);
extern int sched_get_priority_min(int);
extern int sched_getparam(pid_t, struct sched_param *);
extern int sched_getscheduler(pid_t);
extern int sched_rr_get_interval(pid_t, struct timespec *);
extern int sched_setparam(pid_t, const struct sched_param *);
extern int sched_setscheduler(pid_t, int, const struct sched_param *);
extern int sched_yield(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5907"
>13.4.41. search.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct entry {
    char *key;
    void *data;
} ENTRY;
typedef enum {
    FIND, ENTER
} ACTION;
typedef enum {
    preorder, postorder, endorder, leaf
} VISIT;

typedef void (*__action_fn_t) (void *__nodep, VISIT __value, int __level);
extern int hcreate(size_t);
extern ENTRY *hsearch(ENTRY, ACTION);
extern void insque(void *, void *);
extern void *lfind(const void *, const void *, size_t *, size_t,
		   __compar_fn_t);
extern void *lsearch(const void *, void *, size_t *, size_t,
		     __compar_fn_t);
extern void remque(void *);
extern void hdestroy(void);
extern void *tdelete(const void *, void **, __compar_fn_t);
extern void *tfind(const void *, void *const *, __compar_fn_t);
extern void *tsearch(const void *, void **, __compar_fn_t);
extern void twalk(const void *, __action_fn_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5911"
>13.4.42. setjmp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define setjmp(env)	_setjmp(env)
#define sigsetjmp(a,b)	__sigsetjmp(a,b)

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    sigset_t __saved_mask;
};

typedef struct __jmp_buf_tag jmp_buf[1];
typedef jmp_buf sigjmp_buf;
extern int __sigsetjmp(jmp_buf, int);
extern void longjmp(jmp_buf, int);
extern void siglongjmp(sigjmp_buf, int);
extern void _longjmp(jmp_buf, int);
extern int _setjmp(jmp_buf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5915"
>13.4.43. signal.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SIGSET_NWORDS	(1024/(8*sizeof(unsigned long)))
#define SIGRTMAX	(__libc_current_sigrtmax ())
#define SIGRTMIN	(__libc_current_sigrtmin ())
#define SIG_BLOCK	0
#define SIG_UNBLOCK	1
#define SIG_SETMASK	2
#define NSIG	65

typedef int sig_atomic_t;

typedef void (*sighandler_t) (int);

#define SIG_HOLD	((sighandler_t) 2)
#define SIG_ERR	((sighandler_t)-1)
#define SIG_DFL	((sighandler_t)0)
#define SIG_IGN	((sighandler_t)1)

#define SIGHUP	1
#define SIGUSR1	10
#define SIGSEGV	11
#define SIGUSR2	12
#define SIGPIPE	13
#define SIGALRM	14
#define SIGTERM	15
#define SIGSTKFLT	16
#define SIGCHLD	17
#define SIGCONT	18
#define SIGSTOP	19
#define SIGINT	2
#define SIGTSTP	20
#define SIGTTIN	21
#define SIGTTOU	22
#define SIGURG	23
#define SIGXCPU	24
#define SIGXFSZ	25
#define SIGVTALRM	26
#define SIGPROF	27
#define SIGWINCH	28
#define SIGIO	29
#define SIGQUIT	3
#define SIGPWR	30
#define SIGSYS	31
#define SIGUNUSED	31
#define SIGILL	4
#define SIGTRAP	5
#define SIGABRT	6
#define SIGIOT	6
#define SIGBUS	7
#define SIGFPE	8
#define SIGKILL	9
#define SIGCLD	SIGCHLD
#define SIGPOLL	SIGIO

#define SV_ONSTACK	(1&#60;&#60;0)
#define SV_INTERRUPT	(1&#60;&#60;1)
#define SV_RESETHAND	(1&#60;&#60;2)

typedef union sigval {
    int sival_int;
    void *sival_ptr;
} sigval_t;

#define SIGEV_SIGNAL	0
#define SIGEV_NONE	1
#define SIGEV_THREAD	2
#define SIGEV_MAX_SIZE	64

typedef struct sigevent {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;
    union {
	int _pad[SIGEV_PAD_SIZE];
	struct {
	    void (*sigev_thread_func) (sigval_t);
	    void *_attribute;
	} _sigev_thread;
    } _sigev_un;
} sigevent_t;

#define SI_MAX_SIZE	128
#define si_pid	_sifields._kill._pid
#define si_uid	_sifields._kill._uid
#define si_value	_sifields._rt._sigval
#define si_int	_sifields._rt._sigval.sival_int
#define si_ptr	_sifields._rt._sigval.sival_ptr
#define si_status	_sifields._sigchld._status
#define si_stime	_sifields._sigchld._stime
#define si_utime	_sifields._sigchld._utime
#define si_addr	_sifields._sigfault._addr
#define si_band	_sifields._sigpoll._band
#define si_fd	_sifields._sigpoll._fd
#define si_timer1	_sifields._timer._timer1
#define si_timer2	_sifields._timer._timer2

typedef struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union {
	int _pad[SI_PAD_SIZE];
	struct {
	    pid_t _pid;
	    uid_t _uid;
	} _kill;
	struct {
	    unsigned int _timer1;
	    unsigned int _timer2;
	} _timer;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    sigval_t _sigval;
	} _rt;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    int _status;
	    clock_t _utime;
	    clock_t _stime;
	} _sigchld;
	struct {
	    void *_addr;
	} _sigfault;
	struct {
	    int _band;
	    int _fd;
	} _sigpoll;
    } _sifields;
} siginfo_t;

#define SI_QUEUE	-1
#define SI_TIMER	-2
#define SI_MESGQ	-3
#define SI_ASYNCIO	-4
#define SI_SIGIO	-5
#define SI_TKILL	-6
#define SI_ASYNCNL	-60
#define SI_USER	0
#define SI_KERNEL	0x80

#define ILL_ILLOPC	1
#define ILL_ILLOPN	2
#define ILL_ILLADR	3
#define ILL_ILLTRP	4
#define ILL_PRVOPC	5
#define ILL_PRVREG	6
#define ILL_COPROC	7
#define ILL_BADSTK	8

#define FPE_INTDIV	1
#define FPE_INTOVF	2
#define FPE_FLTDIV	3
#define FPE_FLTOVF	4
#define FPE_FLTUND	5
#define FPE_FLTRES	6
#define FPE_FLTINV	7
#define FPE_FLTSUB	8

#define SEGV_MAPERR	1
#define SEGV_ACCERR	2

#define BUS_ADRALN	1
#define BUS_ADRERR	2
#define BUS_OBJERR	3

#define TRAP_BRKPT	1
#define TRAP_TRACE	2

#define CLD_EXITED	1
#define CLD_KILLED	2
#define CLD_DUMPED	3
#define CLD_TRAPPED	4
#define CLD_STOPPED	5
#define CLD_CONTINUED	6

#define POLL_IN	1
#define POLL_OUT	2
#define POLL_MSG	3
#define POLL_ERR	4
#define POLL_PRI	5
#define POLL_HUP	6

typedef struct {
    unsigned long int sig[_SIGSET_NWORDS];
} sigset_t;

#define SA_NOCLDSTOP	0x00000001
#define SA_NOCLDWAIT	0x00000002
#define SA_SIGINFO	0x00000004
#define SA_ONSTACK	0x08000000
#define SA_RESTART	0x10000000
#define SA_INTERRUPT	0x20000000
#define SA_NODEFER	0x40000000
#define SA_RESETHAND	0x80000000
#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND

typedef struct sigaltstack {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
} stack_t;

#define SS_ONSTACK	1
#define SS_DISABLE	2

extern int __libc_current_sigrtmax(void);
extern int __libc_current_sigrtmin(void);
extern sighandler_t __sysv_signal(int, sighandler_t);
extern char *const _sys_siglist(void);
extern int killpg(pid_t, int);
extern void psignal(int, const char *);
extern int raise(int);
extern int sigaddset(sigset_t *, int);
extern int sigandset(sigset_t *, const sigset_t *, const sigset_t *);
extern int sigdelset(sigset_t *, int);
extern int sigemptyset(sigset_t *);
extern int sigfillset(sigset_t *);
extern int sighold(int);
extern int sigignore(int);
extern int siginterrupt(int, int);
extern int sigisemptyset(const sigset_t *);
extern int sigismember(const sigset_t *, int);
extern int sigorset(sigset_t *, const sigset_t *, const sigset_t *);
extern int sigpending(sigset_t *);
extern int sigrelse(int);
extern sighandler_t sigset(int, sighandler_t);
extern int pthread_kill(pthread_t, int);
extern int pthread_sigmask(int, sigset_t *, sigset_t *);
extern int sigaction(int, const struct sigaction *, struct sigaction *);
extern int sigwait(sigset_t *, int *);
extern int kill(pid_t, int);
extern int sigaltstack(const struct sigaltstack *, struct sigaltstack *);
extern sighandler_t signal(int, sighandler_t);
extern int sigpause(int);
extern int sigprocmask(int, const sigset_t *, sigset_t *);
extern int sigreturn(struct sigcontext *);
extern int sigsuspend(const sigset_t *);
extern int sigqueue(pid_t, int, const union sigval);
extern int sigwaitinfo(const sigset_t *, siginfo_t *);
extern int sigtimedwait(const sigset_t *, siginfo_t *,
			const struct timespec *);
extern sighandler_t bsd_signal(int, sighandler_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5919"
>13.4.44. stddef.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define offsetof(TYPE,MEMBER)	((size_t)&#38;((TYPE*)0)-&#62;MEMBER)
#define NULL	(0L)

typedef int wchar_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5923"
>13.4.45. stdio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EOF	(-1)
#define P_tmpdir	"/tmp"
#define FOPEN_MAX	16
#define L_tmpnam	20
#define FILENAME_MAX	4096
#define BUFSIZ	8192
#define L_ctermid	9
#define L_cuserid	9

typedef struct {
    off_t __pos;
    mbstate_t __state;
} fpos_t;
typedef struct {
    off64_t __pos;
    mbstate_t __state;
} fpos64_t;

typedef struct _IO_FILE FILE;

#define _IOFBF	0
#define _IOLBF	1
#define _IONBF	2

extern char *const _sys_errlist(void);
extern void clearerr(FILE *);
extern int fclose(FILE *);
extern FILE *fdopen(int, const char *);
extern int fflush_unlocked(FILE *);
extern int fileno(FILE *);
extern FILE *fopen(const char *, const char *);
extern int fprintf(FILE *, const char *, ...);
extern int fputc(int, FILE *);
extern FILE *freopen(const char *, const char *, FILE *);
extern FILE *freopen64(const char *, const char *, FILE *);
extern int fscanf(FILE *, const char *, ...);
extern int fseek(FILE *, long int, int);
extern int fseeko(FILE *, off_t, int);
extern int fseeko64(FILE *, loff_t, int);
extern off_t ftello(FILE *);
extern loff_t ftello64(FILE *);
extern int getchar(void);
extern int getchar_unlocked(void);
extern int getw(FILE *);
extern int pclose(FILE *);
extern void perror(const char *);
extern FILE *popen(const char *, const char *);
extern int printf(const char *, ...);
extern int putc_unlocked(int, FILE *);
extern int putchar(int);
extern int putchar_unlocked(int);
extern int putw(int, FILE *);
extern int remove(const char *);
extern void rewind(FILE *);
extern int scanf(const char *, ...);
extern void setbuf(FILE *, char *);
extern int sprintf(char *, const char *, ...);
extern int sscanf(const char *, const char *, ...);
extern FILE *stderr(void);
extern FILE *stdin(void);
extern FILE *stdout(void);
extern char *tempnam(const char *, const char *);
extern FILE *tmpfile64(void);
extern FILE *tmpfile(void);
extern char *tmpnam(char *);
extern int vfprintf(FILE *, const char *, va_list);
extern int vprintf(const char *, va_list);
extern int feof(FILE *);
extern int ferror(FILE *);
extern int fflush(FILE *);
extern int fgetc(FILE *);
extern int fgetpos(FILE *, fpos_t *);
extern char *fgets(char *, int, FILE *);
extern int fputs(const char *, FILE *);
extern size_t fread(void *, size_t, size_t, FILE *);
extern int fsetpos(FILE *, const fpos_t *);
extern long int ftell(FILE *);
extern size_t fwrite(const void *, size_t, size_t, FILE *);
extern int getc(FILE *);
extern int putc(int, FILE *);
extern int puts(const char *);
extern int setvbuf(FILE *, char *, int, size_t);
extern int snprintf(char *, size_t, const char *, ...);
extern int ungetc(int, FILE *);
extern int vsnprintf(char *, size_t, const char *, va_list);
extern int vsprintf(char *, const char *, va_list);
extern void flockfile(FILE *);
extern int asprintf(char **, const char *, ...);
extern int fgetpos64(FILE *, fpos64_t *);
extern FILE *fopen64(const char *, const char *);
extern int fsetpos64(FILE *, const fpos64_t *);
extern int ftrylockfile(FILE *);
extern void funlockfile(FILE *);
extern int getc_unlocked(FILE *);
extern void setbuffer(FILE *, char *, size_t);
extern int vasprintf(char **, const char *, va_list);
extern int vdprintf(int, const char *, va_list);
extern int vfscanf(FILE *, const char *, va_list);
extern int vscanf(const char *, va_list);
extern int vsscanf(const char *, const char *, va_list);
extern size_t __fpending(FILE *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5927"
>13.4.46. stdlib.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MB_CUR_MAX	(__ctype_get_mb_cur_max())
#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
#define RAND_MAX	2147483647

typedef int (*__compar_fn_t) (const void *, const void *);
struct random_data {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
};

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;
extern double __strtod_internal(const char *, char **, int);
extern float __strtof_internal(const char *, char **, int);
extern long int __strtol_internal(const char *, char **, int, int);
extern long double __strtold_internal(const char *, char **, int);
extern long long int __strtoll_internal(const char *, char **, int, int);
extern unsigned long int __strtoul_internal(const char *, char **, int,
					    int);
extern unsigned long long int __strtoull_internal(const char *, char **,
						  int, int);
extern long int a64l(const char *);
extern void abort(void);
extern int abs(int);
extern double atof(const char *);
extern int atoi(char *);
extern long int atol(char *);
extern long long int atoll(const char *);
extern void *bsearch(const void *, const void *, size_t, size_t,
		     __compar_fn_t);
extern div_t div(int, int);
extern double drand48(void);
extern char *ecvt(double, int, int *, int *);
extern double erand48(unsigned short);
extern void exit(int);
extern char *fcvt(double, int, int *, int *);
extern char *gcvt(double, int, char *);
extern char *getenv(const char *);
extern int getsubopt(char **, char *const *, char **);
extern int grantpt(int);
extern long int jrand48(unsigned short);
extern char *l64a(long int);
extern long int labs(long int);
extern void lcong48(unsigned short);
extern ldiv_t ldiv(long int, long int);
extern long long int llabs(long long int);
extern lldiv_t lldiv(long long int, long long int);
extern long int lrand48(void);
extern int mblen(const char *, size_t);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern int mbtowc(wchar_t *, const char *, size_t);
extern char *mktemp(char *);
extern long int mrand48(void);
extern long int nrand48(unsigned short);
extern char *ptsname(int);
extern int putenv(char *);
extern void qsort(void *, size_t, size_t, __compar_fn_t);
extern int rand(void);
extern int rand_r(unsigned int *);
extern unsigned short *seed48(unsigned short);
extern void srand48(long int);
extern int unlockpt(int);
extern size_t wcstombs(char *, const wchar_t *, size_t);
extern int wctomb(char *, wchar_t);
extern int system(const char *);
extern void *calloc(size_t, size_t);
extern void free(void *);
extern char *initstate(unsigned int, char *, size_t);
extern void *malloc(size_t);
extern long int random(void);
extern void *realloc(void *, size_t);
extern char *setstate(char *);
extern void srand(unsigned int);
extern void srandom(unsigned int);
extern double strtod(char *, char **);
extern float strtof(const char *, char **);
extern long int strtol(char *, char **, int);
extern long double strtold(const char *, char **);
extern long long int strtoll(const char *, char **, int);
extern long long int strtoq(const char *, char **, int);
extern unsigned long int strtoul(const char *, char **, int);
extern unsigned long long int strtoull(const char *, char **, int);
extern unsigned long long int strtouq(const char *, char **, int);
extern void _Exit(int);
extern size_t __ctype_get_mb_cur_max(void);
extern char **environ(void);
extern char *realpath(const char *, char *);
extern int setenv(const char *, const char *, int);
extern int unsetenv(const char *);
extern int getloadavg(double, int);
extern int mkstemp64(char *);
extern int posix_memalign(void **, size_t, size_t);
extern int posix_openpt(int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5931"
>13.4.47. string.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void *__mempcpy(void *, const void *, size_t);
extern char *__stpcpy(char *, const char *);
extern char *__strtok_r(char *, const char *, char **);
extern void bcopy(void *, void *, size_t);
extern void *memchr(void *, int, size_t);
extern int memcmp(void *, void *, size_t);
extern void *memcpy(void *, void *, size_t);
extern void *memmem(const void *, size_t, const void *, size_t);
extern void *memmove(void *, const void *, size_t);
extern void *memset(void *, int, size_t);
extern char *strcat(char *, const char *);
extern char *strchr(char *, int);
extern int strcmp(char *, char *);
extern int strcoll(const char *, const char *);
extern char *strcpy(char *, char *);
extern size_t strcspn(const char *, const char *);
extern char *strerror(int);
extern size_t strlen(char *);
extern char *strncat(char *, char *, size_t);
extern int strncmp(char *, char *, size_t);
extern char *strncpy(char *, char *, size_t);
extern char *strpbrk(const char *, const char *);
extern char *strrchr(char *, int);
extern char *strsignal(int);
extern size_t strspn(const char *, const char *);
extern char *strstr(char *, char *);
extern char *strtok(char *, const char *);
extern size_t strxfrm(char *, const char *, size_t);
extern int bcmp(void *, void *, size_t);
extern void bzero(void *, size_t);
extern int ffs(int);
extern char *index(char *, int);
extern void *memccpy(void *, const void *, int, size_t);
extern char *rindex(char *, int);
extern int strcasecmp(char *, char *);
extern char *strdup(char *);
extern int strncasecmp(char *, char *, size_t);
extern char *strndup(const char *, size_t);
extern size_t strnlen(const char *, size_t);
extern char *strsep(char **, const char *);
extern char *strerror_r(int, char *, size_t);
extern char *strtok_r(char *, const char *, char **);
extern char *strcasestr(const char *, const char *);
extern char *stpcpy(char *, const char *);
extern char *stpncpy(char *, const char *, size_t);
extern void *memrchr(const void *, int, size_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5935"
>13.4.48. sys/file.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LOCK_SH	1
#define LOCK_EX	2
#define LOCK_NB	4
#define LOCK_UN	8

extern int flock(int, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5939"
>13.4.49. sys/ioctl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct winsize {
    unsigned short ws_row;
    unsigned short ws_col;
    unsigned short ws_xpixel;
    unsigned short ws_ypixel;
};
extern int ioctl(int, unsigned long int, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5943"
>13.4.50. sys/ipc.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPC_PRIVATE	((key_t)0)
#define IPC_RMID	0
#define IPC_CREAT	00001000
#define IPC_EXCL	00002000
#define IPC_NOWAIT	00004000
#define IPC_SET	1
#define IPC_STAT	2

extern key_t ftok(char *, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5947"
>13.4.51. sys/mman.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MAP_FAILED	((void*)-1)
#define PROT_NONE	0x0
#define MAP_SHARED	0x01
#define MAP_PRIVATE	0x02
#define PROT_READ	0x1
#define MAP_FIXED	0x10
#define PROT_WRITE	0x2
#define MAP_ANONYMOUS	0x20
#define PROT_EXEC	0x4
#define MS_ASYNC	1
#define MS_INVALIDATE	2
#define MS_SYNC	4
#define MAP_ANON	MAP_ANONYMOUS

extern int msync(void *, size_t, int);
extern int mlock(const void *, size_t);
extern int mlockall(int);
extern void *mmap(void *, size_t, int, int, int, off_t);
extern int mprotect(void *, size_t, int);
extern int munlock(const void *, size_t);
extern int munlockall(void);
extern int munmap(void *, size_t);
extern void *mmap64(void *, size_t, int, int, int, off64_t);
extern int shm_open(const char *, int, mode_t);
extern int shm_unlink(const char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5951"
>13.4.52. sys/msg.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MSG_NOERROR	010000

extern int msgctl(int, int, struct msqid_ds *);
extern int msgget(key_t, int);
extern int msgrcv(int, void *, size_t, long int, int);
extern int msgsnd(int, const void *, size_t, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5955"
>13.4.53. sys/param.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NOFILE	256
#define MAXPATHLEN	4096</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5959"
>13.4.54. sys/poll.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define POLLIN	0x0001
#define POLLPRI	0x0002
#define POLLOUT	0x0004
#define POLLERR	0x0008
#define POLLHUP	0x0010
#define POLLNVAL	0x0020

struct pollfd {
    int fd;
    short events;
    short revents;
};
typedef unsigned long int nfds_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5963"
>13.4.55. sys/resource.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RUSAGE_CHILDREN	(-1)
#define RUSAGE_BOTH	(-2)
#define RLIM_INFINITY	(~0UL)
#define RLIM_SAVED_CUR	-1
#define RLIM_SAVED_MAX	-1
#define RLIMIT_CPU	0
#define RUSAGE_SELF	0
#define RLIMIT_FSIZE	1
#define RLIMIT_DATA	2
#define RLIMIT_STACK	3
#define RLIMIT_CORE	4
#define RLIMIT_NOFILE	7
#define RLIMIT_AS	9

typedef unsigned long int rlim_t;
typedef unsigned long long int rlim64_t;
typedef int __rlimit_resource_t;

struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
struct rlimit64 {
    rlim64_t rlim_cur;
    rlim64_t rlim_max;
};

struct rusage {
    struct timeval ru_utime;
    struct timeval ru_stime;
    long int ru_maxrss;
    long int ru_ixrss;
    long int ru_idrss;
    long int ru_isrss;
    long int ru_minflt;
    long int ru_majflt;
    long int ru_nswap;
    long int ru_inblock;
    long int ru_oublock;
    long int ru_msgsnd;
    long int ru_msgrcv;
    long int ru_nsignals;
    long int ru_nvcsw;
    long int ru_nivcsw;
};

enum __priority_which {
    PRIO_PROCESS, PRIO_PGRP = 1, PRIO_USER = 2
};

#define PRIO_PGRP	PRIO_PGRP
#define PRIO_PROCESS	PRIO_PROCESS
#define PRIO_USER	PRIO_USER

typedef enum __priority_which __priority_which_t;
extern int getpriority(__priority_which_t, id_t);
extern int getrlimit64(id_t, struct rlimit64 *);
extern int setpriority(__priority_which_t, id_t, int);
extern int setrlimit(__rlimit_resource_t, const struct rlimit *);
extern int setrlimit64(__rlimit_resource_t, const struct rlimit64 *);
extern int getrlimit(__rlimit_resource_t, struct rlimit *);
extern int getrusage(int, struct rusage *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5967"
>13.4.56. sys/sem.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SEM_UNDO	0x1000
#define GETPID	11
#define GETVAL	12
#define GETALL	13
#define GETNCNT	14
#define GETZCNT	15
#define SETVAL	16
#define SETALL	17

struct sembuf {
    short sem_num;
    short sem_op;
    short sem_flg;
};
extern int semctl(int, int, int, ...);
extern int semget(key_t, int, int);
extern int semop(int, struct sembuf *, size_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5971"
>13.4.57. sys/shm.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SHM_RDONLY	010000
#define SHM_W	0200
#define SHM_RND	020000
#define SHM_R	0400
#define SHM_REMAP	040000
#define SHM_LOCK	11
#define SHM_UNLOCK	12

extern int __getpagesize(void);
extern void *shmat(int, const void *, int);
extern int shmctl(int, int, struct shmid_ds *);
extern int shmdt(const void *);
extern int shmget(key_t, size_t, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5975"
>13.4.58. sys/socket.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CMSG_LEN(len)	(CMSG_ALIGN(sizeof(struct cmsghdr))+(len))
#define SCM_RIGHTS	0x01
#define SOL_SOCKET	1
#define SOMAXCONN	128
#define SOL_RAW	255
#define CMSG_ALIGN(len)	\
	(((len)+sizeof(size_t)-1)&#38;(size_t)~(sizeof(size_t)-1))
#define CMSG_DATA(cmsg)	\
	((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr)))
#define CMSG_SPACE(len)	\
	(CMSG_ALIGN(sizeof(struct cmsghdr))+CMSG_ALIGN(len))
#define CMSG_FIRSTHDR(msg)	\
           ((msg)-&#62;msg_controllen &#62;= sizeof(struct cmsghdr) ? \
            (struct cmsghdr *)(msg)-&#62;msg_control : \
            (struct cmsghdr *)NULL)
#define CMSG_NXTHDR(mhdr,cmsg)	\
        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \
         (((u_char *)(cmsg) + CMSG_ALIGN((cmsg)-&#62;cmsg_len) \
                            + CMSG_ALIGN(sizeof(struct cmsghdr)) &#62; \
           (u_char *)((mhdr)-&#62;msg_control) + (mhdr)-&#62;msg_controllen) ? \
          (struct cmsghdr *)NULL : \
          (struct cmsghdr *)((u_char *)(cmsg) + CMSG_ALIGN((cmsg)-&#62;cmsg_len))))

struct linger {
    int l_onoff;
    int l_linger;
};
struct cmsghdr {
    size_t cmsg_len;
    int cmsg_level;
    int cmsg_type;
};
struct iovec {
    void *iov_base;
    size_t iov_len;
};

typedef unsigned short sa_family_t;
typedef unsigned int socklen_t;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};
struct sockaddr_storage {
    sa_family_t ss_family;
    __ss_aligntype __ss_align;
    char __ss_padding[(128 - (2 * sizeof(__ss_aligntype)))];
};

struct msghdr {
    void *msg_name;
    int msg_namelen;
    struct iovec *msg_iov;
    size_t msg_iovlen;
    void *msg_control;
    size_t msg_controllen;
    unsigned int msg_flags;
};

#define AF_UNSPEC	0
#define AF_UNIX	1
#define AF_INET6	10
#define AF_INET	2

#define PF_INET	AF_INET
#define PF_INET6	AF_INET6
#define PF_UNIX	AF_UNIX
#define PF_UNSPEC	AF_UNSPEC

#define SOCK_STREAM	1
#define SOCK_PACKET	10
#define SOCK_DGRAM	2
#define SOCK_RAW	3
#define SOCK_RDM	4
#define SOCK_SEQPACKET	5

#define SO_DEBUG	1
#define SO_OOBINLINE	10
#define SO_NO_CHECK	11
#define SO_PRIORITY	12
#define SO_LINGER	13
#define SO_REUSEADDR	2
#define SO_TYPE	3
#define SO_ACCEPTCONN	30
#define SO_ERROR	4
#define SO_DONTROUTE	5
#define SO_BROADCAST	6
#define SO_SNDBUF	7
#define SO_RCVBUF	8
#define SO_KEEPALIVE	9

#define SIOCGIFCONF	0x8912
#define SIOCGIFFLAGS	0x8913
#define SIOCGIFADDR	0x8915
#define SIOCGIFNETMASK	0x891b

#define SHUT_RD	0
#define SHUT_WR	1
#define SHUT_RDWR	2
#define MSG_DONTROUTE	4

#define MSG_WAITALL	0x100
#define MSG_TRUNC	0x20
#define MSG_EOR	0x80
#define MSG_OOB	1
#define MSG_PEEK	2
#define MSG_CTRUNC	8

extern int bind(int, const struct sockaddr *, socklen_t);
extern int getnameinfo(const struct sockaddr *, socklen_t, char *,
		       socklen_t, char *, socklen_t, unsigned int);
extern int getsockname(int, struct sockaddr *, socklen_t *);
extern int listen(int, int);
extern int setsockopt(int, int, int, const void *, socklen_t);
extern int accept(int, struct sockaddr *, socklen_t *);
extern int connect(int, const struct sockaddr *, socklen_t);
extern ssize_t recv(int, void *, size_t, int);
extern ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *,
			socklen_t *);
extern ssize_t recvmsg(int, struct msghdr *, int);
extern ssize_t send(int, const void *, size_t, int);
extern ssize_t sendmsg(int, const struct msghdr *, int);
extern ssize_t sendto(int, const void *, size_t, int,
		      const struct sockaddr *, socklen_t);
extern int getpeername(int, struct sockaddr *, socklen_t *);
extern int getsockopt(int, int, int, void *, socklen_t *);
extern int shutdown(int, int);
extern int socket(int, int, int);
extern int socketpair(int, int, int, int);
extern int sockatmark(int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5979"
>13.4.59. sys/stat.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define S_ISBLK(m)	(((m)&#38;S_IFMT)==S_IFBLK)
#define S_ISCHR(m)	(((m)&#38;S_IFMT)==S_IFCHR)
#define S_ISDIR(m)	(((m)&#38;S_IFMT)==S_IFDIR)
#define S_ISFIFO(m)	(((m)&#38;S_IFMT)==S_IFIFO)
#define S_ISLNK(m)	(((m)&#38;S_IFMT)==S_IFLNK)
#define S_ISREG(m)	(((m)&#38;S_IFMT)==S_IFREG)
#define S_ISSOCK(m)	(((m)&#38;S_IFMT)==S_IFSOCK)
#define S_TYPEISMQ(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_TYPEISSEM(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_TYPEISSHM(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_IRWXU	(S_IREAD|S_IWRITE|S_IEXEC)
#define S_IROTH	(S_IRGRP&#62;&#62;3)
#define S_IRGRP	(S_IRUSR&#62;&#62;3)
#define S_IRWXO	(S_IRWXG&#62;&#62;3)
#define S_IRWXG	(S_IRWXU&#62;&#62;3)
#define S_IWOTH	(S_IWGRP&#62;&#62;3)
#define S_IWGRP	(S_IWUSR&#62;&#62;3)
#define S_IXOTH	(S_IXGRP&#62;&#62;3)
#define S_IXGRP	(S_IXUSR&#62;&#62;3)
#define S_ISVTX	01000
#define S_IXUSR	0x0040
#define S_IWUSR	0x0080
#define S_IRUSR	0x0100
#define S_ISGID	0x0400
#define S_ISUID	0x0800
#define S_IFIFO	0x1000
#define S_IFCHR	0x2000
#define S_IFDIR	0x4000
#define S_IFBLK	0x6000
#define S_IFREG	0x8000
#define S_IFLNK	0xa000
#define S_IFSOCK	0xc000
#define S_IFMT	0xf000
#define st_atime	st_atim.tv_sec
#define st_ctime	st_ctim.tv_sec
#define st_mtime	st_mtim.tv_sec
#define S_IREAD	S_IRUSR
#define S_IWRITE	S_IWUSR
#define S_IEXEC	S_IXUSR

extern int __fxstat(int, int, struct stat *);
extern int __fxstat64(int, int, struct stat64 *);
extern int __lxstat(int, char *, struct stat *);
extern int __lxstat64(int, const char *, struct stat64 *);
extern int __xmknod(int, const char *, mode_t, dev_t *);
extern int __xstat(int, const char *, struct stat *);
extern int __xstat64(int, const char *, struct stat64 *);
extern int mkfifo(const char *, mode_t);
extern int chmod(const char *, mode_t);
extern int fchmod(int, mode_t);
extern mode_t umask(mode_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5983"
>13.4.60. sys/statvfs.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int fstatvfs(int, struct statvfs *);
extern int fstatvfs64(int, struct statvfs64 *);
extern int statvfs(const char *, struct statvfs *);
extern int statvfs64(const char *, struct statvfs64 *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5987"
>13.4.61. sys/time.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ITIMER_REAL	0
#define ITIMER_VIRTUAL	1
#define ITIMER_PROF	2

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef int __itimer_which_t;

struct timespec {
    time_t tv_sec;
    long int tv_nsec;
};

struct timeval {
    time_t tv_sec;
    suseconds_t tv_usec;
};

struct itimerval {
    struct timeval it_interval;
    struct timeval it_value;
};
extern int getitimer(__itimer_which_t, struct itimerval *);
extern int setitimer(__itimer_which_t, const struct itimerval *,
		     struct itimerval *);
extern int adjtime(const struct timeval *, struct timeval *);
extern int gettimeofday(struct timeval *, struct timezone *);
extern int utimes(const char *, const struct timeval *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5991"
>13.4.62. sys/timeb.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
};
extern int ftime(struct timeb *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5995"
>13.4.63. sys/times.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct tms {
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
};
extern clock_t times(struct tms *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5999"
>13.4.64. sys/types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FALSE	0
#define TRUE	1
#define FD_SETSIZE	1024
#define FD_ZERO(fdsetp)	bzero(fdsetp, sizeof(*(fdsetp)))
#define FD_ISSET(d,set)	\
	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]&#38;(1&#60;&#60;((d)%(8*sizeof(long)))))
#define FD_CLR(d,set)	\
	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]&#38;=~(1&#60;&#60;((d)%(8*sizeof(long)))))
#define FD_SET(d,set)	\
	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]|=(1&#60;&#60;((d)%(8*sizeof(long)))))

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned int uid_t;
typedef int pid_t;
typedef long int off_t;
typedef int key_t;
typedef long int suseconds_t;
typedef unsigned int u_int;
typedef struct {
    int __val[2];
} fsid_t;
typedef unsigned int useconds_t;
typedef unsigned long int blksize_t;
typedef long int fd_mask;
typedef int timer_t;
typedef int clockid_t;

typedef unsigned int id_t;

typedef unsigned long long int ino64_t;
typedef long long int loff_t;
typedef unsigned long int blkcnt_t;
typedef unsigned long int fsblkcnt_t;
typedef unsigned long int fsfilcnt_t;
typedef unsigned long long int blkcnt64_t;
typedef unsigned long long int fsblkcnt64_t;
typedef unsigned long long int fsfilcnt64_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned long int u_long;

typedef unsigned long int ino_t;
typedef unsigned int gid_t;
typedef unsigned long long int dev_t;
typedef unsigned int mode_t;
typedef unsigned long int nlink_t;
typedef char *caddr_t;

typedef struct {
    unsigned long int fds_bits[__FDSET_LONGS];
} fd_set;

typedef long int clock_t;
typedef long int time_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6003"
>13.4.65. sys/uio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t readv(int, const struct iovec *, int);
extern ssize_t writev(int, const struct iovec *, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6007"
>13.4.66. sys/un.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UNIX_PATH_MAX	108

struct sockaddr_un {
    sa_family_t sun_family;
    char sun_path[UNIX_PATH_MAX];
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6011"
>13.4.67. sys/utsname.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SYS_NMLN	65

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};
extern int uname(struct utsname *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6015"
>13.4.68. sys/wait.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define WIFSIGNALED(status)	(!WIFSTOPPED(status) &#38;&#38; !WIFEXITED(status))
#define WIFSTOPPED(status)	(((status) &#38; 0xff) == 0x7f)
#define WEXITSTATUS(status)	(((status) &#38; 0xff00) &#62;&#62; 8)
#define WTERMSIG(status)	((status) &#38; 0x7f)
#define WCOREDUMP(status)	((status) &#38; 0x80)
#define WIFEXITED(status)	(WTERMSIG(status) == 0)
#define WNOHANG	0x00000001
#define WUNTRACED	0x00000002
#define WCOREFLAG	0x80
#define WSTOPSIG(status)	WEXITSTATUS(status)

typedef enum {
    P_ALL, P_PID, P_PGID
} idtype_t;
extern pid_t wait(int *);
extern pid_t waitpid(pid_t, int *, int);
extern pid_t wait4(pid_t, int *, int, struct rusage *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6019"
>13.4.69. syslog.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LOG_EMERG	0
#define LOG_PRIMASK	0x07
#define LOG_ALERT	1
#define LOG_CRIT	2
#define LOG_ERR	3
#define LOG_WARNING	4
#define LOG_NOTICE	5
#define LOG_INFO	6
#define LOG_DEBUG	7

#define LOG_KERN	(0&#60;&#60;3)
#define LOG_AUTHPRIV	(10&#60;&#60;3)
#define LOG_FTP	(11&#60;&#60;3)
#define LOG_USER	(1&#60;&#60;3)
#define LOG_MAIL	(2&#60;&#60;3)
#define LOG_DAEMON	(3&#60;&#60;3)
#define LOG_AUTH	(4&#60;&#60;3)
#define LOG_SYSLOG	(5&#60;&#60;3)
#define LOG_LPR	(6&#60;&#60;3)
#define LOG_NEWS	(7&#60;&#60;3)
#define LOG_UUCP	(8&#60;&#60;3)
#define LOG_CRON	(9&#60;&#60;3)
#define LOG_FACMASK	0x03f8

#define LOG_LOCAL0	(16&#60;&#60;3)
#define LOG_LOCAL1	(17&#60;&#60;3)
#define LOG_LOCAL2	(18&#60;&#60;3)
#define LOG_LOCAL3	(19&#60;&#60;3)
#define LOG_LOCAL4	(20&#60;&#60;3)
#define LOG_LOCAL5	(21&#60;&#60;3)
#define LOG_LOCAL6	(22&#60;&#60;3)
#define LOG_LOCAL7	(23&#60;&#60;3)

#define LOG_UPTO(pri)	((1 &#60;&#60; ((pri)+1)) - 1)
#define LOG_MASK(pri)	(1 &#60;&#60; (pri))

#define LOG_PID	0x01
#define LOG_CONS	0x02
#define LOG_ODELAY	0x04
#define LOG_NDELAY	0x08
#define LOG_NOWAIT	0x10
#define LOG_PERROR	0x20

extern void closelog(void);
extern void openlog(const char *, int, int);
extern int setlogmask(int);
extern void syslog(int, const char *, ...);
extern void vsyslog(int, const char *, va_list);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6023"
>13.4.70. termios.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define TCIFLUSH	0
#define TCOOFF	0
#define TCSANOW	0
#define BS0	0000000
#define CR0	0000000
#define FF0	0000000
#define NL0	0000000
#define TAB0	0000000
#define VT0	0000000
#define OPOST	0000001
#define OCRNL	0000010
#define ONOCR	0000020
#define ONLRET	0000040
#define OFILL	0000100
#define OFDEL	0000200
#define NL1	0000400
#define TCOFLUSH	1
#define TCOON	1
#define TCSADRAIN	1
#define TCIOFF	2
#define TCIOFLUSH	2
#define TCSAFLUSH	2
#define TCION	3

typedef unsigned int speed_t;
typedef unsigned char cc_t;
typedef unsigned int tcflag_t;

#define NCCS	32

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[NCCS];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

#define VINTR	0
#define VQUIT	1
#define VLNEXT	15
#define VERASE	2
#define VKILL	3
#define VEOF	4

#define IGNBRK	0000001
#define BRKINT	0000002
#define IGNPAR	0000004
#define PARMRK	0000010
#define INPCK	0000020
#define ISTRIP	0000040
#define INLCR	0000100
#define IGNCR	0000200
#define ICRNL	0000400
#define IXANY	0004000
#define IMAXBEL	0020000

#define CS5	0000000

#define ECHO	0000010

#define B0	0000000
#define B50	0000001
#define B75	0000002
#define B110	0000003
#define B134	0000004
#define B150	0000005
#define B200	0000006
#define B300	0000007
#define B600	0000010
#define B1200	0000011
#define B1800	0000012
#define B2400	0000013
#define B4800	0000014
#define B9600	0000015
#define B19200	0000016
#define B38400	0000017

extern speed_t cfgetispeed(const struct termios *);
extern speed_t cfgetospeed(const struct termios *);
extern void cfmakeraw(struct termios *);
extern int cfsetispeed(struct termios *, speed_t);
extern int cfsetospeed(struct termios *, speed_t);
extern int cfsetspeed(struct termios *, speed_t);
extern int tcflow(int, int);
extern int tcflush(int, int);
extern pid_t tcgetsid(int);
extern int tcsendbreak(int, int);
extern int tcsetattr(int, int, const struct termios *);
extern int tcdrain(int);
extern int tcgetattr(int, struct termios *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6027"
>13.4.71. time.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CLK_TCK	((clock_t)__sysconf(2))
#define CLOCK_REALTIME	0
#define TIMER_ABSTIME	1
#define CLOCKS_PER_SEC	1000000l

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    char *tm_zone;
};
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};

extern int __daylight(void);
extern long int __timezone(void);
extern char *__tzname(void);
extern char *asctime(const struct tm *);
extern clock_t clock(void);
extern char *ctime(const time_t *);
extern char *ctime_r(const time_t *, char *);
extern double difftime(time_t, time_t);
extern struct tm *getdate(const char *);
extern int getdate_err(void);
extern struct tm *gmtime(const time_t *);
extern struct tm *localtime(const time_t *);
extern time_t mktime(struct tm *);
extern int stime(const time_t *);
extern size_t strftime(char *, size_t, const char *, const struct tm *);
extern char *strptime(const char *, const char *, struct tm *);
extern time_t time(time_t *);
extern int nanosleep(const struct timespec *, struct timespec *);
extern int daylight(void);
extern long int timezone(void);
extern char *tzname(void);
extern void tzset(void);
extern char *asctime_r(const struct tm *, char *);
extern struct tm *gmtime_r(const time_t *, struct tm *);
extern struct tm *localtime_r(const time_t *, struct tm *);
extern int clock_getcpuclockid(pid_t, clockid_t *);
extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_nanosleep(clockid_t, int, const struct timespec *,
			   struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int timer_create(clockid_t, struct sigevent *, timer_t *);
extern int timer_delete(timer_t);
extern int timer_getoverrun(timer_t);
extern int timer_gettime(timer_t, struct itimerspec *);
extern int timer_settime(timer_t, int, const struct itimerspec *,
			 struct itimerspec *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6031"
>13.4.72. ucontext.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int getcontext(ucontext_t *);
extern int makecontext(ucontext_t *, void (*func) (void)
		       , int, ...);
extern int setcontext(const struct ucontext *);
extern int swapcontext(ucontext_t *, const struct ucontext *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6035"
>13.4.73. ulimit.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UL_GETFSIZE	1
#define UL_SETFSIZE	2

extern long int ulimit(int, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6039"
>13.4.74. unistd.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SEEK_SET	0
#define STDIN_FILENO	0
#define SEEK_CUR	1
#define STDOUT_FILENO	1
#define SEEK_END	2
#define STDERR_FILENO	2

typedef long long int off64_t;

#define F_OK	0
#define X_OK	1
#define W_OK	2
#define R_OK	4

#define _POSIX_VDISABLE	'\0'
#define _POSIX_CHOWN_RESTRICTED	1
#define _POSIX_JOB_CONTROL	1
#define _POSIX_NO_TRUNC	1
#define _POSIX_SHELL	1
#define _POSIX_FSYNC	200112
#define _POSIX_MAPPED_FILES	200112
#define _POSIX_MEMLOCK	200112
#define _POSIX_MEMLOCK_RANGE	200112
#define _POSIX_MEMORY_PROTECTION	200112
#define _POSIX_SEMAPHORES	200112
#define _POSIX_SHARED_MEMORY_OBJECTS	200112
#define _POSIX_TIMERS	200112
#define _POSIX2_C_BIND	200112L
#define _POSIX_THREADS	200112L

#define _PC_LINK_MAX	0
#define _PC_MAX_CANON	1
#define _PC_ASYNC_IO	10
#define _PC_PRIO_IO	11
#define _PC_FILESIZEBITS	13
#define _PC_REC_INCR_XFER_SIZE	14
#define _PC_REC_MIN_XFER_SIZE	16
#define _PC_REC_XFER_ALIGN	17
#define _PC_ALLOC_SIZE_MIN	18
#define _PC_MAX_INPUT	2
#define _PC_2_SYMLINKS	20
#define _PC_NAME_MAX	3
#define _PC_PATH_MAX	4
#define _PC_PIPE_BUF	5
#define _PC_CHOWN_RESTRICTED	6
#define _PC_NO_TRUNC	7
#define _PC_VDISABLE	8
#define _PC_SYNC_IO	9

#define _SC_ARG_MAX	0
#define _SC_CHILD_MAX	1
#define _SC_PRIORITY_SCHEDULING	10
#define _SC_TIMERS	11
#define _SC_ASYNCHRONOUS_IO	12
#define _SC_XBS5_ILP32_OFF32	125
#define _SC_XBS5_ILP32_OFFBIG	126
#define _SC_XBS5_LP64_OFF64	127
#define _SC_XBS5_LPBIG_OFFBIG	128
#define _SC_XOPEN_LEGACY	129
#define _SC_PRIORITIZED_IO	13
#define _SC_XOPEN_REALTIME	130
#define _SC_XOPEN_REALTIME_THREADS	131
#define _SC_ADVISORY_INFO	132
#define _SC_BARRIERS	133
#define _SC_CLOCK_SELECTION	137
#define _SC_CPUTIME	138
#define _SC_THREAD_CPUTIME	139
#define _SC_SYNCHRONIZED_IO	14
#define _SC_MONOTONIC_CLOCK	149
#define _SC_FSYNC	15
#define _SC_READER_WRITER_LOCKS	153
#define _SC_SPIN_LOCKS	154
#define _SC_REGEXP	155
#define _SC_SHELL	157
#define _SC_SPAWN	159
#define _SC_MAPPED_FILES	16
#define _SC_SPORADIC_SERVER	160
#define _SC_THREAD_SPORADIC_SERVER	161
#define _SC_TIMEOUTS	164
#define _SC_TYPED_MEMORY_OBJECTS	165
#define _SC_2_PBS_ACCOUNTING	169
#define _SC_MEMLOCK	17
#define _SC_2_PBS_LOCATE	170
#define _SC_2_PBS_MESSAGE	171
#define _SC_2_PBS_TRACK	172
#define _SC_SYMLOOP_MAX	173
#define _SC_2_PBS_CHECKPOINT	175
#define _SC_V6_ILP32_OFF32	176
#define _SC_V6_ILP32_OFFBIG	177
#define _SC_V6_LP64_OFF64	178
#define _SC_V6_LPBIG_OFFBIG	179
#define _SC_MEMLOCK_RANGE	18
#define _SC_HOST_NAME_MAX	180
#define _SC_TRACE	181
#define _SC_TRACE_EVENT_FILTER	182
#define _SC_TRACE_INHERIT	183
#define _SC_TRACE_LOG	184
#define _SC_MEMORY_PROTECTION	19
#define _SC_CLK_TCK	2
#define _SC_MESSAGE_PASSING	20
#define _SC_SEMAPHORES	21
#define _SC_SHARED_MEMORY_OBJECTS	22
#define _SC_AIO_LISTIO_MAX	23
#define _SC_AIO_MAX	24
#define _SC_AIO_PRIO_DELTA_MAX	25
#define _SC_DELAYTIMER_MAX	26
#define _SC_MQ_OPEN_MAX	27
#define _SC_MQ_PRIO_MAX	28
#define _SC_VERSION	29
#define _SC_NGROUPS_MAX	3
#define _SC_PAGESIZE	30
#define _SC_PAGE_SIZE	30
#define _SC_RTSIG_MAX	31
#define _SC_SEM_NSEMS_MAX	32
#define _SC_SEM_VALUE_MAX	33
#define _SC_SIGQUEUE_MAX	34
#define _SC_TIMER_MAX	35
#define _SC_BC_BASE_MAX	36
#define _SC_BC_DIM_MAX	37
#define _SC_BC_SCALE_MAX	38
#define _SC_BC_STRING_MAX	39
#define _SC_OPEN_MAX	4
#define _SC_COLL_WEIGHTS_MAX	40
#define _SC_EXPR_NEST_MAX	42
#define _SC_LINE_MAX	43
#define _SC_RE_DUP_MAX	44
#define _SC_2_VERSION	46
#define _SC_2_C_BIND	47
#define _SC_2_C_DEV	48
#define _SC_2_FORT_DEV	49
#define _SC_STREAM_MAX	5
#define _SC_2_FORT_RUN	50
#define _SC_2_SW_DEV	51
#define _SC_2_LOCALEDEF	52
#define _SC_TZNAME_MAX	6
#define _SC_IOV_MAX	60
#define _SC_THREADS	67
#define _SC_THREAD_SAFE_FUNCTIONS	68
#define _SC_GETGR_R_SIZE_MAX	69
#define _SC_JOB_CONTROL	7
#define _SC_GETPW_R_SIZE_MAX	70
#define _SC_LOGIN_NAME_MAX	71
#define _SC_TTY_NAME_MAX	72
#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
#define _SC_THREAD_KEYS_MAX	74
#define _SC_THREAD_STACK_MIN	75
#define _SC_THREAD_THREADS_MAX	76
#define _SC_THREAD_ATTR_STACKADDR	77
#define _SC_THREAD_ATTR_STACKSIZE	78
#define _SC_THREAD_PRIORITY_SCHEDULING	79
#define _SC_SAVED_IDS	8
#define _SC_THREAD_PRIO_INHERIT	80
#define _SC_THREAD_PRIO_PROTECT	81
#define _SC_THREAD_PROCESS_SHARED	82
#define _SC_ATEXIT_MAX	87
#define _SC_PASS_MAX	88
#define _SC_XOPEN_VERSION	89
#define _SC_REALTIME_SIGNALS	9
#define _SC_XOPEN_UNIX	91
#define _SC_XOPEN_CRYPT	92
#define _SC_XOPEN_ENH_I18N	93
#define _SC_XOPEN_SHM	94
#define _SC_2_CHAR_TERM	95
#define _SC_2_C_VERSION	96
#define _SC_2_UPE	97

#define _CS_PATH	0
#define _POSIX_REGEXP	1
#define _CS_XBS5_ILP32_OFF32_CFLAGS	1100
#define _CS_XBS5_ILP32_OFF32_LDFLAGS	1101
#define _CS_XBS5_ILP32_OFF32_LIBS	1102
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS	1103
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS	1104
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS	1105
#define _CS_XBS5_ILP32_OFFBIG_LIBS	1106
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS	1107
#define _CS_XBS5_LP64_OFF64_CFLAGS	1108
#define _CS_XBS5_LP64_OFF64_LDFLAGS	1109
#define _CS_XBS5_LP64_OFF64_LIBS	1110
#define _CS_XBS5_LP64_OFF64_LINTFLAGS	1111
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS	1112
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS	1113
#define _CS_XBS5_LPBIG_OFFBIG_LIBS	1114
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS	1115

#define _XOPEN_XPG4	1

#define F_ULOCK	0
#define F_LOCK	1
#define F_TLOCK	2
#define F_TEST	3

extern char **__environ(void);
extern pid_t __getpgid(pid_t);
extern void _exit(int);
extern int acct(const char *);
extern unsigned int alarm(unsigned int);
extern int chown(const char *, uid_t, gid_t);
extern int chroot(const char *);
extern size_t confstr(int, char *, size_t);
extern int creat(const char *, mode_t);
extern int creat64(const char *, mode_t);
extern char *ctermid(char *);
extern char *cuserid(char *);
extern int daemon(int, int);
extern int execl(const char *, const char *, ...);
extern int execle(const char *, const char *, ...);
extern int execlp(const char *, const char *, ...);
extern int execv(const char *, char *const);
extern int execvp(const char *, char *const);
extern int fdatasync(int);
extern int ftruncate64(int, off64_t);
extern long int gethostid(void);
extern char *getlogin(void);
extern int getlogin_r(char *, size_t);
extern int getopt(int, char *const, const char *);
extern pid_t getpgrp(void);
extern pid_t getsid(pid_t);
extern char *getwd(char *);
extern int lockf(int, int, off_t);
extern int mkstemp(char *);
extern int nice(int);
extern char *optarg(void);
extern int opterr(void);
extern int optind(void);
extern int optopt(void);
extern int rename(const char *, const char *);
extern int setegid(gid_t);
extern int seteuid(uid_t);
extern int sethostname(const char *, size_t);
extern int setpgrp(void);
extern void swab(const void *, void *, ssize_t);
extern void sync(void);
extern pid_t tcgetpgrp(int);
extern int tcsetpgrp(int, pid_t);
extern int truncate(const char *, off_t);
extern int truncate64(const char *, off64_t);
extern char *ttyname(int);
extern unsigned int ualarm(useconds_t, useconds_t);
extern int usleep(useconds_t);
extern int close(int);
extern int fsync(int);
extern off_t lseek(int, off_t, int);
extern int open(const char *, int, ...);
extern int pause(void);
extern ssize_t read(int, void *, size_t);
extern ssize_t write(int, const void *, size_t);
extern char *crypt(char *, char *);
extern void encrypt(char *, int);
extern void setkey(const char *);
extern int access(const char *, int);
extern int brk(void *);
extern int chdir(const char *);
extern int dup(int);
extern int dup2(int, int);
extern int execve(const char *, char *const, char *const);
extern int fchdir(int);
extern int fchown(int, uid_t, gid_t);
extern pid_t fork(void);
extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern int getgroups(int, gid_t);
extern int gethostname(char *, size_t);
extern pid_t getpgid(pid_t);
extern pid_t getpid(void);
extern uid_t getuid(void);
extern int lchown(const char *, uid_t, gid_t);
extern int link(const char *, const char *);
extern int mkdir(const char *, mode_t);
extern long int pathconf(const char *, int);
extern int pipe(int);
extern int readlink(const char *, char *, size_t);
extern int rmdir(const char *);
extern void *sbrk(ptrdiff_t);
extern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
extern int setgid(gid_t);
extern int setpgid(pid_t, pid_t);
extern int setregid(gid_t, gid_t);
extern int setreuid(uid_t, uid_t);
extern pid_t setsid(void);
extern int setuid(uid_t);
extern unsigned int sleep(unsigned int);
extern int symlink(const char *, const char *);
extern long int sysconf(int);
extern int unlink(const char *);
extern pid_t vfork(void);
extern ssize_t pread(int, void *, size_t, off_t);
extern ssize_t pwrite(int, const void *, size_t, off_t);
extern char **_environ(void);
extern long int fpathconf(int, int);
extern int ftruncate(int, off_t);
extern char *getcwd(char *, size_t);
extern int getpagesize(void);
extern pid_t getppid(void);
extern int isatty(int);
extern loff_t lseek64(int, loff_t, int);
extern int open64(const char *, int, ...);
extern ssize_t pread64(int, void *, size_t, off64_t);
extern ssize_t pwrite64(int, const void *, size_t, off64_t);
extern int ttyname_r(int, char *, size_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6043"
>13.4.75. utime.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct utimbuf {
    time_t actime;
    time_t modtime;
};
extern int utime(const char *, const struct utimbuf *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6047"
>13.4.76. utmp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UT_HOSTSIZE	256
#define UT_LINESIZE	32
#define UT_NAMESIZE	32

struct exit_status {
    short e_termination;
    short e_exit;
};

#define EMPTY	0
#define RUN_LVL	1
#define BOOT_TIME	2
#define NEW_TIME	3
#define OLD_TIME	4
#define INIT_PROCESS	5
#define LOGIN_PROCESS	6
#define USER_PROCESS	7
#define DEAD_PROCESS	8
#define ACCOUNTING	9

extern void endutent(void);
extern struct utmp *getutent(void);
extern void setutent(void);
extern int getutent_r(struct utmp *, struct utmp **);
extern int utmpname(const char *);
extern int login_tty(int);
extern void login(const struct utmp *);
extern int logout(const char *);
extern void logwtmp(const char *, const char *, const char *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6051"
>13.4.77. utmpx.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void endutxent(void);
extern struct utmpx *getutxent(void);
extern struct utmpx *getutxid(const struct utmpx *);
extern struct utmpx *getutxline(const struct utmpx *);
extern struct utmpx *pututxline(const struct utmpx *);
extern void setutxent(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6055"
>13.4.78. wchar.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define WEOF	(0xffffffffu)
#define WCHAR_MAX	0x7FFFFFFF
#define WCHAR_MIN	0x80000000

extern double __wcstod_internal(const wchar_t *, wchar_t * *, int);
extern float __wcstof_internal(const wchar_t *, wchar_t * *, int);
extern long int __wcstol_internal(const wchar_t *, wchar_t * *, int, int);
extern long double __wcstold_internal(const wchar_t *, wchar_t * *, int);
extern unsigned long int __wcstoul_internal(const wchar_t *, wchar_t * *,
					    int, int);
extern wchar_t *wcscat(wchar_t *, const wchar_t *);
extern wchar_t *wcschr(const wchar_t *, wchar_t);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t *, const wchar_t *);
extern size_t wcscspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsdup(const wchar_t *);
extern wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t * *);
extern int wcswidth(const wchar_t *, size_t);
extern size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
extern int wctob(wint_t);
extern int wcwidth(wchar_t);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t);
extern size_t mbrlen(const char *, size_t, mbstate_t *);
extern size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
extern int mbsinit(const mbstate_t *);
extern size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t,
			 mbstate_t *);
extern size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
extern wchar_t *wcpcpy(wchar_t *, const wchar_t *);
extern wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t);
extern size_t wcrtomb(char *, wchar_t, mbstate_t *);
extern size_t wcslen(const wchar_t *);
extern size_t wcsnrtombs(char *, const wchar_t * *, size_t, size_t,
			 mbstate_t *);
extern size_t wcsrtombs(char *, const wchar_t * *, size_t, mbstate_t *);
extern double wcstod(const wchar_t *, wchar_t * *);
extern float wcstof(const wchar_t *, wchar_t * *);
extern long int wcstol(const wchar_t *, wchar_t * *, int);
extern long double wcstold(const wchar_t *, wchar_t * *);
extern long long int wcstoq(const wchar_t *, wchar_t * *, int);
extern unsigned long int wcstoul(const wchar_t *, wchar_t * *, int);
extern unsigned long long int wcstouq(const wchar_t *, wchar_t * *, int);
extern wchar_t *wcswcs(const wchar_t *, const wchar_t *);
extern int wcscasecmp(const wchar_t *, const wchar_t *);
extern int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
extern size_t wcsnlen(const wchar_t *, size_t);
extern long long int wcstoll(const wchar_t *, wchar_t * *, int);
extern unsigned long long int wcstoull(const wchar_t *, wchar_t * *, int);
extern wint_t btowc(int);
extern wint_t fgetwc(FILE *);
extern wint_t fgetwc_unlocked(FILE *);
extern wchar_t *fgetws(wchar_t *, int, FILE *);
extern wint_t fputwc(wchar_t, FILE *);
extern int fputws(const wchar_t *, FILE *);
extern int fwide(FILE *, int);
extern int fwprintf(FILE *, const wchar_t *, ...);
extern int fwscanf(FILE *, const wchar_t *, ...);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
extern int swprintf(wchar_t *, size_t, const wchar_t *, ...);
extern int swscanf(const wchar_t *, const wchar_t *, ...);
extern wint_t ungetwc(wint_t, FILE *);
extern int vfwprintf(FILE *, const wchar_t *, va_list);
extern int vfwscanf(FILE *, const wchar_t *, va_list);
extern int vswprintf(wchar_t *, size_t, const wchar_t *, va_list);
extern int vswscanf(const wchar_t *, const wchar_t *, va_list);
extern int vwprintf(const wchar_t *, va_list);
extern int vwscanf(const wchar_t *, va_list);
extern size_t wcsftime(wchar_t *, size_t, const wchar_t *,
		       const struct tm *);
extern int wprintf(const wchar_t *, ...);
extern int wscanf(const wchar_t *, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6059"
>13.4.79. wctype.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef unsigned long int wctype_t;
typedef unsigned int wint_t;
typedef const int32_t *wctrans_t;
typedef struct {
    int count;
    wint_t value;
} __mbstate_t;

typedef __mbstate_t mbstate_t;
extern int iswblank(wint_t);
extern wint_t towlower(wint_t);
extern wint_t towupper(wint_t);
extern wctrans_t wctrans(const char *);
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswcntrl(wint_t);
extern int iswctype(wint_t, wctype_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern wctype_t wctype(const char *);
extern wint_t towctrans(wint_t, wctrans_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6063"
>13.4.80. wordexp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum {
    WRDE_DOOFFS, WRDE_APPEND, WRDE_NOCMD, WRDE_REUSE, WRDE_SHOWERR,
	WRDE_UNDEF, __WRDE_FLAGS
};

typedef struct {
    int we_wordc;
    char **we_wordv;
    int we_offs;
} wordexp_t;

enum {
    WRDE_NOSYS, WRDE_NOSPACE, WRDE_BADCHAR, WRDE_BADVAL, WRDE_CMDSUB,
	WRDE_SYNTAX
};
extern int wordexp(const char *, wordexp_t *, int);
extern void wordfree(wordexp_t *);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBCMAN"
>13.5. Interface Definitions for libc</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB--IO-FEOF-3"
>_IO_feof</A
>&nbsp;--&nbsp;alias for feof</DT
><DT
><A
HREF="#BASELIB--IO-GETC-3"
>_IO_getc</A
>&nbsp;--&nbsp;alias for getc</DT
><DT
><A
HREF="#BASELIB--IO-PUTC-3"
>_IO_putc</A
>&nbsp;--&nbsp;alias for putc</DT
><DT
><A
HREF="#BASELIB--IO-PUTS-3"
>_IO_puts</A
>&nbsp;--&nbsp;alias for puts</DT
><DT
><A
HREF="#BASELIB---ASSERT-FAIL-1"
>__assert_fail</A
>&nbsp;--&nbsp;abort the program after false assertion</DT
><DT
><A
HREF="#BASELIB---CTYPE-B-LOC"
>__ctype_b_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b array for ctype functions</DT
><DT
><A
HREF="#BASELIB---CTYPE-GET-MB-CUR-MAX-1"
>__ctype_get_mb_cur_max</A
>&nbsp;--&nbsp;maximum length of a multibyte character in the current locale</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOLOWER-LOC"
>__ctype_tolower_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b_tolower array for ctype tolower() function</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOUPPER-LOC"
>__ctype_toupper_loc</A
>&nbsp;--&nbsp;accessor function for <TT
CLASS="FUNCTION"
>__ctype_b_toupper()</TT
>
array for ctype <TT
CLASS="FUNCTION"
>toupper()</TT
> function</DT
><DT
><A
HREF="#BASELIB---CXA-ATEXIT"
>__cxa_atexit</A
>&nbsp;--&nbsp;register a function to be called by exit or when a shared library is unloaded</DT
><DT
><A
HREF="#BASELIB-DAYLIGHT-1"
>__daylight</A
>&nbsp;--&nbsp;daylight savings time flag</DT
><DT
><A
HREF="#BASELIB---ENVIRON"
>__environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB-ERRNO-LOCATION-1"
>__errno_location</A
>&nbsp;--&nbsp;address of errno variable</DT
><DT
><A
HREF="#BASELIB---FPENDING"
>__fpending</A
>&nbsp;--&nbsp;returns in bytes the amount of output pending on a stream</DT
><DT
><A
HREF="#BASELIB---GETPAGESIZE"
>__getpagesize</A
>&nbsp;--&nbsp;alias for getpagesize - get current page size </DT
><DT
><A
HREF="#BASELIB---GETPGID-1"
>__getpgid</A
>&nbsp;--&nbsp;get the process group id</DT
><DT
><A
HREF="#BASELIB-H-ERRNO-LOCATION-1"
>__h_errno_location</A
>&nbsp;--&nbsp;address of h_errno variable</DT
><DT
><A
HREF="#BASELIB---ISINF"
>__isinf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFF"
>__isinff</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFL"
>__isinfl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNAN"
>__isnan</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANF"
>__isnanf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANL"
>__isnanl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMAX-1"
>__libc_current_sigrtmax</A
>&nbsp;--&nbsp;return number of available real-time signal with lowest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMIN-1"
>__libc_current_sigrtmin</A
>&nbsp;--&nbsp;return number of available real-time signal with highest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-START-MAIN-"
>__libc_start_main</A
>&nbsp;--&nbsp;initialization routine</DT
><DT
><A
HREF="#LIBUTIL---LXSTAT-2"
>__lxstat</A
>&nbsp;--&nbsp;inline wrapper around call to lxstat</DT
><DT
><A
HREF="#BASELIB---MEMPCPY"
>__mempcpy</A
>&nbsp;--&nbsp;copy given number of bytes of source to destination</DT
><DT
><A
HREF="#BASELIB---RAWMEMCHR"
>__rawmemchr</A
>&nbsp;--&nbsp;scan memory</DT
><DT
><A
HREF="#BASELIB--REGISTER-ATFORK"
>__register_atfork</A
>&nbsp;--&nbsp;alias for register_atfork</DT
><DT
><A
HREF="#BASELIB---SIGSETJMP-1"
>__sigsetjmp</A
>&nbsp;--&nbsp;save stack context for non-local goto</DT
><DT
><A
HREF="#LIBUTIL---STPCPY-2"
>__stpcpy</A
>&nbsp;--&nbsp;alias for stpcpy</DT
><DT
><A
HREF="#BASELIB---STRDUP-1"
>__strdup</A
>&nbsp;--&nbsp;alias for strdup</DT
><DT
><A
HREF="#BASELIB---STRTOD-INTERNAL-1"
>__strtod_internal</A
>&nbsp;--&nbsp;underlying function for strtod</DT
><DT
><A
HREF="#BASELIB-STRTOF-INTERNAL-1"
>__strtof_internal</A
>&nbsp;--&nbsp;underlying function for strtof</DT
><DT
><A
HREF="#BASELIB---STRTOK-R-1"
>__strtok_r</A
>&nbsp;--&nbsp;alias for strtok_r</DT
><DT
><A
HREF="#BASELIB---STRTOL-INTERNAL-1"
>__strtol_internal</A
>&nbsp;--&nbsp;alias for strtol</DT
><DT
><A
HREF="#BASELIB---STRTOLD-INTERNAL-1"
>__strtold_internal</A
>&nbsp;--&nbsp;underlying function for strtold</DT
><DT
><A
HREF="#BASELIB---STRTOLL-INTERNAL-1"
>__strtoll_internal</A
>&nbsp;--&nbsp;underlying function for strtoll</DT
><DT
><A
HREF="#BASELIB-STRTOUL-INTERNAL-1"
>__strtoul_internal</A
>&nbsp;--&nbsp;underlying function for strtoul</DT
><DT
><A
HREF="#BASELIB---STRTOULL-INTERNAL-1"
>__strtoull_internal</A
>&nbsp;--&nbsp;underlying function for strtoull</DT
><DT
><A
HREF="#BASELIB---SYSCONF"
>__sysconf</A
>&nbsp;--&nbsp;get configuration information at runtime</DT
><DT
><A
HREF="#BASELIB---SYSV-SIGNAL-1"
>__sysv_signal</A
>&nbsp;--&nbsp;signal handling</DT
><DT
><A
HREF="#BASELIB-TIMEZONE-1"
>__timezone</A
>&nbsp;--&nbsp;global variable containing timezone</DT
><DT
><A
HREF="#BASELIB-TZNAME-1"
>__tzname</A
>&nbsp;--&nbsp;global variable containing the timezone</DT
><DT
><A
HREF="#BASELIB---WCSTOD-INTERNAL-1"
>__wcstod_internal</A
>&nbsp;--&nbsp;underlying function for wcstod</DT
><DT
><A
HREF="#BASELIB---WCSTOF-INTERNAL-1"
>__wcstof_internal</A
>&nbsp;--&nbsp;underlying function for wcstof</DT
><DT
><A
HREF="#BASELIB---WCSTOL-INTERNAL-1"
>__wcstol_internal</A
>&nbsp;--&nbsp;underlying function for wcstol</DT
><DT
><A
HREF="#BASELIB---WCSTOLD-INTERNAL-1"
>__wcstold_internal</A
>&nbsp;--&nbsp;underlying function for wcstold</DT
><DT
><A
HREF="#BASELIB---WCSTOUL-INTERNAL-1"
>__wcstoul_internal</A
>&nbsp;--&nbsp;underlying function for wcstoul</DT
><DT
><A
HREF="#BASELIB---XMKNOD-1"
>__xmknod</A
>&nbsp;--&nbsp;make block or character special file</DT
><DT
><A
HREF="#BASELIB-XSTAT-1"
>__xstat</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB-XSTAT64-1"
>__xstat64</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB--ENVIRON"
>_environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB--NL-MSG-CAT-CNTR"
>_nl_msg_cat_cntr</A
>&nbsp;--&nbsp;new catalog load counter</DT
><DT
><A
HREF="#BASELIB--SYS-ERRLIST"
>_sys_errlist</A
>&nbsp;--&nbsp;array containing the "C" locale strings used by strerror()</DT
><DT
><A
HREF="#BASELIB--SYS-SIGLIST"
>_sys_siglist</A
>&nbsp;--&nbsp;array containing the names of the signal names</DT
><DT
><A
HREF="#BASELIB-ACCT-3"
>acct</A
>&nbsp;--&nbsp;switch process accounting on or off</DT
><DT
><A
HREF="#BASELIB-ADJTIME-2"
>adjtime</A
>&nbsp;--&nbsp;correct the time to allow synchronization of the system clock</DT
><DT
><A
HREF="#BASELIB-ASPRINTF"
>asprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-BIND-TEXTDOMAIN-CODESET"
>bind_textdomain_codeset</A
>&nbsp;--&nbsp;specify encoding for message retrieval</DT
><DT
><A
HREF="#BASELIB-BINDRESVPORT-3"
>bindresvport</A
>&nbsp;--&nbsp;bind socket to privileged IP port</DT
><DT
><A
HREF="#BASELIB-BINDTEXTDOMAIN"
>bindtextdomain</A
>&nbsp;--&nbsp;specify the location of a message catalog</DT
><DT
><A
HREF="#BASELIB-CFMAKERAW-3"
>cfmakeraw</A
>&nbsp;--&nbsp;get and set terminal attributes</DT
><DT
><A
HREF="#BASELIB-CFSETSPEED-3"
>cfsetspeed</A
>&nbsp;--&nbsp;set terminal input and output data rate</DT
><DT
><A
HREF="#BASELIB-DAEMON-3"
>daemon</A
>&nbsp;--&nbsp;run in the background</DT
><DT
><A
HREF="#BASELIB-DCGETTEXT"
>dcgettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog</DT
><DT
><A
HREF="#BASELIB-DCNGETTEXT"
>dcngettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog
with plural</DT
><DT
><A
HREF="#BASELIB-DGETTEXT"
>dgettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current LC_MESSAGES locale</DT
><DT
><A
HREF="#BASELIB-DNGETTEXT"
>dngettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current locale</DT
><DT
><A
HREF="#BASELIB-DUPLOCALE-3"
>duplocale</A
>&nbsp;--&nbsp;provide new handle for selection of locale</DT
><DT
><A
HREF="#BASELIB-ERR-3"
>err</A
>&nbsp;--&nbsp;display formatted error messages</DT
><DT
><A
HREF="#BASELIB-ERROR-N"
>error</A
>&nbsp;--&nbsp;print error message</DT
><DT
><A
HREF="#BASELIB-ERRX-3"
>errx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-FCNTL-3"
>fcntl</A
>&nbsp;--&nbsp;file control</DT
><DT
><A
HREF="#BASELIB-FFLUSH-UNLOCKED-1"
>fflush_unlocked</A
>&nbsp;--&nbsp;non thread safe fflush</DT
><DT
><A
HREF="#BASELIB-FGETWC-UNLOCKED-1"
>fgetwc_unlocked</A
>&nbsp;--&nbsp;non thread safe fgetwc</DT
><DT
><A
HREF="#BASELIB-FLOCK-2"
>flock</A
>&nbsp;--&nbsp;apply or remove an advisory lock on an open file</DT
><DT
><A
HREF="#BASELIB-FREELOCALE-3"
>freelocale</A
>&nbsp;--&nbsp;free a locale object</DT
><DT
><A
HREF="#BASELIB-FSCANF"
>fscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-FWSCANF"
>fwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-GETGROUPLIST-3"
>getgrouplist</A
>&nbsp;--&nbsp;get network group entry</DT
><DT
><A
HREF="#BASELIB-GETLOADAVG-3"
>getloadavg</A
>&nbsp;--&nbsp;get system load averages</DT
><DT
><A
HREF="#LIBUTIL-GETOPT-3"
>getopt</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-3"
>getopt_long</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-ONLY-3"
>getopt_long_only</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETSOCKOPT-1"
>getsockopt</A
>&nbsp;--&nbsp;get socket options</DT
><DT
><A
HREF="#BASELIB-GETTEXT"
>gettext</A
>&nbsp;--&nbsp;search message catalogs for a string</DT
><DT
><A
HREF="#BASELIB-GETUTENT-3"
>getutent</A
>&nbsp;--&nbsp;access user accounting database entries	</DT
><DT
><A
HREF="#BASELIB-GETUTENT-R-3"
>getutent_r</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-GLOB64"
>glob64</A
>&nbsp;--&nbsp;find pathnames matching a pattern  (Large File Support)</DT
><DT
><A
HREF="#BASELIB-GLOBFREE64"
>globfree64</A
>&nbsp;--&nbsp;free memory from glob64() (Large File Support)</DT
><DT
><A
HREF="#BASELIB-INITGROUPS-3"
>initgroups</A
>&nbsp;--&nbsp;initialize the supplementary group access list</DT
><DT
><A
HREF="#BASELIB-IOCTL-2"
>ioctl</A
>&nbsp;--&nbsp;control device</DT
><DT
><A
HREF="#BASELIB-SOCKIO-2"
>sockio</A
>&nbsp;--&nbsp;socket ioctl commands</DT
><DT
><A
HREF="#BASELIB-TTYIO-2"
>ttyio</A
>&nbsp;--&nbsp;tty ioctl commands</DT
><DT
><A
HREF="#BASELIB-KILL-3"
>kill</A
>&nbsp;--&nbsp;send a signal</DT
><DT
><A
HREF="#BASELIB-LINK-1"
>link</A
>&nbsp;--&nbsp;create a link to a file</DT
><DT
><A
HREF="#BASELIB-MBSNRTOWCS-3"
>mbsnrtowcs</A
>&nbsp;--&nbsp;convert a multibyte string to a wide character string</DT
><DT
><A
HREF="#BASELIB-MEMMEM-3"
>memmem</A
>&nbsp;--&nbsp;locate bytes</DT
><DT
><A
HREF="#BASELIB-MEMRCHR"
>memrchr</A
>&nbsp;--&nbsp;scan memory for a character</DT
><DT
><A
HREF="#BASELIB-NEWLOCALE-3"
>newlocale</A
>&nbsp;--&nbsp;allocate a locale object</DT
><DT
><A
HREF="#BASELIB-NGETTEXT"
>ngettext</A
>&nbsp;--&nbsp;search message catalogs for plural string</DT
><DT
><A
HREF="#BASELIB-PMAP-GETPORT-3"
>pmap_getport</A
>&nbsp;--&nbsp;find the port number assigned to a service registered with a
portmapper.</DT
><DT
><A
HREF="#BASELIB-PMAP-SET-3"
>pmap_set</A
>&nbsp;--&nbsp;establishes mapping to machine's RPC Bind service.</DT
><DT
><A
HREF="#BASELIB-PMAP-UNSET-3"
>pmap_unset</A
>&nbsp;--&nbsp;
destroys RPC Binding&#13;</DT
><DT
><A
HREF="#BASELIB-PSIGNAL-3"
>psignal</A
>&nbsp;--&nbsp;print signal message</DT
><DT
><A
HREF="#BASELIB-REGEXEC-2"
>regexec</A
>&nbsp;--&nbsp;regular expression matching</DT
><DT
><A
HREF="#BASELIB-SCANF"
>scanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SETBUFFER-3"
>setbuffer</A
>&nbsp;--&nbsp;stream buffering operation</DT
><DT
><A
HREF="#BASELIB-SETGROUPS-2"
>setgroups</A
>&nbsp;--&nbsp;set list of supplementary group IDs</DT
><DT
><A
HREF="#BASELIB-SETHOSTNAME-2"
>sethostname</A
>&nbsp;--&nbsp;set host name</DT
><DT
><A
HREF="#BASELIB-SETSOCKOPT-2"
>setsockopt</A
>&nbsp;--&nbsp;set socket options</DT
><DT
><A
HREF="#BASELIB-SETUTENT-3"
>setutent</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-SIGANDSET"
>sigandset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical AND</DT
><DT
><A
HREF="#BASELIB-SIGISEMPTYSET"
>sigisemptyset</A
>&nbsp;--&nbsp;check for empty signal set</DT
><DT
><A
HREF="#BASELIB-SIGORSET"
>sigorset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical OR</DT
><DT
><A
HREF="#BASELIB-SIGRETURN-2"
>sigreturn</A
>&nbsp;--&nbsp;return from signal handler and cleanup stack frame</DT
><DT
><A
HREF="#BASELIB-SSCANF"
>sscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-STIME-2"
>stime</A
>&nbsp;--&nbsp;set time</DT
><DT
><A
HREF="#BASELIB-STPCPY-3"
>stpcpy</A
>&nbsp;--&nbsp;copy a string returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-STPNCPY-3"
>stpncpy</A
>&nbsp;--&nbsp;copy a fixed-size string, returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-STRCASESTR"
>strcasestr</A
>&nbsp;--&nbsp;locate a substring ignoring case</DT
><DT
><A
HREF="#BASELIB-STRERROR-R"
>strerror_r</A
>&nbsp;--&nbsp;reentrant version of strerror</DT
><DT
><A
HREF="#BASELIB-STRNDUP"
>strndup</A
>&nbsp;--&nbsp;return a malloc'd copy of at most the specified number of bytes of a string </DT
><DT
><A
HREF="#BASELIB-STRNLEN-3"
>strnlen</A
>&nbsp;--&nbsp;determine the length of a fixed-size string</DT
><DT
><A
HREF="#BASELIB-STRPTIME-3"
>strptime</A
>&nbsp;--&nbsp;parse a time string</DT
><DT
><A
HREF="#BASELIB-STRSEP-3"
>strsep</A
>&nbsp;--&nbsp;extract token from string</DT
><DT
><A
HREF="#BASELIB-STRSIGNAL-3"
>strsignal</A
>&nbsp;--&nbsp;return string describing signal</DT
><DT
><A
HREF="#BASELIB-STRTOQ-3"
>strtoq</A
>&nbsp;--&nbsp;convert string value to a long or quad_t integer</DT
><DT
><A
HREF="#BASELIB-STRTOUQ-3"
>strtouq</A
>&nbsp;--&nbsp;convert a string to an unsigned long long</DT
><DT
><A
HREF="#BASELIB-SVC-REGISTER-3"
>svc_register</A
>&nbsp;--&nbsp;register Remote Procedure Call interface</DT
><DT
><A
HREF="#BASELIB-SVC-RUN-3"
>svc_run</A
>&nbsp;--&nbsp;waits for RPC requests to arrive and calls service procedure</DT
><DT
><A
HREF="#BASELIB-SVC-SENDREPLY-3"
>svc_sendreply</A
>&nbsp;--&nbsp;called by RPC service's dispatch routine</DT
><DT
><A
HREF="#BASELIB-SVCTCP-CREATE-3"
>svctcp_create</A
>&nbsp;--&nbsp;create a TCP/IP-based RPC service transport</DT
><DT
><A
HREF="#BASELIB-SVCUDP-CREATE-3"
>svcudp_create</A
>&nbsp;--&nbsp;		create a UDP-based RPC service transport
		</DT
><DT
><A
HREF="#BASELIB-SWSCANF"
>swscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SYSTEM-3"
>system</A
>&nbsp;--&nbsp;execute a shell command</DT
><DT
><A
HREF="#BASELIB-TEXTDOMAIN"
>textdomain</A
>&nbsp;--&nbsp;set the current default message domain</DT
><DT
><A
HREF="#BASELIB-UNLINK-3"
>unlink</A
>&nbsp;--&nbsp;remove a directory entry</DT
><DT
><A
HREF="#BASELIB-USELOCALE-3"
>uselocale</A
>&nbsp;--&nbsp;set locale for thread</DT
><DT
><A
HREF="#BASELIB-UTMPNAME-3"
>utmpname</A
>&nbsp;--&nbsp;set user accounting database</DT
><DT
><A
HREF="#BASELIB-VASPRINTF"
>vasprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-VDPRINTF"
>vdprintf</A
>&nbsp;--&nbsp;write formatted output to a file descriptor</DT
><DT
><A
HREF="#BASELIB-VERRX-3"
>verrx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-VFSCANF"
>vfscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VFWSCANF"
>vfwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSCANF"
>vscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSSCANF"
>vsscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSWSCANF"
>vswscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSYSLOG-3"
>vsyslog</A
>&nbsp;--&nbsp;log to system log</DT
><DT
><A
HREF="#BASELIB-VWSCANF"
>vwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-WAIT4-2"
>wait4</A
>&nbsp;--&nbsp;wait for process termination, BSD style</DT
><DT
><A
HREF="#BASELIB-WAITPID-3"
>waitpid</A
>&nbsp;--&nbsp;wait for child process</DT
><DT
><A
HREF="#BASELIB-WARN-3"
>warn</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WARNX-3"
>warnx</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WCPCPY-3"
>wcpcpy</A
>&nbsp;--&nbsp;copy a wide character string, returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-WCPNCPY-3"
>wcpncpy</A
>&nbsp;--&nbsp;copy a fixed-size string of wide characters, returning a pointer to its end</DT
><DT
><A
HREF="#BASELIB-WCSCASECMP-3"
>wcscasecmp</A
>&nbsp;--&nbsp;compare two wide-character strings, ignoring case</DT
><DT
><A
HREF="#BASELIB-WCSDUP-3"
>wcsdup</A
>&nbsp;--&nbsp;duplicate a wide-character string</DT
><DT
><A
HREF="#BASELIB-WCSNCASECMP-3"
>wcsncasecmp</A
>&nbsp;--&nbsp;compare two fixed-size wide-character strings, ignoring case</DT
><DT
><A
HREF="#BASELIB-WCSNLEN-3"
>wcsnlen</A
>&nbsp;--&nbsp;determine the length of a fixed-size wide-character string</DT
><DT
><A
HREF="#BASELIB-WCSNRTOMBS-3"
>wcsnrtombs</A
>&nbsp;--&nbsp;convert a wide character string to a multi-byte string</DT
><DT
><A
HREF="#BASELIB-WCSTOQ"
>wcstoq</A
>&nbsp;--&nbsp;convert wide string to long long int representation</DT
><DT
><A
HREF="#BASELIB-WCSTOUQ"
>wcstouq</A
>&nbsp;--&nbsp;convert wide string to unsigned long long int representation</DT
><DT
><A
HREF="#BASELIB-WSCANF"
>wscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-XDR-U-INT-3"
>xdr_u_int</A
>&nbsp;--&nbsp;library routines for external data representation</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libc and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBC"
>Section 13.3</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB--IO-FEOF-3"
></A
>_IO_feof</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6076"
></A
><H2
>Name</H2
>_IO_feof&nbsp;--&nbsp;alias for feof</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6079"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6082"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_feof</TT
></CODE
>(_IO_FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__fp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6089"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_feof()</TT
> tests the end-of-file indicator for the 
stream pointed to by <TT
CLASS="PARAMETER"
><I
>__fp</I
></TT
>, returning a non-zero 
value if it is set.  </P
><P
><TT
CLASS="FUNCTION"
>_IO_feof()</TT
> is not in the source standard; it is only 
in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--IO-GETC-3"
></A
>_IO_getc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6102"
></A
><H2
>Name</H2
>_IO_getc&nbsp;--&nbsp;alias for getc</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6105"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6108"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_getc</TT
></CODE
>(_IO_FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__fp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6115"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_getc()</TT
> reads the next character from 
<TT
CLASS="PARAMETER"
><I
>__fp</I
></TT
> and returns it as an unsigned char cast 
to an int, or <CODE
CLASS="VARNAME"
>EOF</CODE
> on end-of-file or error.</P
><P
><TT
CLASS="FUNCTION"
>_IO_getc()</TT
> is not in the source standard; it is 
only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--IO-PUTC-3"
></A
>_IO_putc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6129"
></A
><H2
>Name</H2
>_IO_putc&nbsp;--&nbsp;alias for putc</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6132"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6135"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_putc</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__c</I
></TT
></I
></TT
>, _IO_FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__fp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6145"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_putc()</TT
> writes the character 
<TT
CLASS="PARAMETER"
><I
>__c</I
></TT
>, cast to an unsigned char, to 
<TT
CLASS="PARAMETER"
><I
>__fp</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>_IO_putc()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--IO-PUTS-3"
></A
>_IO_puts</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6159"
></A
><H2
>Name</H2
>_IO_puts&nbsp;--&nbsp;alias for puts</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6162"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6165"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_puts</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__c</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6172"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_puts()</TT
> writes the string <TT
CLASS="PARAMETER"
><I
>__s</I
></TT
> 
and a trailing newline to <CODE
CLASS="VARNAME"
>stdout</CODE
>.</P
><P
><TT
CLASS="FUNCTION"
>_IO_puts()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ASSERT-FAIL-1"
></A
>__assert_fail</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6186"
></A
><H2
>Name</H2
>__assert_fail&nbsp;--&nbsp;abort the program after false assertion</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6189"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6190"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>__assert_fail</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>assertion</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></I
></TT
>, unsigned int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>line</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>function</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6206"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__assert_fail()</TT
> function is used to
implement the <TT
CLASS="FUNCTION"
>assert()</TT
> interface of
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
The <TT
CLASS="FUNCTION"
>__assert_fail()</TT
> function 
shall print the given <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> filename,
<TT
CLASS="PARAMETER"
><I
>line</I
></TT
> line number, 
<TT
CLASS="PARAMETER"
><I
>function</I
></TT
> function name and a message
on the standard error stream in an unspecified format, and abort
program execution via the <TT
CLASS="FUNCTION"
>abort()</TT
> function.
For example:
<A
NAME="AEN6217"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>a.c:10: foobar: Assertion a == b failed.</P
></BLOCKQUOTE
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>function</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>, 
<TT
CLASS="FUNCTION"
>__assert_fail()</TT
> shall omit
information about the function.</P
><P
><TT
CLASS="PARAMETER"
><I
>assertion</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, and
<TT
CLASS="PARAMETER"
><I
>line</I
></TT
> shall be non-<TT
CLASS="LITERAL"
>NULL</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__assert_fail()</TT
> function
is not in the source standard; 
it is only in the binary standard.
The <TT
CLASS="FUNCTION"
>assert()</TT
> interface is not in the binary standard;
it is only in the source standard. The <TT
CLASS="FUNCTION"
>assert()</TT
> may
be implemented as a macro.</P
></DIV
><H1
><A
NAME="BASELIB---CTYPE-B-LOC"
></A
>__ctype_b_loc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6236"
></A
><H2
>Name</H2
>__ctype_b_loc&nbsp;--&nbsp;accessor function for __ctype_b array for ctype functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6239"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6242"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const unsigned short * *
    <TT
CLASS="FUNCTION"
>__ctype_b_loc</TT
>
  </CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6248"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_b_loc()</TT
>
function shall return a pointer into an array of
characters in the current locale that contains characteristics for each
character in the current character set. The array shall contain a total of 
<CODE
CLASS="CONSTANT"
>384</CODE
>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CODE
CLASS="CONSTANT"
>-128</CODE
> and 
<CODE
CLASS="CONSTANT"
>255</CODE
>). If the application is multithreaded, the 
array shall be local to the current thread. </P
><P
>This interface is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6258"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_b_loc()</TT
> function shall return a pointer
to the array of characters to be used for the <TT
CLASS="FUNCTION"
>ctype()</TT
>
family of functions (see <TT
CLASS="FILENAME"
>&#60;ctype.h&#62;</TT
>).</P
></DIV
><H1
><A
NAME="BASELIB---CTYPE-GET-MB-CUR-MAX-1"
></A
>__ctype_get_mb_cur_max</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6268"
></A
><H2
>Name</H2
>__ctype_get_mb_cur_max&nbsp;--&nbsp;maximum length of a multibyte character in the current locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6271"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6274"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>__ctype_get_mb_cur_max</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6279"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__ctype_get_mb_cur_max()</TT
> returns the maximum 
length of a multibyte character in the current locale.</P
><P
><TT
CLASS="FUNCTION"
>__ctype_get_mb_cur_max()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="LIBUTIL---CTYPE-TOLOWER-LOC"
></A
>__ctype_tolower_loc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6291"
></A
><H2
>Name</H2
>__ctype_tolower_loc&nbsp;--&nbsp;accessor function for __ctype_b_tolower array for ctype tolower() function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6294"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6297"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int32_t * *
  <TT
CLASS="FUNCTION"
>__ctype_tolower_loc</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6303"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_tolower_loc()</TT
>
function shall return a pointer into an array of
characters in the current locale that contains lower case equivalents for each
character in the current character set. The array shall contain a total of 
<CODE
CLASS="CONSTANT"
>384</CODE
>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CODE
CLASS="CONSTANT"
>-128</CODE
> and 
<CODE
CLASS="CONSTANT"
>255</CODE
>). If the application is multithreaded, the 
array shall be local to the current thread. </P
><P
>This interface is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6313"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_tolower_loc()</TT
> function shall return a pointer
to the array of characters to be used for the <TT
CLASS="FUNCTION"
>ctype()</TT
>
family of functions (see <TT
CLASS="FILENAME"
>&#60;ctype.h&#62;</TT
>).</P
></DIV
><H1
><A
NAME="LIBUTIL---CTYPE-TOUPPER-LOC"
></A
>__ctype_toupper_loc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6323"
></A
><H2
>Name</H2
>__ctype_toupper_loc&nbsp;--&nbsp;accessor function for <TT
CLASS="FUNCTION"
>__ctype_b_toupper()</TT
>
array for ctype <TT
CLASS="FUNCTION"
>toupper()</TT
> function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6328"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6331"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int32_t * *
  <TT
CLASS="FUNCTION"
>__ctype_toupper_loc</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6337"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_toupper_loc()</TT
>
function shall return a pointer into an array of
characters in the current locale that contains upper case equivalents for each
character in the current character set. The array shall contain a total of 
<CODE
CLASS="CONSTANT"
>384</CODE
>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CODE
CLASS="CONSTANT"
>-128</CODE
> and 
<CODE
CLASS="CONSTANT"
>255</CODE
>). If the application is multithreaded, the 
array shall be local to the current thread. </P
><P
>This interface is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6347"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_toupper_loc()</TT
> function shall return a pointer
to the array of characters to be used for the <TT
CLASS="FUNCTION"
>ctype()</TT
>
family of functions (see <TT
CLASS="FILENAME"
>&#60;ctype.h&#62;</TT
>).</P
></DIV
><H1
><A
NAME="BASELIB---CXA-ATEXIT"
></A
>__cxa_atexit</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6357"
></A
><H2
>Name</H2
>__cxa_atexit&nbsp;--&nbsp;register a function to be called by exit or when a shared library is unloaded</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6360"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6363"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__cxa_atexit</TT
></CODE
>(void (*func) 
  (void *), void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>, void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dso_handle</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6376"
></A
><H2
>Description</H2
><P
>As described in the <A
HREF="#STD.CXXABI"
>Itanium C++ ABI</A
>,
<TT
CLASS="FUNCTION"
>__cxa_atexit()</TT
> registers a destructor function to be called by 
<TT
CLASS="FUNCTION"
>exit()</TT
> or when a shared library is unloaded. 
When a shared library is unloaded, any destructor function associated with that
shared library, identified by <TT
CLASS="PARAMETER"
><I
>dso_handle</I
></TT
>, shall be called
with the single argument <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>, and then that function shall
be removed, or marked as complete, from the list of functions to run at 
<TT
CLASS="FUNCTION"
>exit()</TT
>.
On a call to <TT
CLASS="FUNCTION"
>exit()</TT
>,
any remaining functions registered shall be called 
with the single argument <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>.
Destructor functions shall always be called in the reverse order to their
registration (i.e. the most recently registered function shall be called first),</P
><P
>The <TT
CLASS="FUNCTION"
>__cxa_atexit()</TT
> function is used to implement
<TT
CLASS="FUNCTION"
>atexit()</TT
>, as described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
Calling <TT
CLASS="LITERAL"
>atexit(func)</TT
> from the statically linked part of
an application shall be equivalent to
<TT
CLASS="LITERAL"
>__cxa_atexit(func, NULL, NULL)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__cxa_atexit()</TT
> is not in the source standard; 
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><TT
CLASS="FUNCTION"
>atexit()</TT
> is not in the binary standard; 
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-DAYLIGHT-1"
></A
>__daylight</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6404"
></A
><H2
>Name</H2
>__daylight&nbsp;--&nbsp;daylight savings time flag</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6407"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int <CODE
CLASS="VARNAME"
>__daylight</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6410"
></A
><H2
>Description</H2
><P
>The integer variable <CODE
CLASS="VARNAME"
>__daylight</CODE
> 
shall implement the daylight savings time flag <CODE
CLASS="VARNAME"
>daylight</CODE
>
as specified in the 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> header file <TT
CLASS="FILENAME"
>&#60;time.h&#62;</TT
>.</P
><P
><CODE
CLASS="VARNAME"
>__daylight</CODE
> is not in the source standard;
it is only in the binary standard. <CODE
CLASS="VARNAME"
>daylight</CODE
>
is not in the binary standard; it is only in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB---ENVIRON"
></A
>__environ</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6424"
></A
><H2
>Name</H2
>__environ&nbsp;--&nbsp;alias for environ - user environment </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6427"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern char * *<CODE
CLASS="VARNAME"
>__environ</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6432"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>__environ</CODE
> is an alias for <CODE
CLASS="VARNAME"
>environ</CODE
>
- user environment.</P
><P
><CODE
CLASS="VARNAME"
>__environ</CODE
> has the same specification as 
<CODE
CLASS="VARNAME"
>environ</CODE
>.</P
><P
><CODE
CLASS="VARNAME"
>__environ</CODE
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB-ERRNO-LOCATION-1"
></A
>__errno_location</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6448"
></A
><H2
>Name</H2
>__errno_location&nbsp;--&nbsp;address of errno variable</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6451"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6454"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int *
  <TT
CLASS="FUNCTION"
>__errno_location</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6459"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__errno_location()</TT
> function shall return
the address of the <CODE
CLASS="VARNAME"
>errno</CODE
> variable for the current
thread.</P
><P
><TT
CLASS="FUNCTION"
>__errno_location()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FPENDING"
></A
>__fpending</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6472"
></A
><H2
>Name</H2
>__fpending&nbsp;--&nbsp;returns in bytes the amount of output pending on a stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6475"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6478"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>__fpending</TT
></CODE
>(FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>stream</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6485"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__fpending()</TT
> returns the amount of output in bytes 
pending on a stream.</P
><P
><TT
CLASS="FUNCTION"
>__fpending()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETPAGESIZE"
></A
>__getpagesize</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6497"
></A
><H2
>Name</H2
>__getpagesize&nbsp;--&nbsp;alias for getpagesize - get current page size </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6500"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6503"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__getpagesize</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6508"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__getpagesize()</TT
> is an alias for 
<TT
CLASS="FUNCTION"
>getpagesize()</TT
> - get current page size.</P
><P
><TT
CLASS="FUNCTION"
>__getpagesize()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>getpagesize()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__getpagesize()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETPGID-1"
></A
>__getpgid</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6524"
></A
><H2
>Name</H2
>__getpgid&nbsp;--&nbsp;get the process group id</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6527"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6530"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>pid_t 
  <TT
CLASS="FUNCTION"
>__getpgid</TT
></CODE
>(pid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pid</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6537"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__getpgid()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>getpgid()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__getpgid()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB-H-ERRNO-LOCATION-1"
></A
>__h_errno_location</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6550"
></A
><H2
>Name</H2
>__h_errno_location&nbsp;--&nbsp;address of h_errno variable</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6553"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6556"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int *
  <TT
CLASS="FUNCTION"
>__h_errno_location</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6561"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__h_errno_location()</TT
> returns the address of the 
<CODE
CLASS="VARNAME"
>h_errno</CODE
> variable, where <CODE
CLASS="VARNAME"
>h_errno</CODE
> 
is as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__h_errno_location()</TT
> is not in the source standard; 
it is only in the binary standard. Note that <CODE
CLASS="VARNAME"
>h_errno</CODE
> 
itself is only in the source standard; it is not in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISINF"
></A
>__isinf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6577"
></A
><H2
>Name</H2
>__isinf&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6580"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6581"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isinf</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6588"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isinf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isinf()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isinf()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__isinf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISINFF"
></A
>__isinff</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6601"
></A
><H2
>Name</H2
>__isinff&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6604"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6605"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isinff</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6612"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isinff()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isinf()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isinff()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__isinff()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISINFL"
></A
>__isinfl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6625"
></A
><H2
>Name</H2
>__isinfl&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6628"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6629"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isinfl</TT
></CODE
>(long double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6636"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isinfl()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isinf()</TT
> in the <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isinfl()</TT
> is known to be long double.</P
><P
><TT
CLASS="FUNCTION"
>__isinfl()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISNAN"
></A
>__isnan</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6649"
></A
><H2
>Name</H2
>__isnan&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6652"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6653"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isnan</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6660"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isnan()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isnan()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isnan()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__isnan()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISNANF"
></A
>__isnanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6673"
></A
><H2
>Name</H2
>__isnanf&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6676"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6677"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isnanf</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6684"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isnanf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isnan()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isnanf()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__isnanf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISNANL"
></A
>__isnanl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6697"
></A
><H2
>Name</H2
>__isnanl&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6700"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6701"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isnanl</TT
></CODE
>(long double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6708"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isnanl()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isnan()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isnanl()</TT
> is known to be long double.</P
><P
><TT
CLASS="FUNCTION"
>__isnanl()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---LIBC-CURRENT-SIGRTMAX-1"
></A
>__libc_current_sigrtmax</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6721"
></A
><H2
>Name</H2
>__libc_current_sigrtmax&nbsp;--&nbsp;return number of available real-time signal with lowest priority</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6724"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6727"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__libc_current_sigrtmax</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6732"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmax()</TT
> returns the number of 
an available real-time signal with the lowest priority.</P
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmax()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---LIBC-CURRENT-SIGRTMIN-1"
></A
>__libc_current_sigrtmin</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6744"
></A
><H2
>Name</H2
>__libc_current_sigrtmin&nbsp;--&nbsp;return number of available real-time signal with highest priority</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6747"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6750"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__libc_current_sigrtmin</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6755"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmin()</TT
> returns the number of 
an available real-time signal with the highest priority.</P
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmin()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---LIBC-START-MAIN-"
></A
>__libc_start_main</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6767"
></A
><H2
>Name</H2
>__libc_start_main&nbsp;--&nbsp;initialization routine</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6770"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6773"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>__libc_start_main</TT
></CODE
>(int *(main) 
               (int, char * *, char * *), int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * * 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ubp_av</I
></TT
></I
></TT
>, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (*
  <TT
CLASS="REPLACEABLE"
><I
>stack_end</I
></TT
>));</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6798"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__libc_start_main()</TT
> function shall
perform any necessary initialization of the execution
environment, call the <TT
CLASS="PARAMETER"
><I
>main</I
></TT
> function
with appropriate arguments, and handle the return from <TT
CLASS="FUNCTION"
>main()</TT
>. If the <TT
CLASS="FUNCTION"
>main()</TT
> function returns,
the return value shall be passed to the <TT
CLASS="FUNCTION"
>exit()</TT
> function.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>While this specification is intended to be implementation independent,
process and library initialization may include:
<P
></P
><UL
><LI
><P
>performing any necessary security checks if the effective user ID is
not the same as the real user ID.</P
></LI
><LI
><P
>initialize the threading subsystem.</P
></LI
><LI
><P
>registering the <TT
CLASS="PARAMETER"
><I
>rtld_fini</I
></TT
> to release resources when this
dynamic shared object exits (or is unloaded).</P
></LI
><LI
><P
>registering the <TT
CLASS="PARAMETER"
><I
>fini</I
></TT
> handler to run at program exit.</P
></LI
><LI
><P
>calling the initializer function <TT
CLASS="FUNCTION"
>(*<TT
CLASS="PARAMETER"
><I
>init</I
></TT
>)()</TT
>.</P
></LI
><LI
><P
>calling <TT
CLASS="FUNCTION"
>main()</TT
> with appropriate arguments.</P
></LI
><LI
><P
>calling <TT
CLASS="FUNCTION"
>exit()</TT
> with the return value from
<TT
CLASS="FUNCTION"
>main()</TT
>.</P
></LI
></UL
>
This list is an example only.</P
></BLOCKQUOTE
></DIV
></P
><P
><TT
CLASS="FUNCTION"
>__libc_start_main()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6834"
></A
><H2
>See Also</H2
><P
>The section on Process Initialization in each of 
the architecture specific supplements.</P
></DIV
><H1
><A
NAME="LIBUTIL---LXSTAT-2"
></A
>__lxstat</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6841"
></A
><H2
>Name</H2
>__lxstat&nbsp;--&nbsp;inline wrapper around call to lxstat</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6844"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6847"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__lxstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>version</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__path</I
></TT
></I
></TT
>, struct stat 
  <TT
CLASS="PARAMETER"
><I
>__statbuf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6860"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__lxstat()</TT
> is an inline wrapper around call to 
<TT
CLASS="FUNCTION"
>lxstat()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__lxstat()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MEMPCPY"
></A
>__mempcpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6873"
></A
><H2
>Name</H2
>__mempcpy&nbsp;--&nbsp;copy given number of bytes of source to destination</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6876"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6879"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ptr_t 
  <TT
CLASS="FUNCTION"
>__mempcpy</TT
></CODE
>(ptr_t restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const ptr_t restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6893"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__mempcpy()</TT
> copies <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> 
bytes of source to destination, returning pointer to bytes after 
the last written byte.</P
><P
><TT
CLASS="FUNCTION"
>__mempcpy()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---RAWMEMCHR"
></A
>__rawmemchr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6906"
></A
><H2
>Name</H2
>__rawmemchr&nbsp;--&nbsp;scan memory</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6909"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6912"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ptr_t 
  <TT
CLASS="FUNCTION"
>__rawmemchr</TT
></CODE
>(const ptr_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>c</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6923"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> searches in <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> 
for <TT
CLASS="PARAMETER"
><I
>c</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> is a weak alias to 
<TT
CLASS="FUNCTION"
>rawmemchr()</TT
>. It is similar to 
<TT
CLASS="FUNCTION"
>memchr()</TT
>, but it has no length limit. </P
><P
><TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--REGISTER-ATFORK"
></A
>__register_atfork</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6941"
></A
><H2
>Name</H2
>__register_atfork&nbsp;--&nbsp;alias for register_atfork</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6944"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6947"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__register_atfork</TT
></CODE
>(void
  (*<TT
CLASS="REPLACEABLE"
><I
>prepare</I
></TT
>)
(void), void
  (*<TT
CLASS="REPLACEABLE"
><I
>parent</I
></TT
>)
(void), void
  (*<TT
CLASS="REPLACEABLE"
><I
>child</I
></TT
>)
(void), void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__dso_handle</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6966"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__register_atfork()</TT
> implements
<TT
CLASS="FUNCTION"
>pthread_atfork()</TT
> as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
The additional parameter <TT
CLASS="PARAMETER"
><I
>__dso_handle</I
></TT
> allows a shared
object to pass in it's handle so that functions registered by
<TT
CLASS="FUNCTION"
>__register_atfork()</TT
> can be unregistered by the runtime when
the shared object is unloaded.</P
></DIV
><H1
><A
NAME="BASELIB---SIGSETJMP-1"
></A
>__sigsetjmp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN6980"
></A
><H2
>Name</H2
>__sigsetjmp&nbsp;--&nbsp;save stack context for non-local goto</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN6983"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN6984"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__sigsetjmp</TT
></CODE
>(jmp_buf 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>env</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>savemask</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN6994"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__sigsetjmp()</TT
> has the same behavior as 
<TT
CLASS="FUNCTION"
>sigsetjmp()</TT
> as specified by 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__sigsetjmp()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="LIBUTIL---STPCPY-2"
></A
>__stpcpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7006"
></A
><H2
>Name</H2
>__stpcpy&nbsp;--&nbsp;alias for stpcpy</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7009"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7012"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>__stpcpy</TT
></CODE
>(char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7023"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__stpcpy()</TT
> function has the same specification as
the <TT
CLASS="FUNCTION"
>stpcpy()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__stpcpy()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRDUP-1"
></A
>__strdup</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7036"
></A
><H2
>Name</H2
>__strdup&nbsp;--&nbsp;alias for strdup</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7039"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7042"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>__strdup</TT
></CODE
>(const char 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7049"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__strdup()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>strdup()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strdup()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOD-INTERNAL-1"
></A
>__strtod_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7062"
></A
><H2
>Name</H2
>__strtod_internal&nbsp;--&nbsp;underlying function for strtod</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7065"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7066"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double 
  <TT
CLASS="FUNCTION"
>__strtod_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7079"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtod_internal()</TT
> is undefined. </P
><P
><TT
CLASS="FUNCTION"
>__strtod_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)()</TT
> 
has the same specification as 
<TT
CLASS="FUNCTION"
>strtod(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>)()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtod_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB-STRTOF-INTERNAL-1"
></A
>__strtof_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7099"
></A
><H2
>Name</H2
>__strtof_internal&nbsp;--&nbsp;underlying function for strtof</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7102"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7103"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float 
  <TT
CLASS="FUNCTION"
>__strtof_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7116"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtof_internal()</TT
> is undefined. </P
><P
><TT
CLASS="FUNCTION"
>__strtof_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)()</TT
> 
has the same specification as 
<TT
CLASS="FUNCTION"
>strtof(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>)()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtof_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOK-R-1"
></A
>__strtok_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7136"
></A
><H2
>Name</H2
>__strtok_r&nbsp;--&nbsp;alias for strtok_r</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7139"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7142"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>__strtok_r</TT
></CODE
>(char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>delim</I
></TT
></I
></TT
>, char * * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>save_ptr</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7155"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__strtok_r()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>strtok_r()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtok_r()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOL-INTERNAL-1"
></A
>__strtol_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7168"
></A
><H2
>Name</H2
>__strtol_internal&nbsp;--&nbsp;alias for strtol</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7171"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7174"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long int 
  <TT
CLASS="FUNCTION"
>__strtol_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7190"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtol_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtol_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtol(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtol_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOLD-INTERNAL-1"
></A
>__strtold_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7214"
></A
><H2
>Name</H2
>__strtold_internal&nbsp;--&nbsp;underlying function for strtold</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7217"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7218"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double  
  <TT
CLASS="FUNCTION"
>__strtold_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7231"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtold_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtold_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
has the same specification as 
<TT
CLASS="LITERAL"
>strtold(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtold_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOLL-INTERNAL-1"
></A
>__strtoll_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7251"
></A
><H2
>Name</H2
>__strtoll_internal&nbsp;--&nbsp;underlying function for strtoll</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7254"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7255"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long 
  <TT
CLASS="FUNCTION"
>__strtoll_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7271"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtoll_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtoll_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtoll(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtoll_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB-STRTOUL-INTERNAL-1"
></A
>__strtoul_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7293"
></A
><H2
>Name</H2
>__strtoul_internal&nbsp;--&nbsp;underlying function for strtoul</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7296"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7297"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long int 
  <TT
CLASS="FUNCTION"
>__strtoul_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7313"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtoul_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtoul_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtoul(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtoul_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOULL-INTERNAL-1"
></A
>__strtoull_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7335"
></A
><H2
>Name</H2
>__strtoull_internal&nbsp;--&nbsp;underlying function for strtoull</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7338"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7339"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long 
  <TT
CLASS="FUNCTION"
>__strtoull_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7355"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtoull_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtoull_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtoull(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtoull_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SYSCONF"
></A
>__sysconf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7377"
></A
><H2
>Name</H2
>__sysconf&nbsp;--&nbsp;get configuration information at runtime</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7380"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7383"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long 
  <TT
CLASS="FUNCTION"
>__sysconf</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7391"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> gets configuration information at runtime.</P
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> is weak alias to 
<TT
CLASS="FUNCTION"
>sysconf()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>sysconf()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SYSV-SIGNAL-1"
></A
>__sysv_signal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7409"
></A
><H2
>Name</H2
>__sysv_signal&nbsp;--&nbsp;signal handling</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7412"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7415"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>__sighandler_t 
  <TT
CLASS="FUNCTION"
>__sysv_signal</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sig</I
></TT
></I
></TT
>, __sighandler_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>handler</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7425"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__sysv_signal()</TT
> has the same behavior as 
<TT
CLASS="FUNCTION"
>signal()</TT
> as specified by 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__sysv_signal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB-TIMEZONE-1"
></A
>__timezone</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7439"
></A
><H2
>Name</H2
>&nbsp;--&nbsp;global variable containing timezone</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7442"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>long int <CODE
CLASS="VARNAME"
>__timezone</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7445"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__timezone()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>timezone()</TT
> in the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
></P
></DIV
><H1
><A
NAME="BASELIB-TZNAME-1"
></A
>__tzname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7456"
></A
><H2
>Name</H2
>&nbsp;--&nbsp;global variable containing the timezone</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7459"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char * <CODE
CLASS="VARNAME"
>__tzname</CODE
>[2];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7462"
></A
><H2
>Description</H2
><P
><CODE
CLASS="CONSTANT"
>__tzname</CODE
> has the same specification as 
<CODE
CLASS="CONSTANT"
>tzname</CODE
> in the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>.</P
><P
>Note that the array size of <TT
CLASS="LITERAL"
>2</TT
> is explicit in the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>, but not in the
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV2"
>SUSv2</A
></I
>.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOD-INTERNAL-1"
></A
>__wcstod_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7479"
></A
><H2
>Name</H2
>__wcstod_internal&nbsp;--&nbsp;underlying function for wcstod</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7482"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7483"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double 
  <TT
CLASS="FUNCTION"
>__wcstod_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7496"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstod_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstod_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
shall behave as
<TT
CLASS="LITERAL"
>wcstod(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>)</TT
> as specified by
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstod_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOF-INTERNAL-1"
></A
>__wcstof_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7517"
></A
><H2
>Name</H2
>__wcstof_internal&nbsp;--&nbsp;underlying function for wcstof</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7520"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7521"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float 
  <TT
CLASS="FUNCTION"
>__wcstof_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7534"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstof_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstof_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
shall behave as
<TT
CLASS="LITERAL"
>wcstof(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>)</TT
> as specified in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstof_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOL-INTERNAL-1"
></A
>__wcstol_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7555"
></A
><H2
>Name</H2
>__wcstol_internal&nbsp;--&nbsp;underlying function for wcstol</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7558"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7559"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long 
  <TT
CLASS="FUNCTION"
>__wcstol_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7575"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstol_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstol_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>wcstol(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstol_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOLD-INTERNAL-1"
></A
>__wcstold_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7598"
></A
><H2
>Name</H2
>__wcstold_internal&nbsp;--&nbsp;underlying function for wcstold</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7601"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7602"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double 
  <TT
CLASS="FUNCTION"
>__wcstold_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7615"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstold_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstold_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
shall behave as
<TT
CLASS="LITERAL"
>wcstold(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstold_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOUL-INTERNAL-1"
></A
>__wcstoul_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7636"
></A
><H2
>Name</H2
>__wcstoul_internal&nbsp;--&nbsp;underlying function for wcstoul</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7639"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7640"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long 
  <TT
CLASS="FUNCTION"
>__wcstoul_internal</TT
></CODE
>(const wchar_t * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7656"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstoul_internal()</TT
> is undefined. </P
><P
><TT
CLASS="FUNCTION"
>__wcstoul_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)()</TT
> shall behave as
<TT
CLASS="FUNCTION"
>wcstoul(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>)()</TT
>
as specified by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstoul_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---XMKNOD-1"
></A
>__xmknod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7679"
></A
><H2
>Name</H2
>__xmknod&nbsp;--&nbsp;make block or character special file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7682"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7685"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__xmknod</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, mode_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
></I
></TT
>, dev_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dev</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7701"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__xmknod()</TT
> function shall implement the
<TT
CLASS="FUNCTION"
>mknod()</TT
> interface from <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
>The value of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> shall be <TT
CLASS="LITERAL"
>1</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__xmknod()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__xmknod(<TT
CLASS="LITERAL"
>1</TT
>, 
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>mknod(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__xmknod()</TT
> function is not in the source standard; 
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>mknod()</TT
> function is not in the binary standard; 
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-XSTAT-1"
></A
>__xstat</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7733"
></A
><H2
>Name</H2
>__xstat&nbsp;--&nbsp;get File Status</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7740"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7743"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/stat.h&#62;
#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__xstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__lxstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fxstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fildes</I
></TT
></I
></TT
>, struct stat *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7778"
></A
><H2
>Description</H2
><P
>The functions 
<TT
CLASS="FUNCTION"
>__xstat()</TT
>,
<TT
CLASS="FUNCTION"
>__lxstat()</TT
>, and
<TT
CLASS="FUNCTION"
>__fxstat()</TT
> shall implement
the <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> functions
<TT
CLASS="FUNCTION"
>stat()</TT
>,
<TT
CLASS="FUNCTION"
>lstat()</TT
>, and
<TT
CLASS="FUNCTION"
>fstat()</TT
> respectively.</P
><P
><TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> shall be <TT
CLASS="LITERAL"
>3</TT
> or the 
behavior of these functions is undefined. </P
><P
><TT
CLASS="LITERAL"
>__xstat(<TT
CLASS="LITERAL"
>3</TT
>, <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall implement
<TT
CLASS="LITERAL"
>stat(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="LITERAL"
>__lxstat(<TT
CLASS="LITERAL"
>3</TT
>, <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall implement
<TT
CLASS="LITERAL"
>lstat(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="LITERAL"
>__fxstat(<TT
CLASS="LITERAL"
>3</TT
>, <TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall implement
<TT
CLASS="LITERAL"
>fstat(<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__xstat()</TT
>, <TT
CLASS="FUNCTION"
>__lxstat()</TT
>, and 
<TT
CLASS="FUNCTION"
>__fxstat()</TT
> are not in the source standard; 
they are only in the binary standard.</P
><P
><TT
CLASS="FUNCTION"
>stat()</TT
>, <TT
CLASS="FUNCTION"
>lstat()</TT
>, and  
<TT
CLASS="FUNCTION"
>fstat()</TT
> are not in the binary standard; 
they are only in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB-XSTAT64-1"
></A
>__xstat64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7832"
></A
><H2
>Name</H2
>__xstat64&nbsp;--&nbsp;get File Status</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7847"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7850"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _LARGEFILE_SOURCE 1
#include &#60;sys/stat.h&#62;
#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__xstat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat64 *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__lxstat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat64 *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fxstat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fildes</I
></TT
></I
></TT
>, struct stat64 *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7885"
></A
><H2
>Description</H2
><P
>The functions 
<TT
CLASS="FUNCTION"
>__xstat64()</TT
>,
<TT
CLASS="FUNCTION"
>__lxstat64()</TT
>, and
<TT
CLASS="FUNCTION"
>__fxstat64()</TT
> shall implement
the <A
HREF="#STD.LFS"
>Large File Support</A
> functions
<TT
CLASS="FUNCTION"
>stat64()</TT
>,
<TT
CLASS="FUNCTION"
>lstat64()</TT
>, and
<TT
CLASS="FUNCTION"
>fstat64()</TT
> respectively.</P
><P
><TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> shall be <TT
CLASS="LITERAL"
>3</TT
> or the 
behavior of these functions is undefined. </P
><P
><TT
CLASS="LITERAL"
>__xstat64(<TT
CLASS="LITERAL"
>3</TT
>, <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>stat(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.LFS"
>Large File Support</A
>.</P
><P
><TT
CLASS="LITERAL"
>__lxstat64(<TT
CLASS="LITERAL"
>3</TT
>, <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>lstat(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.LFS"
>Large File Support</A
>.</P
><P
><TT
CLASS="LITERAL"
>__fxstat64(<TT
CLASS="LITERAL"
>3</TT
>, <TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>fstat(<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.LFS"
>Large File Support</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__xstat64()</TT
>, <TT
CLASS="FUNCTION"
>__lxstat64()</TT
>, and 
<TT
CLASS="FUNCTION"
>__fxstat64()</TT
> are not in the source standard; 
they are only in the binary standard.</P
><P
><TT
CLASS="FUNCTION"
>stat64()</TT
>, <TT
CLASS="FUNCTION"
>lstat64()</TT
>, and  
<TT
CLASS="FUNCTION"
>fstat64()</TT
> are not in the binary standard; 
they are only in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB--ENVIRON"
></A
>_environ</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7939"
></A
><H2
>Name</H2
>_environ&nbsp;--&nbsp;alias for environ - user environment </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7942"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern char * *<CODE
CLASS="VARNAME"
>_environ</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7947"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>_environ</CODE
> is an alias for 
<CODE
CLASS="VARNAME"
>environ</CODE
> - user environment.</P
></DIV
><H1
><A
NAME="BASELIB--NL-MSG-CAT-CNTR"
></A
>_nl_msg_cat_cntr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7958"
></A
><H2
>Name</H2
>_nl_msg_cat_cntr&nbsp;--&nbsp;new catalog load counter</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7961"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;libintl.h&#62;

extern int <CODE
CLASS="VARNAME"
>_nl_msg_cat_cntr</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7966"
></A
><H2
>Description</H2
><P
>The global variable
<CODE
CLASS="VARNAME"
>_nl_msg_cat_cntr</CODE
> is incremented each time a new
catalog is loaded. 
This variable is only in the binary standard; it is not in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB--SYS-ERRLIST"
></A
>_sys_errlist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7976"
></A
><H2
>Name</H2
>_sys_errlist&nbsp;--&nbsp;array containing the "C" locale strings used by strerror()</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7979"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;stdio.h&#62;

extern const char *const <CODE
CLASS="VARNAME"
>_sys_errlist</CODE
>[];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7984"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>_sys_errlist</CODE
> is an array containing the "C" locale 
strings used by <TT
CLASS="FUNCTION"
>strerror()</TT
>. This normally should not 
be used directly. <TT
CLASS="FUNCTION"
>strerror()</TT
> provides all of the 
needed functionality.</P
></DIV
><H1
><A
NAME="BASELIB--SYS-SIGLIST"
></A
>_sys_siglist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7996"
></A
><H2
>Name</H2
>_sys_siglist&nbsp;--&nbsp;array containing the names of the signal names</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7999"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;signal.h&#62;

extern const char *const <CODE
CLASS="VARNAME"
>_sys_siglist</CODE
>[NSIG];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8004"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>_sys_siglist</CODE
> is an array containing the names of 
the signal names.</P
><P
>The <CODE
CLASS="VARNAME"
>_sys_siglist</CODE
> array 
is only in the binary standard; it is not in the source standard.
Applications wishing to access the names of signals should use
the <TT
CLASS="FUNCTION"
>strsignal()</TT
> function.</P
></DIV
><H1
><A
NAME="BASELIB-ACCT-3"
></A
>acct</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8017"
></A
><H2
>Name</H2
>acct&nbsp;--&nbsp;switch process accounting on or off</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8020"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8023"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;dirent.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>acct</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8031"
></A
><H2
>Description</H2
><P
>When <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is the name of an existing file, 
<TT
CLASS="FUNCTION"
>acct()</TT
> turns accounting on and appends a record to
<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> for each terminating process. When
<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>,
<TT
CLASS="FUNCTION"
>acct()</TT
> turns accounting off.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8042"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8048"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8051"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOSYS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><ACRONYM
CLASS="ACRONYM"
>BSD</ACRONYM
> process accounting has not been enabled when 
the operating system kernel was compiled.  The kernel configuration 
parameter controlling this feature is 
<TT
CLASS="PARAMETER"
><I
>CONFIG_BSD_PROCESS_ACCT</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8057"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Out of memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8061"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The calling process has no permission to enable process accounting.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8065"
></A
><SPAN
STYLE="white-space: nowrap"
>EACCES</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is not a regular file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8070"
></A
><SPAN
STYLE="white-space: nowrap"
>EIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Error writing to the <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8075"
></A
><SPAN
STYLE="white-space: nowrap"
>EUSERS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There are no more free file structures or we run out of memory.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-ADJTIME-2"
></A
>adjtime</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8083"
></A
><H2
>Name</H2
>adjtime&nbsp;--&nbsp;correct the time to allow synchronization of the system clock</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8086"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8087"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;time.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>adjtime</TT
></CODE
>(const struct timeval *
  <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
>, struct timeval *
  <TT
CLASS="PARAMETER"
><I
>olddelta</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8096"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>adjtime()</TT
> makes small adjustments to the system time 
as returned by <TT
CLASS="FUNCTION"
>gettimeofday()</TT
>(2), advancing or retarding 
it by the time specified by the timeval <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
> is negative, the clock is slowed down 
by incrementing it more slowly than normal until the correction is complete. 
If <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
> is positive, a larger increment than
normal is used. The skew used to perform the correction is generally a
fraction of one percent. Thus, the time is always a monotonically
increasing function. A time correction from an earlier call to
<TT
CLASS="FUNCTION"
>adjtime()</TT
> may not be finished when 
<TT
CLASS="FUNCTION"
>adjtime()</TT
> is called again. If
<TT
CLASS="PARAMETER"
><I
>olddelta</I
></TT
> is non-<TT
CLASS="LITERAL"
>NULL</TT
>, the 
structure pointed to will contain, upon return, the number of microseconds 
still to be corrected from the earlier call.</P
><P
><TT
CLASS="FUNCTION"
>adjtime()</TT
> may be used by time servers that synchronize 
the clocks of computers in a local area network. Such time servers would 
slow down the clocks of some machines and speed up the clocks of others to 
bring them to the average network time.</P
><P
>Appropriate privilege is required to adjust the system time.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8111"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8117"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8120"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An argument points outside the process's allocated address space.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8124"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process does not have appropriate privilege.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-ASPRINTF"
></A
>asprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8132"
></A
><H2
>Name</H2
>asprintf&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8135"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8136"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>asprintf</TT
></CODE
>(char ** restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ptr</I
></TT
></I
></TT
>, const char * restrict
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8148"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>asprintf()</TT
> function shall behave as
<TT
CLASS="FUNCTION"
>sprintf()</TT
>, except that the output string
shall be dynamically allocated space of sufficient length to hold
the resulting string. The address of this dynamically allocated string
shall be stored in the location referenced by <TT
CLASS="PARAMETER"
><I
>ptr</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8154"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8158"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-BIND-TEXTDOMAIN-CODESET"
></A
>bind_textdomain_codeset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8166"
></A
><H2
>Name</H2
>bind_textdomain_codeset&nbsp;--&nbsp;specify encoding for message retrieval</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8169"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8172"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
   <TT
CLASS="FUNCTION"
>bind_textdomain_codeset</TT
>
  </CODE
>(const char *
     <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>
  , const char *
     <TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
>
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8181"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> function can be used to
specify the output codeset for message catalogs for domain 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>.  The <TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
>
argument shall be a valid codeset name which can be used tor the
<TT
CLASS="PARAMETER"
><I
>iconv_open</I
></TT
> function, or a null pointer.
If the <TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
> argument is the null pointer, then 
function returns the currently selected codeset for the domain with the name
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>.  It shall return a null pointer if no
codeset has yet been selected.</P
><P
>Each successive call to <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
>
function overrrides the
settings made by the preceding call with the same <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> function shall return 
a pointer to a string containing the name of the selected codeset. 
The string shall be allocated
internally in the function and shall not be changed or freed by the user.</P
><P
>The <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> function returns
a pointer to a string containing the name of the selected codeset. 
The string is allocated internally in the function and
shall not be changed by the user.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8199"
></A
><H2
>Parameters</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8202"
></A
><SPAN
STYLE="white-space: nowrap"
>domainname</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> argument 
to <TT
CLASS="PARAMETER"
><I
>textdomain</I
></TT
>, except that the selection of the 
domain is valid only for the duration of
the call.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8209"
></A
><SPAN
STYLE="white-space: nowrap"
>codeset</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of the output codeset for the selected domain, or NULL to select
the current codeset.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is the null pointer, or is an empty
string, <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> shall fail, but need not
set <CODE
CLASS="VARNAME"
>errno</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8217"
></A
><H2
>Return Value</H2
><P
>Returns the currently selected codeset name.  It returns a null
pointer if no codeset has yet been selected.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8220"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8223"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to allocate return value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8227"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain</P
></DIV
><H1
><A
NAME="BASELIB-BINDRESVPORT-3"
></A
>bindresvport</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8234"
></A
><H2
>Name</H2
>bindresvport&nbsp;--&nbsp;bind socket to privileged IP port</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8237"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8240"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;rpc/rpc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>bindresvport</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sd</I
></TT
></I
></TT
>, struct sockaddr_in *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sin</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8251"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege, the
<TT
CLASS="FUNCTION"
>bindresvport()</TT
> function shall bind
a socket to a privileged IP 
port.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8257"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8263"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8266"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EPERM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process did not have appropriate privilege.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8271"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EPFNOSUPPORT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
> did not match address family of
<TT
CLASS="PARAMETER"
><I
>sd</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-BINDTEXTDOMAIN"
></A
>bindtextdomain</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8282"
></A
><H2
>Name</H2
>bindtextdomain&nbsp;--&nbsp;specify the location of a message catalog</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8285"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8288"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>bindtextdomain</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8299"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> shall set the the base
directory of the hierarchy containing message catalogs for a given message
domain.</P
><P
>The <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> function specifies that the 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> message catalog can be found in the 
<TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> directory hierarchy, rather than in the 
system default locale data base.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> is not 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, the base directory for message catalogs 
belonging  to  domain 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> shall be set to 
<TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
the base directory for message catalogs shall not be altered.</P
><P
>The function shall make
copies of the argument strings as needed.</P
><P
><TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> can be an absolute or relative pathname.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Applications that wish to use <TT
CLASS="FUNCTION"
>chdir()</TT
>
should always use absolute pathnames to avoid misadvertently
selecting the wrong or non-existant directory.</P
></BLOCKQUOTE
></DIV
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is the null pointer, or is an empty
string, <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> shall fail, but need not
set <CODE
CLASS="VARNAME"
>errno</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> function shall return 
a pointer to a string containing the name of the selected directory. 
The string shall be allocated
internally in the function and shall not be changed or freed by the user.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8328"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> shall return a
pointer to a string containing the 
directory pathname currently bound to the domain. On failure, a 
<TT
CLASS="LITERAL"
>NULL</TT
> pointer is returned, and the global variable
<CODE
CLASS="VARNAME"
>errno</CODE
> may be set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8334"
></A
><H2
>Errors</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8338"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>ENOMEM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory was available.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8343"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-CFMAKERAW-3"
></A
>cfmakeraw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8350"
></A
><H2
>Name</H2
>cfmakeraw&nbsp;--&nbsp;get and set terminal attributes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8353"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8356"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;termios.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>cfmakeraw</TT
></CODE
>(struct termios *
   <TT
CLASS="PARAMETER"
><I
>termios_p</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8363"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>cfmakeraw()</TT
> function shall set the
attributes of the <TT
CLASS="STRUCTNAME"
>termios</TT
> structure referenced
by <TT
CLASS="PARAMETER"
><I
>termios_p</I
></TT
> as follows:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  termios_p-&#62;c_iflag &#38;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);

  termios_p-&#62;c_oflag &#38;= ~OPOST;

  termios_p-&#62;c_lflag &#38;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);

  termios_p-&#62;c_cflag &#38;= ~(CSIZE|PARENB);

  termios_p-&#62;c_cflag |= CS8;</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="PARAMETER"
><I
>termios_p</I
></TT
> shall point to a 
<TT
CLASS="STRUCTNAME"
>termios</TT
> structure that contains the 
following members:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  tcflag_t c_iflag;      /* input modes */
  tcflag_t c_oflag;      /* output modes */
  tcflag_t c_cflag;      /* control modes */
  tcflag_t c_lflag;      /* local modes */
  cc_t c_cc[NCCS];       /* control chars */</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="BASELIB-CFSETSPEED-3"
></A
>cfsetspeed</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8380"
></A
><H2
>Name</H2
>cfsetspeed&nbsp;--&nbsp;set terminal input and output data rate</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8383"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8386"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;termios.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>cfsetspeed</TT
></CODE
>(struct termios *<TT
CLASS="PARAMETER"
><I
>t</I
></TT
>, speed_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>speed</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8396"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>cfsetspeed()</TT
> sets the baud rate values in the 
<TT
CLASS="STRUCTNAME"
>termios</TT
> structure. The effects of the 
function on the terminal as described below do not become effective, 
nor are all errors detected, until the <TT
CLASS="FUNCTION"
>tcsetattr()</TT
> 
function is called. Certain values for baud rates set in 
<TT
CLASS="STRUCTNAME"
>termios</TT
> and passed to 
<TT
CLASS="FUNCTION"
>tcsetattr()</TT
> have special meanings.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN8406"
></A
><H3
>Getting and Setting the Baud Rate</H3
><P
>Input and output baud rates are found in the 
<TT
CLASS="STRUCTNAME"
>termios</TT
> structure. The unsigned integer 
<CODE
CLASS="STRUCTFIELD"
>speed_t</CODE
> is typdef'd in the include file 
<TT
CLASS="FILENAME"
>termios.h</TT
>. The value of the integer corresponds 
directly to the baud rate being represented; however, the following 
symbolic values are defined.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  #define B0      0
  #define B50     50
  #define B75     75
  #define B110    110
  #define B134    134
  #define B150    150
  #define B200    200
  #define B300    300
  #define B600    600
  #define B1200   1200
  #define B1800   1800
  #define B2400   2400
  #define B4800   4800
  #define B9600   9600
  #define B19200  19200
  #define B38400  38400
  #ifndef _POSIX_SOURCE
  #define EXTA    19200
  #define EXTB    38400
  #endif  /*_POSIX_SOURCE */</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="FUNCTION"
>cfsetspeed()</TT
> sets both the input and output baud 
rates in the <TT
CLASS="STRUCTNAME"
>termios</TT
> structure referenced by 
<CODE
CLASS="VARNAME"
>t</CODE
> to <TT
CLASS="PARAMETER"
><I
>speed</I
></TT
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8418"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8424"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8427"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid <TT
CLASS="PARAMETER"
><I
>speed</I
></TT
> argument</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-DAEMON-3"
></A
>daemon</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8436"
></A
><H2
>Name</H2
>daemon&nbsp;--&nbsp;run in the background</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8439"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8442"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>daemon</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nochdir</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>noclose</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8453"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>daemon()</TT
> function shall create a new process,
detached from the controlling terminal. If successful, the calling process
shall exit and the new process shall continue to execute the application
in the background.
If <TT
CLASS="PARAMETER"
><I
>nochdir</I
></TT
> evaluates to true, the current directory
shall not be changed. Otherwise, 
<TT
CLASS="FUNCTION"
>daemon()</TT
> shall change the current working directory 
to the root (`/'). If <TT
CLASS="PARAMETER"
><I
>noclose</I
></TT
> evaluates to true
the standard input, standard output, and standard error file
descriptors shall not be altered. Otherwise,
<TT
CLASS="FUNCTION"
>daemon()</TT
> shall close
the standard input, standard output and standard error file descriptors
and reopen them attached to 
<TT
CLASS="FILENAME"
>/dev/null</TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8464"
></A
><H2
>Return Value</H2
><P
>On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned, and the global 
variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set to any of the errors 
specified for the library functions <TT
CLASS="FUNCTION"
>fork()</TT
> and 
<TT
CLASS="FUNCTION"
>setsid()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-DCGETTEXT"
></A
>dcgettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8475"
></A
><H2
>Name</H2
>dcgettext&nbsp;--&nbsp;perform domain and category specific lookup in message catalog</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8478"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8481"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;
#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dcgettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8495"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dcgettext()</TT
> function
is a domain specified version 
of <TT
CLASS="FUNCTION"
>gettext()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>dcgettext()</TT
>
function shall lookup the translation in the current locale of the message
identified by <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> in the domain specified by 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> and in the locale
category specified by <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is NULL, the current default
domain shall be used. 
The <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> argument shall be a NULL-terminated 
string to be
matched in the catalogue. 
<TT
CLASS="PARAMETER"
><I
>category</I
></TT
> shall specify the locale category to be used
for retrieving message strings. 
The category parameter shall be one of <TT
CLASS="PARAMETER"
><I
>LC_CTYPE</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>LC_COLLATE</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MESSAGES</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MONETARY</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>LC_NUMERIC</I
></TT
>, 
or <TT
CLASS="PARAMETER"
><I
>LC_TIME</I
></TT
>. 
The default domain
shall not be changed by a call to <TT
CLASS="FUNCTION"
>dcgettext()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8517"
></A
><H2
>Return Value</H2
><P
>If a translation was found in one of the specified catalogs, it shall be
converted to the current locale's codeset and returned. The resulting
NULL-terminated string shall be allocated by the dcgettext function, and must
not be modified or freed. If no translation was found, or category was invalid,
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> shall be returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8521"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>dcgettext()</TT
> shall not modify the 
<CODE
CLASS="VARNAME"
>errno</CODE
> global variable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8526"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DCNGETTEXT"
></A
>dcngettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8533"
></A
><H2
>Name</H2
>dcngettext&nbsp;--&nbsp;perform domain and category specific lookup in message catalog
with plural</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8536"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8539"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;
#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dcngettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid2</I
></TT
></I
></TT
>, unsigned long int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8559"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dcngettext()</TT
> function is a domain specific version of 
gettext, capable of
returning either a singular or plural form of the message. 
The <TT
CLASS="FUNCTION"
>dcngettext()</TT
>
function shall lookup the translation in the current locale of the message
identified by <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>
in the domain specified by <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>
and in the locale
category specified by <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is NULL, the current default
domain shall be used. The <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>
argument shall be a NULL-terminated string to
be matched in the catalogue. <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>
shall specify the locale category to be
used for retrieving message strings. The <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>
parameter shall be one of
<TT
CLASS="PARAMETER"
><I
>LC_CTYPE</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_COLLATE</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MESSAGES</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MONETARY</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_NUMERIC</I
></TT
>, or 
<TT
CLASS="PARAMETER"
><I
>LC_TIME</I
></TT
>. 
The
default domain shall not be changed by a call to <TT
CLASS="FUNCTION"
>dcngettext()</TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is 1 then the
singular version of the message is returned, otherwise one of the plural forms
is returned, depending on the value of <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> and the current locale settings.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8582"
></A
><H2
>Return Value</H2
><P
>If a translation corresponding to the value of <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>
was found in one of the
specified catalogs for <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>, 
it shall be converted to the current locale's
codeset and returned. The resulting NULL-terminated string 
shall be allocated by
the <TT
CLASS="FUNCTION"
>dcngettext()</TT
> function, 
and must not be modified or freed. If no translation
was found, or <TT
CLASS="PARAMETER"
><I
>category</I
></TT
> was invalid, 
<TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
> shall be returned 
if <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> has the value
1, otherwise <TT
CLASS="PARAMETER"
><I
>msgid2</I
></TT
> shall be returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8592"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>dcngettext()</TT
> shall not modify the 
<CODE
CLASS="VARNAME"
>errno</CODE
> global variable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8597"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DGETTEXT"
></A
>dgettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8604"
></A
><H2
>Name</H2
>dgettext&nbsp;--&nbsp;perform lookup in message catalog for the current LC_MESSAGES locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8607"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8610"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dgettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8621"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dgettext()</TT
> is a domain specified version of 
<TT
CLASS="FUNCTION"
>gettext()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>dgettext()</TT
> function shall search the currently
selected message catalogs in the domain
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> for a string identified by the string
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>. If a string is located,
that string shall be returned.
The domain specified by <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> applies to the 
currently active
<TT
CLASS="SYMBOL"
>LC_MESSAGE</TT
> locale. The default domain shall not
be changed by a call to <TT
CLASS="FUNCTION"
>dgettext()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The usage of <TT
CLASS="PARAMETER"
><I
>domainanme</I
></TT
> is equivalent in 
syntax and meaning to the <TT
CLASS="FUNCTION"
>textdomain()</TT
> function's
application of <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>, except that the 
selection of the domain in <TT
CLASS="FUNCTION"
>dgettext()</TT
> 
is valid only for the duration of the call.</P
></BLOCKQUOTE
></DIV
>&#13;</P
><P
>The <TT
CLASS="FUNCTION"
>dgettext()</TT
> function is equivalent to
<TT
CLASS="LITERAL"
>dcgettext(domainname, msgid, LC_MESSAGES)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8644"
></A
><H2
>Return Value</H2
><P
>On success of a <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> query, the translated 
<TT
CLASS="LITERAL"
>NULL</TT
>-terminated string is returned. On error, the 
original <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> is returned. The length of the
string returned is undetermined until <TT
CLASS="FUNCTION"
>dgettext()</TT
>
is called.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8651"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>dgettext()</TT
> shall not modify the 
<CODE
CLASS="VARNAME"
>errno</CODE
> global variable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8656"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DNGETTEXT"
></A
>dngettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8663"
></A
><H2
>Name</H2
>dngettext&nbsp;--&nbsp;perform lookup in message catalog for the current locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8666"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8669"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dngettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid2</I
></TT
></I
></TT
>, unsigned long int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8686"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dngettext()</TT
> shall be equivalent to a call to
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES)</PRE
></TD
></TR
></TABLE
>
See <TT
CLASS="FUNCTION"
>dcngettext()</TT
>
for more information.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8694"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DUPLOCALE-3"
></A
>duplocale</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8701"
></A
><H2
>Name</H2
>duplocale&nbsp;--&nbsp;provide new handle for selection of locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8704"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8705"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>locale_t
<TT
CLASS="FUNCTION"
>duplocale</TT
></CODE
>(locale_t
<TT
CLASS="PARAMETER"
><I
>locale</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8712"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>duplocale()</TT
> function shall 
provide a new locale object based on the locale object provided
in <TT
CLASS="PARAMETER"
><I
>locale</I
></TT
>, suitable for use in the
<TT
CLASS="FUNCTION"
>newlocale()</TT
> or <TT
CLASS="FUNCTION"
>uselocale()</TT
> functions.
The new object may be released by calling <TT
CLASS="FUNCTION"
>freelocale()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8720"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>duplocale()</TT
> function shall return 
a locale object. Otherwise, it shall return
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, and set <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8726"
></A
><H2
>Errors</H2
><P
>The <TT
CLASS="FUNCTION"
>duplocale()</TT
> function shall fail if:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8731"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8736"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setlocale()</TT
>, <TT
CLASS="FUNCTION"
>freelocale()</TT
>, <TT
CLASS="FUNCTION"
>newlocale()</TT
>, <TT
CLASS="FUNCTION"
>uselocale()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-ERR-3"
></A
>err</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8752"
></A
><H2
>Name</H2
>err&nbsp;--&nbsp;display formatted error messages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8755"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8758"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>err</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>eval</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8770"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>err()</TT
> function
shall display a formatted error message on the standard
error stream.
First, <TT
CLASS="FUNCTION"
>err()</TT
> shall write
the last component of the program name, a colon
character, and a space character. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is non-NULL, it shall be used as a
format string for the <TT
CLASS="FUNCTION"
>printf()</TT
>
family of functions, and <TT
CLASS="FUNCTION"
>err()</TT
> shall
write the formatted message, a
colon character, and a space.
Finally,  the error message
string affiliated with the current value of the global variable 
<CODE
CLASS="VARNAME"
>errno</CODE
> shall be
written, followed by a newline character.</P
><P
>The <TT
CLASS="FUNCTION"
>err()</TT
> function shall not return, 
the program shall terminate with the exit value of <TT
CLASS="PARAMETER"
><I
>eval</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8784"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>error()</TT
>, <TT
CLASS="FUNCTION"
>errx()</TT
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8789"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8792"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-ERROR-N"
></A
>error</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8799"
></A
><H2
>Name</H2
>error&nbsp;--&nbsp;print error message</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8802"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8803"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>error</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>exitstatus</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>errnum</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8818"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>error()</TT
> shall print a message to standard error.</P
><P
><TT
CLASS="FUNCTION"
>error()</TT
> shall build the message from the following 
elements in their specified order:
<P
></P
><OL
TYPE="1"
><LI
><P
>the program name. If the application has provided a function named 
<TT
CLASS="FUNCTION"
>error_print_progname()</TT
>, <TT
CLASS="FUNCTION"
>error()</TT
> 
shall call this to supply the program name; 
otherwise, <TT
CLASS="FUNCTION"
>error()</TT
> 
uses the content of the global variable <CODE
CLASS="VARNAME"
>program_name</CODE
>.</P
></LI
><LI
><P
>the colon and space characters, then 
the result of using the printf-style <TT
CLASS="PARAMETER"
><I
>format</I
></TT
> 
and the optional arguments.</P
></LI
><LI
><P
>if <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
> is nonzero, 
<TT
CLASS="FUNCTION"
>error()</TT
> shall add the colon and 
space characters, then the result of 
<TT
CLASS="LITERAL"
>strerror(<CODE
CLASS="VARNAME"
>errnum</CODE
>)</TT
>.</P
></LI
><LI
><P
>a newline.</P
></LI
></OL
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>exitstatus</I
></TT
> is nonzero, 
<TT
CLASS="FUNCTION"
>error()</TT
> shall call
<TT
CLASS="LITERAL"
>exit(<CODE
CLASS="VARNAME"
>exitstatus</CODE
>)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8847"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>err()</TT
>, <TT
CLASS="FUNCTION"
>errx()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-ERRX-3"
></A
>errx</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8856"
></A
><H2
>Name</H2
>errx&nbsp;--&nbsp;display formatted error message and exit</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8859"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8862"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>errx</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>eval</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8874"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>errx()</TT
> function shall display a formatted error message on the 
standard error stream. The last component of the program name, a colon 
character, and a space shall be output. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is 
non-<TT
CLASS="LITERAL"
>NULL</TT
>, it shall be used as the format string
for the <TT
CLASS="FUNCTION"
>printf()</TT
> family of functions, and
the formatted error message, a colon 
character, and a space shall be output. The output shall be followed by a 
newline character.</P
><P
><TT
CLASS="FUNCTION"
>errx()</TT
> does not return, but shall exit with the value of 
<TT
CLASS="PARAMETER"
><I
>eval</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8886"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8889"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8892"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>error()</TT
>, <TT
CLASS="FUNCTION"
>err()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-FCNTL-3"
></A
>fcntl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8901"
></A
><H2
>Name</H2
>fcntl&nbsp;--&nbsp;file control</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8904"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fcntl()</TT
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN8909"
></A
><H3
>Implementation may set <CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
></H3
><P
>According to <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
only an application sets
<TT
CLASS="FUNCTION"
>fcntl()</TT
> flags, for example 
<CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
>. However, this specification
also allows an implementation to set the <CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
> 
flag in the case where the programming environment is one of
<CODE
CLASS="CONSTANT"
>_POSIX_V6_ILP32_OFFBIG</CODE
>, <CODE
CLASS="CONSTANT"
>_POSIX_V6_LP64_OFF64</CODE
>, <CODE
CLASS="CONSTANT"
>_POSIX_V6_LPBIG_OFFBIG</CODE
>. See <B
CLASS="COMMAND"
>getconf</B
> and <B
CLASS="COMMAND"
>c99</B
>
in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
for a description of these environments.
Thus, calling <TT
CLASS="FUNCTION"
>fcntl()</TT
> with the 
<TT
CLASS="PARAMETER"
><I
>F_GETFL</I
></TT
> command may return 
<CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
> as well as flags explicitly 
set by the application in the case that both the implementation and 
the application support an <SPAN
CLASS="TYPE"
>off_t</SPAN
> of at least 64 bits.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-FFLUSH-UNLOCKED-1"
></A
>fflush_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8935"
></A
><H2
>Name</H2
>fflush_unlocked&nbsp;--&nbsp;non thread safe fflush</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8940"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fflush_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fflush()</TT
> except that it need not be thread safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FGETWC-UNLOCKED-1"
></A
>fgetwc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8950"
></A
><H2
>Name</H2
>fgetwc_unlocked&nbsp;--&nbsp;non thread safe fgetwc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8955"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fgetwc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fgetwc()</TT
> except that it need not be thread safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FLOCK-2"
></A
>flock</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8965"
></A
><H2
>Name</H2
>flock&nbsp;--&nbsp;apply or remove an advisory lock on an open file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8968"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8971"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>flock</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>operation</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8981"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>flock()</TT
> applies or removes an advisory 
lock on the open file <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>. Valid 
<TT
CLASS="PARAMETER"
><I
>operation</I
></TT
> types are:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8990"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_SH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shared lock. More than one process may hold a shared lock for a given file at a given time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8994"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_EX</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Exclusive lock. Only one process may hold an exclusive lock for a given file at a given time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN8998"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_UN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unlock.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9002"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_NB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Don't block when locking. May be specified (by 
<I
CLASS="EMPHASIS"
>or</I
>ing) along with one of 
the other operations.</P
></TD
></TR
></TBODY
></TABLE
><P
>A single file may not simultaneously have both shared and exclusive locks.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9008"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9014"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9017"
></A
><SPAN
STYLE="white-space: nowrap"
>EWOULDBLOCK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is locked and the <TT
CLASS="LITERAL"
>LOCK_NB</TT
> flag was selected.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-FREELOCALE-3"
></A
>freelocale</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9026"
></A
><H2
>Name</H2
>freelocale&nbsp;--&nbsp;free a locale object</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9029"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9030"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>freelocale</TT
></CODE
>(locale_t
<TT
CLASS="PARAMETER"
><I
>locale</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9037"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>freelocale()</TT
> function shall free
the locale object <TT
CLASS="PARAMETER"
><I
>locale</I
></TT
>, and release any
resources associated with it.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9042"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9045"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9048"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setlocale()</TT
>, <TT
CLASS="FUNCTION"
>newlocale()</TT
>, <TT
CLASS="FUNCTION"
>duplocale()</TT
>, <TT
CLASS="FUNCTION"
>uselocale()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-FSCANF"
></A
>fscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9064"
></A
><H2
>Name</H2
>fscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9067"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9072"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-FWSCANF"
></A
>fwscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9090"
></A
><H2
>Name</H2
>fwscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9093"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9098"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-GETGROUPLIST-3"
></A
>getgrouplist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9116"
></A
><H2
>Name</H2
>getgrouplist&nbsp;--&nbsp;get network group entry</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9119"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9120"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getgrouplist</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>user</I
></TT
>, gid_t
<TT
CLASS="PARAMETER"
><I
>group</I
></TT
>, gid_t *
<TT
CLASS="PARAMETER"
><I
>groups</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9133"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getgrouplist()</TT
> function shall
fill in the array <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> with 
the supplementary groups for the user specified
by <TT
CLASS="PARAMETER"
><I
>user</I
></TT
>. On entry, 
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> shall refer to an integer
containing the maximum number of <SPAN
CLASS="TYPE"
>gid_t</SPAN
>
members in the <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> array.
The group <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall also be included.
On success, the value referred to by <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
>
shall be updated to contain the number of <SPAN
CLASS="TYPE"
>gid_t</SPAN
>
objects copied.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9147"
></A
><H2
>Return Value</H2
><P
>On success, if there was sufficient room to copy all the
supplementatry group identifiers to the array
identified by <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
>, 
<TT
CLASS="FUNCTION"
>getgrouplist()</TT
> shall return the number of 
<SPAN
CLASS="TYPE"
>gid_t</SPAN
> objects copied, and the value referenced by
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> shall be updated.
If there was not sufficient room to copy all the supplementary
group identifiers, <TT
CLASS="FUNCTION"
>grouplist()</TT
> shall return
<CODE
CLASS="CONSTANT"
>-1</CODE
>, and update the value referenced
by <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> to the number actually copied.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>user</I
></TT
> does not refer to a valid
user on the system, <TT
CLASS="FUNCTION"
>getgrouplist()</TT
> shall
return <CODE
CLASS="CONSTANT"
>0</CODE
>, and set the value referenced by
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> to <CODE
CLASS="CONSTANT"
>0</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9163"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9166"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>getgroups()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-GETLOADAVG-3"
></A
>getloadavg</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9174"
></A
><H2
>Name</H2
>getloadavg&nbsp;--&nbsp;get system load averages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9177"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9180"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getloadavg</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>loadavg</I
></TT
>[]</I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nelem</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9191"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getloadavg()</TT
> returns the number of processes in 
the system run queue averaged over various periods of time. Up to 
<TT
CLASS="PARAMETER"
><I
>nelem</I
></TT
> samples are retrieved and assigned to 
successive elements of <TT
CLASS="PARAMETER"
><I
>loadavg</I
></TT
>[]. The system 
imposes a maximum of <TT
CLASS="LITERAL"
>3</TT
> samples, representing 
averages over the last <TT
CLASS="LITERAL"
>1</TT
>, <TT
CLASS="LITERAL"
>5</TT
>, 
and <TT
CLASS="LITERAL"
>15</TT
> minutes, respectively.</P
></DIV
><H1
><A
NAME="LIBUTIL-GETOPT-3"
></A
>getopt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9207"
></A
><H2
>Name</H2
>getopt&nbsp;--&nbsp;parse command line options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9212"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9215"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getopt</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * const 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argv</I
></TT
>[]</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>optstring</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern char <CODE
CLASS="VARNAME"
>*optarg</CODE
>;
extern int <CODE
CLASS="VARNAME"
>optind</CODE
>, <CODE
CLASS="VARNAME"
>opterr</CODE
>, <CODE
CLASS="VARNAME"
>optopt</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9234"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getopt()</TT
> function shall parse command line arguments
as described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, with the following exceptions,
where LSB and POSIX specifications vary.
LSB systems shall
implement the modified behaviors described below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN9241"
></A
><H3
>Argument Ordering</H3
><P
>The <TT
CLASS="FUNCTION"
>getopt()</TT
> function can process command line arguments
referenced by <TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> in one of three ways:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9247"
></A
><SPAN
STYLE="white-space: nowrap"
>PERMUTE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the order of arguments in
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> is altered so that all options (and
their arguments) are moved in front of all of the operands.
This is the default behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This behavior has undefined results if 
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> is not modifiable. This is to support
historic behavior predating the use of <SPAN
CLASS="TOKEN"
>const</SPAN
> and
<A
HREF="#STD.ISOC99"
>ISO C (1999)</A
>. The function prototype was aligned
with <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> despite the fact that it modifies
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
>, 
and the library maintainers are unwilling to change this.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9259"
></A
><SPAN
STYLE="white-space: nowrap"
>REQUIRE_ORDER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The arguments in
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> are processed in exactly the order
given, and option processing stops when the first non-option argument
is reached, or when the element of argv is "--". This ordering
can be enforced either by setting the environment variable
<CODE
CLASS="VARNAME"
>POSIXLY_CORRECT</CODE
>, or by setting the first character
of <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> to '+'.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9266"
></A
><SPAN
STYLE="white-space: nowrap"
>RETURN_IN_ORDER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The order of arguments
is not altered, and all arguments are processed. Non-option arguments
(operands) are handled as if they were the argument to an option with
the value 1 ('\001'). This ordering is selected by setting the first
character of <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> to '-';</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN9271"
></A
><H3
>Option Characteristics</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>an element of <TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> that starts with 
"<SPAN
CLASS="TOKEN"
>-</SPAN
>" (and is not exactly "<SPAN
CLASS="TOKEN"
>-</SPAN
>" or 
"<SPAN
CLASS="TOKEN"
>--</SPAN
>") is an option element.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>characters of an option element, aside from the initial 
"<SPAN
CLASS="TOKEN"
>-</SPAN
>", are option characters.</P
></LI
></UL
></P
><P
><I
CLASS="EMPHASIS"
>POSIX</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>applications using <TT
CLASS="FUNCTION"
>getopt()</TT
> shall obey the following 
syntax guidelines:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>option name is a single alphanumeric character from the portable character set</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>option is preceded by the '<SPAN
CLASS="TOKEN"
>-</SPAN
>' delimiter character</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>options without option-arguments should be accepted when grouped behind 
one '<SPAN
CLASS="TOKEN"
>-</SPAN
>' delimiter</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>each option and option-argument is a separate argument</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>option-arguments are not optional</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>all options should precede operands on the command line</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>the argument "<SPAN
CLASS="TOKEN"
>--</SPAN
>" is accepted as a delimiter 
indicating the end of options and the consideration of subsequent 
arguments, if any, as operands</P
></LI
></UL
></P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>historical implementations of <TT
CLASS="FUNCTION"
>getopt()</TT
> support 
other characters as options as an allowed extension, but applications 
that use extensions are not maximally portable.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>support for multi-byte option characters is only possible when such 
characters can be represented as type <TT
CLASS="LITERAL"
>int</TT
>.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>applications that call any utility with a first operand starting with 
'<SPAN
CLASS="TOKEN"
>-</SPAN
>' should usually specify "<SPAN
CLASS="TOKEN"
>--</SPAN
>" 
to mark the end of the options. Standard utilities that do not support 
this guideline indicate that fact in the OPTIONS section of the utility 
description.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN9319"
></A
><H3
>Extensions</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>if a character is followed by two colons, the option takes an optional 
argument; if there is text in the current <TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> element, 
it is returned in <TT
CLASS="PARAMETER"
><I
>optarg</I
></TT
>, otherwise 
<TT
CLASS="PARAMETER"
><I
>optarg</I
></TT
> is set to <TT
CLASS="LITERAL"
>0</TT
>.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>if <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> contains <TT
CLASS="LITERAL"
>W</TT
> followed 
by a semi-colon (<SPAN
CLASS="TOKEN"
>;</SPAN
>),
then <TT
CLASS="LITERAL"
>-W foo</TT
> is treated as the 
long option <TT
CLASS="LITERAL"
>--foo</TT
>. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>See <TT
CLASS="FUNCTION"
>getopt_long()</TT
> for a description
of long options.</P
></BLOCKQUOTE
></DIV
></P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The first character of <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> shall modify 
the behavior of <TT
CLASS="FUNCTION"
>getopt()</TT
> as follows:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>if the first character is '+', then 
<CODE
CLASS="CONSTANT"
>REQUIRE_ORDER</CODE
> processing shall be in
effect (see above)</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>if the first character is '-', then 
<CODE
CLASS="CONSTANT"
>RETURN_IN_ORDER</CODE
> processing shall be in
effect (see above)</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>if the first character is ':', then 
<TT
CLASS="FUNCTION"
>getopt()</TT
> shall return ':' instead of '?'
to indicate a missing option argument, and shall not print any
diagnostic message to <CODE
CLASS="VARNAME"
>stderr</CODE
>.</P
></LI
></UL
></P
></LI
></UL
></P
><P
><I
CLASS="EMPHASIS"
>POSIX</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>the <CODE
CLASS="OPTION"
>-W</CODE
> option is reserved for implementation extensions.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN9361"
></A
><H3
>Return Values</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies the following additional
<TT
CLASS="FUNCTION"
>getopt()</TT
> return values:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
><SPAN
CLASS="RETURNVALUE"
>'\001'</SPAN
> is returned
if <CODE
CLASS="CONSTANT"
>RETURN_IN_ORDER</CODE
> argument ordering is in effect,
and the next argument is an operand, not an option. The argument is
available in <CODE
CLASS="VARNAME"
>optarg</CODE
>.</P
></LI
></UL
>
Any other return value has the same meaning as for
<I
CLASS="EMPHASIS"
>POSIX</I
>.</P
><P
><I
CLASS="EMPHASIS"
>POSIX</I
> specifies the following 
<TT
CLASS="FUNCTION"
>getopt()</TT
> return values:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>the next option character is returned, if found successfully.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>'<SPAN
CLASS="RETURNVALUE"
>:</SPAN
>' is returned if a parameter is missing for 
one of the options and the first character of <CODE
CLASS="VARNAME"
>optstring</CODE
> is 
'<SPAN
CLASS="TOKEN"
>:</SPAN
>'.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>'<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>' is returned if an unknown option 
character not in <CODE
CLASS="VARNAME"
>optstring</CODE
> is encountered, or if 
<TT
CLASS="FUNCTION"
>getopt()</TT
> detects a missing argument and the first 
character of <CODE
CLASS="VARNAME"
>optstring</CODE
> is not '<SPAN
CLASS="TOKEN"
>:</SPAN
>'.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
><SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned for the end of the option list.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN9394"
></A
><H3
>Environment Variables</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>if the variable <CODE
CLASS="VARNAME"
>POSIXLY_CORRECT</CODE
> is set, option 
processing stops as soon as a non-option argument is encountered.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>the variable <CODE
CLASS="VARNAME"
>_<TT
CLASS="REPLACEABLE"
><I
>[PID]</I
></TT
>_GNU_nonoption_argv_flags_</CODE
>
(where <TT
CLASS="REPLACEABLE"
><I
>[PID]</I
></TT
> is the process ID for the 
current process), contains a space separated list of arguments that should
not be treated as arguments even though they appear to be so.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>This was 
used by bash 2.0 to communicate to <I
CLASS="EMPHASIS"
>GNU</I
> libc which 
arguments resulted from wildcard expansion and so should not be 
considered as options. This behavior was removed in bash version 
2.01, but the support remains in <I
CLASS="EMPHASIS"
>GNU</I
> libc.</P
></BLOCKQUOTE
></DIV
>
This behavior is DEPRECATED in this version of the LSB; future revisions
of this specification may not include this requirement.</P
></LI
></UL
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-GETOPT-LONG-3"
></A
>getopt_long</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9416"
></A
><H2
>Name</H2
>getopt_long&nbsp;--&nbsp;parse command line options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9419"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9422"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;getopt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getopt_long</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * const 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argv</I
></TT
>[]</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>opstring</I
></TT
></I
></TT
>, const struct option *
  <TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>longindex</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9441"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long()</TT
> works like <TT
CLASS="FUNCTION"
>getopt()</TT
> 
except that it also accepts long options, started out by two dashes. 
Long option names may be abbreviated if the abbreviation is unique or 
is an exact match for some defined option. A long option may take a 
parameter, of the form <TT
CLASS="LITERAL"
>--arg=param</TT
> or 
<TT
CLASS="LITERAL"
>--arg param</TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
> is a pointer to the first element of an 
array of struct <TT
CLASS="STRUCTNAME"
>option</TT
> declared in 
<TT
CLASS="FILENAME"
>getopt.h</TT
> as:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  struct option {
             const char *name;
             int has_arg;
             int *flag;
             int val;
  };</PRE
></TD
></TR
></TABLE
></P
><P
>The fields in this structure have the following meaning:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9457"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of the long option.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9462"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>has_arg</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of: 
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>no_argument</CODE
> (or 0) if the option does not take an argument,</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>required_argument</CODE
> (or 1) if the option requires an argument,  or</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>optional_argument</CODE
>  (or  2) if the option takes an optional argument.</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9474"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>flag</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies how results are returned for a long option.   
If  flag
is  <CODE
CLASS="CONSTANT"
>NULL</CODE
>,  then  
<TT
CLASS="FUNCTION"
>getopt_long()</TT
> shall return <CODE
CLASS="STRUCTFIELD"
>val</CODE
>.
(For example, the
calling program may set val to the equivalent short option character.)
Otherwise, <TT
CLASS="FUNCTION"
>getopt_long()</TT
> returns 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>, and <CODE
CLASS="STRUCTFIELD"
>flag</CODE
> shall point to
a variable which shall be set to <CODE
CLASS="STRUCTFIELD"
>val</CODE
>
if the option is found, but left unchanged if the option is not found.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9486"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>val</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The value to return, or to load into the variable pointed to
by flag.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9491"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long()</TT
> returns the option character if a short 
option was found successfully, or "<SPAN
CLASS="RETURNVALUE"
>:</SPAN
>" if 
there was a missing parameter for one of the options, or 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an unknown option character, or 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> for the end of the option list.</P
><P
>For a long option, 
<TT
CLASS="FUNCTION"
>getopt_long()</TT
> returns <CODE
CLASS="STRUCTFIELD"
>val</CODE
> 
if <CODE
CLASS="STRUCTFIELD"
>flag</CODE
> is <TT
CLASS="LITERAL"
>NULL</TT
>, and <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> 
otherwise. Error and <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> returns are the 
same as for <TT
CLASS="FUNCTION"
>getopt()</TT
>, plus 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an ambiguous match or an 
extraneous parameter.</P
></DIV
><H1
><A
NAME="BASELIB-GETOPT-LONG-ONLY-3"
></A
>getopt_long_only</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9511"
></A
><H2
>Name</H2
>getopt_long_only&nbsp;--&nbsp;parse command line options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9514"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9517"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;getopt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getopt_long_only</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * const 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argv</I
></TT
>[]</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>optstring</I
></TT
></I
></TT
>, const struct option *
  <TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>longindex</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9536"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> is like 
<TT
CLASS="FUNCTION"
>getopt_long()</TT
>, but "<SPAN
CLASS="TOKEN"
>-</SPAN
>" as well as 
"<SPAN
CLASS="TOKEN"
>--</SPAN
>" can indicate a long option. If an option that 
starts with "<SPAN
CLASS="TOKEN"
>-</SPAN
>" (not "<SPAN
CLASS="TOKEN"
>--</SPAN
>") doesn't 
match a long option, but does match a short option, it is parsed as 
a short option instead.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> function is intended only
for supporting certain programs whose command line syntax was designed
before the Utility Syntax Guidelines of <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
were developed.  New programs should generally call
<TT
CLASS="FUNCTION"
>getopt_long()</TT
> instead, which provides the --option
syntax for long options, which is preferred by GNU and consistent with
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9553"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> returns the option character if the 
option was found successfully, or "<SPAN
CLASS="RETURNVALUE"
>:</SPAN
>" if 
there was a missing parameter for one of the options, or 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an unknown option character, or 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> for the end of the option list.</P
><P
><TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> also returns the option character 
when a short option is recognized. For a long option, they return val 
if flag is <TT
CLASS="LITERAL"
>NULL</TT
>, and <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> 
otherwise. Error and <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> returns are the 
same as for <TT
CLASS="FUNCTION"
>getopt()</TT
>, plus 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an ambiguous match or an 
extraneous parameter.</P
></DIV
><H1
><A
NAME="BASELIB-GETSOCKOPT-1"
></A
>getsockopt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9571"
></A
><H2
>Name</H2
>getsockopt&nbsp;--&nbsp;get socket options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9576"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9577"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;
#include &#60;netinet/ip.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getsockopt</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>socket</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
>, void * restrict
<TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>, socklen_t * restrict
<TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9592"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getsockopt()</TT
> function shall behave as specified in 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>, 
with the following extensions.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN9598"
></A
><H3
>IP Protocol Level Options</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> parameter is 
<CODE
CLASS="CONSTANT"
>IPPROTO_IP</CODE
>, the following values shall be supported for
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
> (see <A
HREF="#STD.RFC791"
>RFC 791:Internet Protocol</A
> for
further details):
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9606"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_OPTIONS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the Internet Protocol options sent with
every packet from this socket. 
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a
memory buffer in which the options shall be placed; 
on entry <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall point to an integer value
indicating the maximum size of the memory buffer, in bytes. On successful
return, the value referenced by <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall
be updated to the size of data copied to the buffer. For IPv4, the
maximum length of options is 40 bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9614"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TTL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the current unicast Internet Protocol
Time To Live value used when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a buffer large
enough to hold the time to live value (at least 1 byte),
and <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>
shall point to an integer value holding the maximum size of that buffer.
On successful return, the value
referenced by <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall be updated
to contain the number of bytes copied into the buffer, which shall be no
larger than the initial value,
and <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>
shall point to an integer containing the time to live value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9623"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TOS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the Internet Protocol type of service indicator
used when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a buffer large
enough to hold the type of service indicator (at least 1 byte),
and <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>
shall point to an integer value holding the maximum size of that buffer.
On successful return, the value
referenced by <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall be updated
to contain the number of bytes copied into the buffer, which shall be no
larger than the initial value,
and <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>
shall point to an integer containing the time to live value.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-GETTEXT"
></A
>gettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9636"
></A
><H2
>Name</H2
>gettext&nbsp;--&nbsp;search message catalogs for a string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9639"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9642"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>gettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9650"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gettext()</TT
> function shall search the currently 
selected message catalogs for a string identified by the string
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>. If a string is located, 
that string shall be returned.</P
><P
>The <TT
CLASS="FUNCTION"
>gettext()</TT
> function is equivalent to
<TT
CLASS="LITERAL"
>dcgettext(NULL, msgid, LC_MESSAGES)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9660"
></A
><H2
>Return Value</H2
><P
>If a string is found in the currently selected message catalogs for
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>, then a pointer to that string shall be returned.
Otherwise, a pointer to <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> shall be returned.</P
><P
>Applications shall not modify the string returned by <TT
CLASS="FUNCTION"
>gettext()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9667"
></A
><H2
>Errors</H2
><P
>None.</P
><P
>The <TT
CLASS="FUNCTION"
>gettext()</TT
> function shall not modify 
<CODE
CLASS="VARNAME"
>errno</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9673"
></A
><H2
>See Also</H2
><P
>dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-GETUTENT-3"
></A
>getutent</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9680"
></A
><H2
>Name</H2
>getutent&nbsp;--&nbsp;access user accounting database entries	</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9683"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9686"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct utmp
  *<TT
CLASS="FUNCTION"
>getutent</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9692"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getutent()</TT
> function shall read the
next entry from the user accounting database.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9698"
></A
><H2
>Return Value</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>getutent()</TT
>
shall return a 
pointer to a <TT
CLASS="STRUCTNAME"
>utmp</TT
> structure containing a copy
of the requested entry in the user accounting database.
Otherwise, a null pointer shall be returned. The return value may point
to a static area which is overwritten by a subsequent call to
<TT
CLASS="FUNCTION"
>getutent()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9704"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="BASELIB-GETUTENT-R-3"
></A
>getutent_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9711"
></A
><H2
>Name</H2
>getutent_r&nbsp;--&nbsp;access user accounting database entries</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9714"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9717"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getutent_r</TT
></CODE
>(struct utmp *
  <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, struct utmp **
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9725"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getutent_r()</TT
> function is a reentrant version of the 
<TT
CLASS="FUNCTION"
>getutent()</TT
> function.
On entry, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> should point to a user supplied
buffer to which the next entry in the database will be copied, and
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> should point to a location where the
result will be stored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9734"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>getutent_r()</TT
> shall return 0 and set
the location referenced by <TT
CLASS="PARAMETER"
><I
>result</I
></TT
> to a pointer
to <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>. Otherwise, <TT
CLASS="FUNCTION"
>getutent_r()</TT
>
shall return <CODE
CLASS="CONSTANT"
>-1</CODE
> and set the location referenced
by <TT
CLASS="PARAMETER"
><I
>result</I
></TT
> to <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB-GLOB64"
></A
>glob64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9748"
></A
><H2
>Name</H2
>glob64&nbsp;--&nbsp;find pathnames matching a pattern  (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9751"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9754"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;glob.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>glob64</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>, int 
  (*<TT
CLASS="REPLACEABLE"
><I
>errfunc</I
></TT
>) 
  (const char *, int), glob64_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pglob</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9772"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>glob64()</TT
> function is a large-file
version of the <TT
CLASS="FUNCTION"
>glob()</TT
> defined in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
It shall search for pathnames matching
<TT
CLASS="PARAMETER"
><I
>pattern</I
></TT
> according to the rules used by
the shell, <TT
CLASS="FILENAME"
>/bin/sh</TT
>.
No tilde expansion or parameter substitution is done; see
<TT
CLASS="FUNCTION"
>wordexp()</TT
>.</P
><P
>The results of a <TT
CLASS="FUNCTION"
>glob64()</TT
>
call are stored in the structure pointed to by <TT
CLASS="PARAMETER"
><I
>pglob</I
></TT
>,
which is a <CODE
CLASS="VARNAME"
>glob64_t</CODE
> declared in 
<TT
CLASS="FILENAME"
>glob.h</TT
> with the following members:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>typedef struct
{
  size_t <CODE
CLASS="STRUCTFIELD"
>gl_pathc</CODE
>;
  char **<CODE
CLASS="STRUCTFIELD"
>gl_pathv</CODE
>;
  size_t <CODE
CLASS="STRUCTFIELD"
>gl_offs</CODE
>;
  int <CODE
CLASS="STRUCTFIELD"
>gl_flags</CODE
>;
  void (*<CODE
CLASS="STRUCTFIELD"
>gl_closedir</CODE
>) (void *);
  struct dirent64 *(*<CODE
CLASS="STRUCTFIELD"
>gl_readdir64</CODE
>) (void *);
  void *(*<CODE
CLASS="STRUCTFIELD"
>gl_opendir</CODE
>) (const char *);
  int (*<CODE
CLASS="STRUCTFIELD"
>gl_lstat</CODE
>) (const char *, struct stat *);
  int (*<CODE
CLASS="STRUCTFIELD"
>gl_stat</CODE
>) (const char *, struct stat *);
}
glob64_t;</PRE
></TD
></TR
></TABLE
></P
><P
>Structure members with the same name as corresponding members of a 
<CODE
CLASS="VARNAME"
>glob_t</CODE
> as
defined in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> shall have the same purpose.</P
><P
>Other members are defined as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9803"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_flags</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reserved for internal use</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9808"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_closedir</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of closing a directory opened by 
<CODE
CLASS="STRUCTFIELD"
>gl_opendir</CODE
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9814"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_readdir64</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of reading entries in a large 
directory</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9819"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_opendir</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of opening a large directory</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9824"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_stat</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of returning file status 
for a large file</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9829"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_lstat</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of returning file status 
information for a large file or symbolic link</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>A large file or large directory is one with a size which cannot be
represented by a variable of type <SPAN
CLASS="TYPE"
>off_t</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9836"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. Other possible 
returns are:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9841"
></A
><SPAN
STYLE="white-space: nowrap"
>GLOB_NOSPACE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>out of memory</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9845"
></A
><SPAN
STYLE="white-space: nowrap"
>GLOB_ABORTED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>read error</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9849"
></A
><SPAN
STYLE="white-space: nowrap"
>GLOB_NOMATCH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no match found</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-GLOBFREE64"
></A
>globfree64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9857"
></A
><H2
>Name</H2
>globfree64&nbsp;--&nbsp;free memory from glob64() (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9860"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9863"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;glob.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>globfree64</TT
></CODE
>(glob64_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pglob</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9871"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>globfree64()</TT
> frees the dynamically allocated 
storage from an earlier call to <TT
CLASS="FUNCTION"
>glob64()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>globfree64()</TT
> is a 64-bit version of 
<TT
CLASS="FUNCTION"
>globfree()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-INITGROUPS-3"
></A
>initgroups</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9885"
></A
><H2
>Name</H2
>initgroups&nbsp;--&nbsp;initialize the supplementary group access list</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9888"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9889"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;
#include &#60;sys/types.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>initgroups</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
></I
></TT
>, gid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9900"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege,
the <TT
CLASS="FUNCTION"
>initgroups()</TT
> function shall initialize the 
Supplementary Group IDs for the current process
by reading the group database and using all groups of which 
<TT
CLASS="PARAMETER"
><I
>user</I
></TT
> is a member. The additional group 
<TT
CLASS="PARAMETER"
><I
>group</I
></TT
> is also added to the list.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9906"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9912"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9915"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The calling process does not have sufficient privileges.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9919"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory to allocate group information structure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9923"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setgroups()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-IOCTL-2"
></A
>ioctl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9931"
></A
><H2
>Name</H2
>ioctl&nbsp;--&nbsp;control device</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9934"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9937"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ioctl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>ioctl</TT
>
 </CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fildes</I
></TT
></I
></TT
>
 , int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>request</I
></TT
></I
></TT
>
 , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9949"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ioctl()</TT
> function shall manipulate the underlying device 
parameters of special files. <TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> shall be 
an open file descriptor referring to a special file.
The <TT
CLASS="FUNCTION"
>ioctl()</TT
> function shall take three parameters;
the type and value of the third parameter 
is dependent on the device and <TT
CLASS="PARAMETER"
><I
>request</I
></TT
>.</P
><P
>Conforming LSB applications shall not call <TT
CLASS="FUNCTION"
>ioctl()</TT
> 
except in situations explicitly stated in this specification.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9960"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
An <TT
CLASS="FUNCTION"
>ioctl()</TT
> may use the return value as an
output parameter and return a non-negative value on success. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9967"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9970"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EBADF</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> is not a valid descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9976"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EFAULT</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The third parameter references an inaccessible memory area.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9981"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOTTY</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> is not associated with a character special device.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9987"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOTTY </SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified request does not apply to the kind of object that
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> references.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN9993"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EINVAL </SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>request</I
></TT
> or the third parameter is not valid.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9999"
></A
><H2
>Relationship to POSIX (Informative)</H2
><P
>It should be noted that <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> contains an interface 
named <TT
CLASS="FUNCTION"
>ioctl()</TT
>. The LSB only defines behavior when
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> refers to a socket 
(see <A
HREF="#BASELIB-SOCKIO-2"
>sockio</A
>)
or terminal device
(see <A
HREF="#BASELIB-TTYIO-2"
>ttyio</A
>), while 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> only defines behavior when 
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> refers to a STREAMS device. An implementation
may support both behaviors; the LSB does not require any STREAMS support.</P
></DIV
><H1
><A
NAME="BASELIB-SOCKIO-2"
></A
>sockio</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10013"
></A
><H2
>Name</H2
>sockio&nbsp;--&nbsp;socket ioctl commands</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10016"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10019"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ioctl.h&#62;
#include &#60;sys/socket.h&#62;
#include &#60;net/if.h&#62;
#include &#60;netinet/in.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>ioctl</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sockfd</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>request</I
></TT
></I
></TT
>, void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10033"
></A
><H2
>Description</H2
><P
>Socket <TT
CLASS="FUNCTION"
>ioctl()</TT
> commands are a subset of the 
<TT
CLASS="FUNCTION"
>ioctl()</TT
> calls, which can perform a variety of 
functions on sockets. <TT
CLASS="PARAMETER"
><I
>sockfd</I
></TT
> shall be an
open file descriptor referring to a socket (see the
<TT
CLASS="FUNCTION"
>socket()</TT
> or <TT
CLASS="FUNCTION"
>accept()</TT
> functions).</P
><P
>Socket <TT
CLASS="FUNCTION"
>ioctl()</TT
> commands apply to the underlying 
network interfaces, and affect the entire system, not just the file 
descriptor used to issue the <TT
CLASS="FUNCTION"
>ioctl()</TT
>.</P
><P
>The following values for <TT
CLASS="PARAMETER"
><I
>request</I
></TT
>
are accepted:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFCONF</TT
> (Deprecated)</DT
><DD
><P
>Get the interface configuration list for the system.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="SYMBOL"
>SIOCGIFCONF</TT
> interface is
superceded by the 
<TT
CLASS="FUNCTION"
>if_nameindex()</TT
> family of functions (see
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>).
A future version of this specification may withdraw this value
for <TT
CLASS="PARAMETER"
><I
>request</I
></TT
>.</P
></BLOCKQUOTE
></DIV
>
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifconf</TT
> structure, as described in
<TT
CLASS="FILENAME"
>&#60;net/if.h&#62;</TT
>. Before calling, the caller 
shall set the
<CODE
CLASS="STRUCTFIELD"
>ifc_ifcu.ifcu_req</CODE
> field 
to point to an array of <TT
CLASS="STRUCTNAME"
>ifreq</TT
> structures, and 
set <CODE
CLASS="STRUCTFIELD"
>ifc_len</CODE
> to the size in bytes of this allocated 
array. Upon return, <CODE
CLASS="STRUCTFIELD"
>ifc_len</CODE
> 
will contain the size in bytes of the array which was actually used.
If it is the same as the length upon calling, the caller 
should assume that the array was too small and try again with a 
larger array.</P
><P
>On success, <TT
CLASS="SYMBOL"
>SIOCGIFCONF</TT
> shall return a nonnegative value.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Historical UNIX systems disagree on the meaning of the return value.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFFLAGS</TT
></DT
><DD
><P
>Get the interface flags for the indicated interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a 
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_flags</CODE
> field is set 
with the interface flags.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFADDR</TT
></DT
><DD
><P
>Get the interface address for the given interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_addr</CODE
> field is set 
with the interface address.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFBRDADDR</TT
></DT
><DD
><P
>Get the interface broadcast address for the given interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_broadcast</CODE
> field is set 
with the interface broadcast address.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFNETMASK</TT
></DT
><DD
><P
>Get the network mask for the given interface. 
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_netmask</CODE
> field is set 
with the network mask.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFMTU</TT
></DT
><DD
><P
>Get the Maximum Transmission Unit (MTU) size for the given interface. 
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_mtu</CODE
> field is set 
with the MTU.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>FIONREAD</TT
></DT
><DD
><P
>Get the amount of queued unread data in the receive buffer.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to an integer where the result is to be placed.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Some implementations may also support the use of <TT
CLASS="SYMBOL"
>FIONREAD</TT
>
on other types of file descriptor. However, the LSB only specifies its behavior for a socket
related file descriptor.</P
></BLOCKQUOTE
></DIV
></P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10126"
></A
><H2
>Return Value</H2
><P
>On success, if <TT
CLASS="PARAMETER"
><I
>request</I
></TT
> is
<SPAN
CLASS="TOKEN"
>SIOCGIFCONF</SPAN
>, a non-negative integer shall be returned.
If request is not <SPAN
CLASS="TOKEN"
>SIOCGIFCONF</SPAN
>, on success 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10135"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10138"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>sockfd</I
></TT
> is not a valid descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10143"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> references an inaccessible memory area.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10148"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTTY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified <TT
CLASS="PARAMETER"
><I
>request</I
></TT
> does not apply to the kind of 
object that the descriptor <TT
CLASS="PARAMETER"
><I
>sockfd</I
></TT
> references.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10154"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Either <TT
CLASS="PARAMETER"
><I
>request</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
>
is invalid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10160"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTCONN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The operation is only defined on a connected socket, but the socket wasn't
connected.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-TTYIO-2"
></A
>ttyio</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10168"
></A
><H2
>Name</H2
>ttyio&nbsp;--&nbsp;tty ioctl commands</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10171"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10174"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ioctl.h&#62;
#include &#60;fcntl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>ioctl</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, unsigned long 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>request</I
></TT
></I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10188"
></A
><H2
>Description</H2
><P
>Tty <I
CLASS="EMPHASIS"
>ioctl</I
> commands are a subset of the 
<TT
CLASS="FUNCTION"
>ioctl()</TT
> calls, which can perform a variety of 
functions on tty devices. <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> shall be 
an open file descriptor referring to a terminal device.</P
><P
>The following <TT
CLASS="FUNCTION"
>ioctl()</TT
>s are provided:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10199"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="SYMBOL"
>TIOCGWINSZ</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the size attributes of the terminal or pseudo-terminal identified by
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>. On entry, <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall reference
a <TT
CLASS="STRUCTNAME"
>winsize</TT
> structure.
On return, the structure will have 
<CODE
CLASS="STRUCTFIELD"
>ws_row</CODE
> set to the number of rows of text (i.e. lines of text)
that can be viewed on the device, and
<CODE
CLASS="STRUCTFIELD"
>ws_col</CODE
> set to the number of columns (i.e. text width).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The number of columns stored in <CODE
CLASS="STRUCTFIELD"
>ws_col</CODE
>
assumes that the terminal device is using a mono-spaced font.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10212"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10218"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10221"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is not a valid descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10226"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> references an inaccessible memory area.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10231"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>request</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> are not valid.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-KILL-3"
></A
>kill</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10241"
></A
><H2
>Name</H2
>kill&nbsp;--&nbsp;send a signal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10244"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10245"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>kill</TT
></CODE
>(pid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pid</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sig</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10256"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>kill()</TT
> is as specified in the
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN10262"
></A
><H3
>Process ID -1 doesn't affect calling process</H3
><P
>If <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> is specified as <TT
CLASS="LITERAL"
>-1</TT
>,
<TT
CLASS="PARAMETER"
><I
>sig</I
></TT
> shall not be sent to the calling process.
Other than this, the rules in the <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
> apply.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>This was a deliberate Linus decision after an unpopular experiment in
including the calling process in the 2.5.1 kernel.  See "What does it
mean to signal everybody?", Linux Weekly News, 20 December 2001,
<A
HREF="http://lwn.net/2001/1220/kernel.php3"
TARGET="_top"
>http://lwn.net/2001/1220/kernel.php3</A
></P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-LINK-1"
></A
>link</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10278"
></A
><H2
>Name</H2
>link&nbsp;--&nbsp;create a link to a file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10283"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10284"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>link</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>path1</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>path2</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10293"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>link()</TT
> function shall behave as specified in 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>, 
except with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN10299"
></A
><H3
>Need Not Follow Symlinks</H3
><P
>&#13;<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> specifies that pathname resolution
shall follow symbolic links during pathname resolution unless the
function is required to act on the symbolic link itself, or certain 
arguments direct that the function act on the symbolic link itself. The
<TT
CLASS="FUNCTION"
>link()</TT
> function in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
contains no such requirement to operate on a symbolic link. 
However, a conforming
LSB implementation need not follow a symbolic link 
for the <TT
CLASS="PARAMETER"
><I
>path1</I
></TT
> argument. </P
></DIV
></DIV
><H1
><A
NAME="BASELIB-MBSNRTOWCS-3"
></A
>mbsnrtowcs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10310"
></A
><H2
>Name</H2
>mbsnrtowcs&nbsp;--&nbsp;convert a multibyte string to a wide character string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10313"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10316"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>mbsnrtowcs</TT
></CODE
>(wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nms</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>len</I
></TT
></I
></TT
>, mbstate_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ps</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10336"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>mbsnrtowcs()</TT
> is like <TT
CLASS="FUNCTION"
>mbsrtowcs()</TT
>, 
except that the number of bytes to be converted, starting at 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, is limited to <TT
CLASS="PARAMETER"
><I
>nms</I
></TT
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is not a 
<TT
CLASS="LITERAL"
>NULL</TT
> pointer, <TT
CLASS="FUNCTION"
>mbsnrtowcs()</TT
> 
converts at most <TT
CLASS="PARAMETER"
><I
>nms</I
></TT
> bytes from the multibyte 
string <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> to a wide-character string starting 
at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. At most, <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> 
wide characters are written to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. The  
state <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> is updated.</P
><P
>The conversion is effectively performed by repeatedly calling:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
> 
mbrtowc(dest, *src, n, ps)</PRE
></TD
></TR
></TABLE
>
where <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is some positive number, as long as this 
call succeeds, and then incrementing <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> by one 
and <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> by the number of bytes consumed.</P
><P
>The conversion can stop for three reasons:</P
><P
><P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>An invalid multibyte sequence has been encountered. In this case 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> is left pointing to the invalid multibyte 
sequence, (size_t)(-1) is returned, and <CODE
CLASS="VARNAME"
>errno</CODE
> is 
set to <SPAN
CLASS="ERRORNAME"
>EILSEQ</SPAN
>.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The <TT
CLASS="PARAMETER"
><I
>nms</I
></TT
> limit forces a stop, or 
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> non-<SPAN
CLASS="TOKEN"
>L'\0'</SPAN
> wide characters 
have been stored at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. In this case, 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> is left pointing to the next multibyte 
sequence to be converted, and the number of wide characters written 
to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is returned.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The multibyte string has been completely converted, including the 
terminating <SPAN
CLASS="TOKEN"
>'\0'</SPAN
> (which has the side effect of bringing 
back <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> to the initial state). In this case, 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> is set to <TT
CLASS="LITERAL"
>NULL</TT
>, and the 
number of wide characters written to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, 
excluding the terminating <SPAN
CLASS="TOKEN"
>L'\0'</SPAN
> character, is returned.</P
></LI
></UL
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>, 
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> is ignored, and the conversion proceeds 
as above, except that the converted wide characters are not written 
out to memory, and that no destination length limit exists.</P
><P
>In both of the above cases, if <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> is a 
<TT
CLASS="LITERAL"
>NULL</TT
> pointer, a static anonymous state only known 
to <TT
CLASS="FUNCTION"
>mbsnrtowcs()</TT
> is used instead.</P
><P
>The programmer shall ensure that there is room for at least 
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> wide characters at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10395"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>mbsnrtowcs()</TT
> returns the number of wide characters 
that make up the converted part of the wide character string, not 
including the terminating null wide character. If an invalid multibyte 
sequence was encountered, (size_t)(-1) is returned, and the global
variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set to <SPAN
CLASS="ERRORNAME"
>EILSEQ</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10401"
></A
><H2
>Notes</H2
><P
>The behavior of <TT
CLASS="FUNCTION"
>mbsnrtowcs()</TT
> depends on the 
<CODE
CLASS="VARNAME"
>LC_CTYPE</CODE
> category of the current locale.</P
><P
>Passing <SPAN
CLASS="TOKEN"
>NULL</SPAN
> as <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> is not 
multi-thread safe.</P
></DIV
><H1
><A
NAME="BASELIB-MEMMEM-3"
></A
>memmem</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10413"
></A
><H2
>Name</H2
>memmem&nbsp;--&nbsp;locate bytes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10416"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10419"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
  <TT
CLASS="FUNCTION"
>memmem</TT
></CODE
>(const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>haystack</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>haystacklen</I
></TT
></I
></TT
>, const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>needle</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>needlelen</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10436"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>memmem()</TT
> finds the start of the first 
occurrence of the byte array referenced by 
<TT
CLASS="PARAMETER"
><I
>needle</I
></TT
> 
of length <TT
CLASS="PARAMETER"
><I
>needlelen</I
></TT
> in the memory 
area <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
> of length 
<TT
CLASS="PARAMETER"
><I
>haystacklen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10446"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>memmem()</TT
> returns a pointer to the beginning 
of the byte array, or <TT
CLASS="LITERAL"
>NULL</TT
> if the byte array 
is not found.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10451"
></A
><H2
>Notes</H2
><P
>Earlier versions of the C library (prior to glibc 2.1) contained a
<TT
CLASS="FUNCTION"
>memmem()</TT
> with various problems, and application
developers should treat this function with care.</P
></DIV
><H1
><A
NAME="BASELIB-MEMRCHR"
></A
>memrchr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10459"
></A
><H2
>Name</H2
>memrchr&nbsp;--&nbsp;scan memory for a character</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10462"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10463"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
  <TT
CLASS="FUNCTION"
>memrchr</TT
></CODE
>(const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>c</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10477"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>memrchr()</TT
> function shall locate the last
occurence of <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> (converted to an unsigned char)
in the initial <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> bytes (each interpreted as
an unsigned char) of the object pointed to by
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10484"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>memrchr()</TT
> shall return a pointer to the located
byte, or a null pointer if the byte does not occur in the object.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10488"
></A
><H2
>Errors</H2
><P
>No errors are defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10491"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>memchr()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-NEWLOCALE-3"
></A
>newlocale</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10499"
></A
><H2
>Name</H2
>newlocale&nbsp;--&nbsp;allocate a locale object</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10502"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10503"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>locale_t
<TT
CLASS="FUNCTION"
>newlocale</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>category_mask</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>locale</I
></TT
>, locale_t
<TT
CLASS="PARAMETER"
><I
>base</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10514"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>newlocale()</TT
> function shall initialize
a locale object. If <TT
CLASS="PARAMETER"
><I
>base</I
></TT
> is 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, then <TT
CLASS="FUNCTION"
>newlocale()</TT
>
shall first allocate the object; otherwise it shall use the locale
object referenced by <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>.</P
><P
>The object shall be initialized for the locale named
by <TT
CLASS="PARAMETER"
><I
>locale</I
></TT
>, and for the categories selected
in <TT
CLASS="PARAMETER"
><I
>category_mask</I
></TT
>. The 
<TT
CLASS="PARAMETER"
><I
>category_mask</I
></TT
> value is a bitwise
inclusive OR of the required 
<TT
CLASS="LITERAL"
>LC_<TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>_MASK</TT
>
values, or the value <CODE
CLASS="CONSTANT"
>LC_ALL_MASK</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10529"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>newlocale()</TT
> function shall return 
the initialized locale object. Otherwise, it shall return
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, and set <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10535"
></A
><H2
>Errors</H2
><P
>The <TT
CLASS="FUNCTION"
>newlocale()</TT
> function shall fail if:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10540"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10545"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EINVAL</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An invalid <TT
CLASS="PARAMETER"
><I
>category_mask</I
></TT
> was provided, or
the <TT
CLASS="PARAMETER"
><I
>locale</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10553"
></A
><H2
>Application Usage (Informative)</H2
><P
>The only portable way to allocate a locale object is to call
<TT
CLASS="FUNCTION"
>newlocale()</TT
> with a <CODE
CLASS="CONSTANT"
>NULL</CODE
>
<TT
CLASS="PARAMETER"
><I
>base</I
></TT
>. The allocated object may be reinitialized
to a new locale by passing it back to <TT
CLASS="FUNCTION"
>newlocale()</TT
>.
The new object may be released by calling <TT
CLASS="FUNCTION"
>freelocale()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10561"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setlocale()</TT
>, <TT
CLASS="FUNCTION"
>freelocale()</TT
>, <TT
CLASS="FUNCTION"
>duplocale()</TT
>, <TT
CLASS="FUNCTION"
>uselocale()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-NGETTEXT"
></A
>ngettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10577"
></A
><H2
>Name</H2
>ngettext&nbsp;--&nbsp;search message catalogs for plural string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10580"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10583"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>ngettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid2</I
></TT
></I
></TT
>, unsigned long int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10597"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ngettext()</TT
> function shall search the currently 
selected message catalogs for a string matching the singular string
<TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>. If a string is located, and if
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is 1, that string shall be returned.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is not 1, a pluralized version
(dependent on <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>) of the string shall be returned.</P
><P
>The <TT
CLASS="FUNCTION"
>ngettext()</TT
> function is equivalent to
<TT
CLASS="FUNCTION"
>dcngettext(NULL, msgid1, msgid2, n, LC_MESSAGES)()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10610"
></A
><H2
>Return Value</H2
><P
>If a string is found in the currently selected message catalogs for
<TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>, then if <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is
<CODE
CLASS="CONSTANT"
>1</CODE
> a pointer to the located string shall be returned.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is not <CODE
CLASS="CONSTANT"
>1</CODE
>, a pointer to an
appropriately pluralized version of the string shall be returned.
If no message could be found in the currently selected mesage catalogs,
then if <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is <CODE
CLASS="CONSTANT"
>1</CODE
>,
a pointer to <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
> shall be returned, otherwise
a pointer to <TT
CLASS="PARAMETER"
><I
>msgid2</I
></TT
> shall be returned.</P
><P
>Applications shall not modify the string returned by <TT
CLASS="FUNCTION"
>ngettext()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10624"
></A
><H2
>Errors</H2
><P
>None.</P
><P
>The <TT
CLASS="FUNCTION"
>ngettext()</TT
> function shall not modify 
<CODE
CLASS="VARNAME"
>errno</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10630"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-PMAP-GETPORT-3"
></A
>pmap_getport</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10637"
></A
><H2
>Name</H2
>pmap_getport&nbsp;--&nbsp;find the port number assigned to a service registered with a
portmapper.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10640"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10643"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/pmap_clnt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>u_short *
  <TT
CLASS="FUNCTION"
>pmap_getport</TT
></CODE
>(struct sockaddr_in *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>address</I
></TT
></I
></TT
>, const u_long
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>program</I
></TT
></I
></TT
>, const u_long *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>version</I
></TT
></I
></TT
>, u_int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>protocol</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10660"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function shall
return the port number assigned to a service registered with a
RPC Binding service running on a given target system,
using the protocol described in
<A
HREF="#STD.RFC1833"
>RFC 1833: Binding Protocols for ONC RPC Version 2</A
>.
The <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function shall be called given the
RPC program number <TT
CLASS="PARAMETER"
><I
>program</I
></TT
>,
the program version <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, and transport
protocol <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
>. Conforming implementations shall
support both <CODE
CLASS="CONSTANT"
>IPPROTO_UDP</CODE
> and 
<CODE
CLASS="CONSTANT"
>IPPROTO_TCP</CODE
> protocols. On entry,
<TT
CLASS="PARAMETER"
><I
>address</I
></TT
> shall specify the address of the 
system on which the portmapper to be
contacted resides. The value of <CODE
CLASS="VARNAME"
>address-&#62;sin_port</CODE
>
shall be ignored, and the standard
value for the portmapper port shall always be used.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Security and network restrictions may prevent a
conforming application from contacting a remote RPC Binding
Service.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10677"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function shall return 
the port number in host byte order of the RPC application
registered with the remote portmapper. On failure, 
if either the program was not
registered or the remote portmapper service could not be reached, 
the <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function
shall return 0. If the remote portmap service could not be reached, the status
is left in the global variable <CODE
CLASS="VARNAME"
>rpc_createerr</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB-PMAP-SET-3"
></A
>pmap_set</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10687"
></A
><H2
>Name</H2
>pmap_set&nbsp;--&nbsp;establishes mapping to machine's RPC Bind service.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10690"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10693"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/pmap_clnt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t
  <TT
CLASS="FUNCTION"
>pmap_set</TT
></CODE
>(const u_long
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>program</I
></TT
></I
></TT
>, const u_long
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>version</I
></TT
></I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>protocol</I
></TT
></I
></TT
>, u_short
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10710"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pmap_set()</TT
> establishes a mapping between the
triple <TT
CLASS="PARAMETER"
><I
>[program,version,protocol]</I
></TT
> and
<TT
CLASS="PARAMETER"
><I
>port</I
></TT
> on the machine's RPC Bind
service. The value of <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
>
is most likely <CODE
CLASS="VARNAME"
>IPPROTO_UDP</CODE
> or <CODE
CLASS="VARNAME"
>IPPROTO_TCP</CODE
>. Automatically done by <TT
CLASS="FUNCTION"
>svc_register()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10722"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>pmap_set()</TT
> returns non-zero if it suceeds, 0 otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-PMAP-UNSET-3"
></A
>pmap_unset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10730"
></A
><H2
>Name</H2
>pmap_unset&nbsp;--&nbsp;
destroys RPC Binding&#13;</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10733"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10736"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>&#13;#include &#60;rpc/pmap_clnt.h&#62;&#13;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t

  <TT
CLASS="FUNCTION"
>pmap_unset</TT
></CODE
>(u_long

  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>prognum</I
></TT
></I
></TT
>, u_long

  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>versnum</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10747"
></A
><H2
>Description&#13;</H2
><P
>&#13;As a user interface to the RPC Bind service, 

<TT
CLASS="FUNCTION"
>pmap_unset()</TT
> destroys all mapping between the triple 

[<TT
CLASS="PARAMETER"
><I
>prognum</I
></TT
>,<TT
CLASS="PARAMETER"
><I
>versnum</I
></TT
>,

<TT
CLASS="PARAMETER"
><I
>*</I
></TT
>] and <CODE
CLASS="VARNAME"
>ports</CODE
> on the machine's 

RPC Bind service.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10757"
></A
><H2
>Return Value&#13;</H2
><P
>&#13;<TT
CLASS="FUNCTION"
>pmap_unset()</TT
> returns non-zero if it succeeds, zero otherwise.&#13;</P
></DIV
><H1
><A
NAME="BASELIB-PSIGNAL-3"
></A
>psignal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10765"
></A
><H2
>Name</H2
>psignal&nbsp;--&nbsp;print signal message</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10768"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10771"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>psignal</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sig</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern const char *const <CODE
CLASS="VARNAME"
>sys_siglist</CODE
>[]</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10784"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>psignal()</TT
> function shall 
display a message on the <CODE
CLASS="VARNAME"
>stderr</CODE
> stream.
If <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> is not the null pointer, and does 
not point to an empty string (e.g. <TT
CLASS="LITERAL"
>"\0"</TT
>), the
message shall consist 
of the string <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, a colon, a space, and a string 
describing the signal number <TT
CLASS="PARAMETER"
><I
>sig</I
></TT
>; otherwise
<TT
CLASS="FUNCTION"
>psignal()</TT
> shall display only a message describing
the signal number <TT
CLASS="PARAMETER"
><I
>sig</I
></TT
>. If 
<TT
CLASS="PARAMETER"
><I
>sig</I
></TT
> is invalid, the message displayed shall 
indicate an unknown signal.</P
><P
>The array <CODE
CLASS="VARNAME"
>sys_siglist</CODE
> holds the signal description 
strings indexed by signal number.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10800"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>psignal()</TT
> returns no value.</P
></DIV
><H1
><A
NAME="BASELIB-REGEXEC-2"
></A
>regexec</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10808"
></A
><H2
>Name</H2
>regexec&nbsp;--&nbsp;regular expression matching</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10813"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>regexec()</TT
> function shall behave as specified in 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>, 
except with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN10819"
></A
><H3
>Differences</H3
><P
>Certain aspects of regular expression matching are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Internationalization and Regular Expressions</A
>.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-SCANF"
></A
>scanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10827"
></A
><H2
>Name</H2
>scanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10830"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10835"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-SETBUFFER-3"
></A
>setbuffer</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10853"
></A
><H2
>Name</H2
>setbuffer&nbsp;--&nbsp;stream buffering operation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10856"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10859"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>setbuffer</TT
></CODE
>(FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>stream</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>size</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10873"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>setbuffer()</TT
> is an alias for the call to 
<TT
CLASS="FUNCTION"
>setvbuf()</TT
>. It works the same, except that the 
size of the buffer in <TT
CLASS="FUNCTION"
>setbuffer()</TT
> is up to 
the caller, rather than being determined by the default 
<TT
CLASS="PARAMETER"
><I
>BUFSIZ</I
></TT
>.  </P
></DIV
><H1
><A
NAME="BASELIB-SETGROUPS-2"
></A
>setgroups</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10886"
></A
><H2
>Name</H2
>setgroups&nbsp;--&nbsp;set list of supplementary group IDs</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10889"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10890"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>setgroups</TT
></CODE
>(size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>size</I
></TT
></I
></TT
>, const gid_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>list</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10901"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege,
the <TT
CLASS="FUNCTION"
>setgroups()</TT
> function shall set
the supplementary group IDs for 
the current process. <TT
CLASS="PARAMETER"
><I
>list</I
></TT
> shall reference
an array of <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> group IDs. A process
may have at most <CODE
CLASS="CONSTANT"
>NGROUPS_MAX</CODE
> supplementary
group IDs.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10908"
></A
><H2
>Return Value</H2
><P
>On successful completion, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the <CODE
CLASS="VARNAME"
>errno</CODE
> is set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10914"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10917"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EFAULT</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>list</I
></TT
> has an invalid address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10923"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EPERM</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process does not have appropriate privileges.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10928"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EINVAL</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
> is greater than <CODE
CLASS="VARNAME"
>NGROUPS_MAX</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-SETHOSTNAME-2"
></A
>sethostname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10939"
></A
><H2
>Name</H2
>sethostname&nbsp;--&nbsp;set host name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10942"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10943"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;
#include &#60;sys/param.h.h&#62;
#include &#60;sys/utsname.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sethostname</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>len</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10954"
></A
><H2
>Description</H2
><P
>If the process has appropriate privileges, the
<TT
CLASS="FUNCTION"
>sethostname()</TT
> function shall change the host name for the 
current macine. The <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> shall point to a
null-terminated string of at most <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes
that holds the new hostname.</P
><P
>If the symbol <CODE
CLASS="CONSTANT"
>HOST_NAME_MAX</CODE
> is defined, or if
<TT
CLASS="FUNCTION"
>sysconf(_SC_HOST_NAME_MAX)()</TT
> returns a value greater
than 0, this value shall represent the maximum length of the new hostname.
Otherwise, if the symbol <CODE
CLASS="CONSTANT"
>MAXHOSTLEN</CODE
> is defined, this value
shall represent the maximum length for the new hostname. If none of these
values are defined, the maximum length shall be the size of the
<CODE
CLASS="STRUCTFIELD"
>nodename</CODE
> field of the
<TT
CLASS="STRUCTNAME"
>utsname</TT
> structure.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10966"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10972"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10975"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
> is negative or larger than the maximum allowed size.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10980"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the process did not have appropriate privilege.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN10984"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is an invalid address.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10989"
></A
><H2
>Rationale</H2
><P
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
guarantees that:
<A
NAME="AEN10993"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Maximum length of a host name (not including the terminating null) 
as returned from the <TT
CLASS="FUNCTION"
>gethostname()</TT
> function shall be at least 255 bytes.</P
></BLOCKQUOTE
></P
><P
>The glibc C library does not currently define <CODE
CLASS="CONSTANT"
>HOST_NAME_MAX</CODE
>,
and although it provides the name <CODE
CLASS="CONSTANT"
>_SC_HOST_NAME_MAX</CODE
>
a call to <TT
CLASS="FUNCTION"
>sysconf()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>
and does not alter <CODE
CLASS="VARNAME"
>errno</CODE
> in this case (indicating that
there is no restriction on the hostname length). However, the glibc
manual idicates that some implementations may have 
<CODE
CLASS="CONSTANT"
>MAXHOSTNAMELEN</CODE
> as a means of detecting the maximum length,
while the Linux kernel at release 2.4 and 2.6 stores this hostname
in the <TT
CLASS="STRUCTNAME"
>utsname</TT
> structure.
While the glibc manual suggests simply shortening the name until
<TT
CLASS="FUNCTION"
>sethostname()</TT
> succeeds, the LSB requires
that one of the first four mechanisms works.
Future versions of glibc may provide a more reasonable result from 
<TT
CLASS="LITERAL"
>sysconf</TT
>(<CODE
CLASS="CONSTANT"
>_SC_HOST_NAME_MAX</CODE
>).</P
></DIV
><H1
><A
NAME="BASELIB-SETSOCKOPT-2"
></A
>setsockopt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11011"
></A
><H2
>Name</H2
>setsockopt&nbsp;--&nbsp;set socket options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11016"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11017"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;
#include &#60;netinet/ip.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>setsockopt</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>socket</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
>, const void *
<TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>, socklen_t
<TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11032"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>setsockopt()</TT
> function shall behave as specified in
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>,
with the following extensions.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN11038"
></A
><H3
>IP Protocol Level Options</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> parameter is
<CODE
CLASS="CONSTANT"
>IPPROTO_IP</CODE
>, the following values shall be supported for
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
> (see <A
HREF="#STD.RFC791"
>RFC 791:Internet Protocol</A
> for
further details):
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11046"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_OPTIONS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the Internet Protocol options sent with
every packet from this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a
memory buffer containing the options and
<TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall contain the size in bytes
of that buffer.
For IPv4, the maximum length of options is 40 bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11053"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TOS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the Type of Service flags
to use when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a value
containing the type of service value. The least significant two bits
of the value shall contain the new Type of Service indicator. Use of other
bits in the value is unspecified.
The <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> parameter shall hold the size, in bytes,
of the buffer referred to by <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11061"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TTL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the current unicast Internet Protocol
Time To Live value used when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a value
containing the time to live value, which shall be between
1 and 255.
The <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> parameter shall hold the size, in bytes,
of the buffer referred to by <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11069"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_MULTICAST_TTL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Sets the Time To Live value of outgoing multicast packets for this
socket. <TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to an integer which contains
the new TTL value. If the new TTL value is <CODE
CLASS="CONSTANT"
>-1</CODE
>, the implementation
should use an unspecified default TTL value. If the new TTL value is out of the range
of acceptable values (0-255), <TT
CLASS="FUNCTION"
>setsockopt()</TT
> shall return
<CODE
CLASS="CONSTANT"
>-1</CODE
> and set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11079"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_MULTICAST_LOOP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Sets a boolean flag indicating whether multicast packets originating locally
should be looped back to the local sockets.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to an integer which contains
the new flag value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11085"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_ADD_MEMBERSHIP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Join a multicast group.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure. Before calling, the
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>imr_multiaddr</CODE
>
field with the multicast group address and the
<CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
> field with the address of the local
interface. If <CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
> is set to INADDR_ANY,
then an appropriate interface is chosen by the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11095"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_DROP_MEMBERSHIP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Leave a multicast group.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure containing the same values as were
used with <CODE
CLASS="CONSTANT"
>IP_ADD_MEMBERSHIP</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11103"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_MULTICAST_IF</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the local device for a multicast socket.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure initialized in the same manner as
with <CODE
CLASS="CONSTANT"
>IP_ADD_MEMBERSHIP</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure contains two
<TT
CLASS="STRUCTNAME"
>struct in_addr</TT
> fields:
<CODE
CLASS="STRUCTFIELD"
>imr_multiaddr</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11116"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11122"
></A
><H2
>Errors</H2
><P
>As defined in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-SETUTENT-3"
></A
>setutent</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11130"
></A
><H2
>Name</H2
>setutent&nbsp;--&nbsp;access user accounting database entries</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11133"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11136"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>setutent</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11142"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>setutent()</TT
> function shall 
reset the user accounting database such that the next
call to <TT
CLASS="FUNCTION"
>getutent()</TT
> shall return the first
record in the database.
It is recommended to
call it before any of the other functions that operate on
the user accounting databases (e.g.
<TT
CLASS="FUNCTION"
>getutent()</TT
>)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11150"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-SIGANDSET"
></A
>sigandset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11157"
></A
><H2
>Name</H2
>sigandset&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical AND</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11160"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11161"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigandset</TT
></CODE
>(sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>set</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>left</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>right</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11175"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigandset()</TT
> shall combine the two signal 
sets referenced
by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>right</I
></TT
>,
using a logical AND operation, and shall place the result in the location
referenced by <TT
CLASS="PARAMETER"
><I
>set</I
></TT
>,
The resulting signal set shall contain only signals that are in both
the set referenced by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> and the set referenced by
<TT
CLASS="PARAMETER"
><I
>right</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11184"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>sigandset()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>. Otherise, <TT
CLASS="FUNCTION"
>sigandset()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11192"
></A
><H2
>Errors</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11196"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EINVAL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One or more of 
<TT
CLASS="PARAMETER"
><I
>set</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>left</I
></TT
>, or
<TT
CLASS="PARAMETER"
><I
>right</I
></TT
> was a null pointer.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11204"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>sigorset()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGISEMPTYSET"
></A
>sigisemptyset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11212"
></A
><H2
>Name</H2
>sigisemptyset&nbsp;--&nbsp;check for empty signal set</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11215"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11216"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigisemptyset</TT
></CODE
>(const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>set</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11224"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigisemptyset()</TT
> function shall
check for empty signal set referenced by <TT
CLASS="PARAMETER"
><I
>set</I
></TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11229"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>sigisemptyset()</TT
> function shall return
a positive non-zero value if the signal set referenced by 
<TT
CLASS="PARAMETER"
><I
>set</I
></TT
> is empty, or zero if this set is empty.
On error, <TT
CLASS="FUNCTION"
>sigisemptyset()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11237"
></A
><H2
>Errors</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11241"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EINVAL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>set</I
></TT
> is a null pointer.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="BASELIB-SIGORSET"
></A
>sigorset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11251"
></A
><H2
>Name</H2
>sigorset&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical OR</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11254"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11257"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigorset</TT
></CODE
>(sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>set</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>left</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>right</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11271"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigorset()</TT
> shall combine the two signal 
sets referenced
by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>right</I
></TT
>,
using a logical OR operation, and shall place the result in the location
referenced by <TT
CLASS="PARAMETER"
><I
>set</I
></TT
>,
The resulting signal set shall contain only signals that are in either
the set referenced by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> or the set referenced by
<TT
CLASS="PARAMETER"
><I
>right</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11282"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>sigorset()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>. Otherise, <TT
CLASS="FUNCTION"
>sigorset()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11290"
></A
><H2
>Errors</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11294"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EINVAL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One or more of 
<TT
CLASS="PARAMETER"
><I
>set</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>left</I
></TT
>, or
<TT
CLASS="PARAMETER"
><I
>right</I
></TT
> was a null pointer.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11302"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>sigandset()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGRETURN-2"
></A
>sigreturn</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11310"
></A
><H2
>Name</H2
>sigreturn&nbsp;--&nbsp;return from signal handler and cleanup stack frame</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11313"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11316"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigreturn</TT
></CODE
>(struct sigcontext *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>scp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11323"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigreturn()</TT
> function is used by the system 
to cleanup after a signal handler has returned.
This function is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11329"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>sigreturn()</TT
> never returns.</P
></DIV
><H1
><A
NAME="BASELIB-SSCANF"
></A
>sscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11337"
></A
><H2
>Name</H2
>sscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11340"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11345"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-STIME-2"
></A
>stime</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11363"
></A
><H2
>Name</H2
>stime&nbsp;--&nbsp;set time</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11366"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11369"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _SVID_SOURCE
#include &#60;time.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>stime</TT
></CODE
>(const time_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11377"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege, the <TT
CLASS="FUNCTION"
>stime()</TT
>
function shall set the system's idea of the time and date. 
Time, referenced by <TT
CLASS="PARAMETER"
><I
>t</I
></TT
>, is measured in seconds 
from the epoch (defined in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> as 00:00:00 UTC January 1, 1970).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11385"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>stime()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>stime()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and
<CODE
CLASS="VARNAME"
>errno</CODE
> shall be set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11393"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11396"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EPERM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process does not have appropriate privilege.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11401"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EINVAL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>t</I
></TT
> is a null pointer.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-STPCPY-3"
></A
>stpcpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11411"
></A
><H2
>Name</H2
>stpcpy&nbsp;--&nbsp;copy a string returning a pointer to its end</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11414"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11417"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>stpcpy</TT
></CODE
>(char * restrict
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const char * restrict
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11428"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>stpcpy()</TT
> function shall
copy the string pointed to by 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> (including the terminating null
character) to the array pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. 
The strings may not overlap, and the destination string 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> shall be large enough to receive the copy.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11437"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>stpcpy()</TT
> returns a pointer to the end of the string 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> (that is, the address of the terminating 
null character) rather than the beginning.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11442"
></A
><H2
>Example</H2
><P
>This program uses <TT
CLASS="FUNCTION"
>stpcpy()</TT
> to concatenate 
<TT
CLASS="LITERAL"
>foo</TT
> and <TT
CLASS="LITERAL"
>bar</TT
> to produce 
<TT
CLASS="LITERAL"
>foobar</TT
>, which it then prints.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  #include &#60;string.h&#62;

  int
  main (void)
  {
    char buffer[256];
    char *to = buffer;
    to = stpcpy (to, "foo");
    to = stpcpy (to, "bar");
    printf ("%s\n", buffer);
  }</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="BASELIB-STPNCPY-3"
></A
>stpncpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11454"
></A
><H2
>Name</H2
>stpncpy&nbsp;--&nbsp;copy a fixed-size string, returning a pointer to its end</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11457"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11460"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>stpncpy</TT
></CODE
>(char * restrict
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const char * restrict
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11474"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>stpncpy()</TT
> function
shall copy at most <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> 
characters from the string pointed to by <TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, 
including the terminating null character, to the array 
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. Exactly <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>
characters are written at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If the length 
<TT
CLASS="FUNCTION"
>strlen()</TT
><TT
CLASS="PARAMETER"
><I
>(src)</I
></TT
> is smaller than 
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, the remaining characters in 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> are filled with <SPAN
CLASS="TOKEN"
>'\0'</SPAN
> characters. 
If the length <TT
CLASS="LITERAL"
>strlen</TT
><TT
CLASS="PARAMETER"
><I
>(src)</I
></TT
> 
is greater than or equal to <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> will not be null terminated.</P
><P
>The strings may not overlap.</P
><P
>The programmer shall ensure that there is room for at least
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11498"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>stpncpy()</TT
> function shall return
a pointer to the terminating 
<SPAN
CLASS="TOKEN"
>NULL</SPAN
> in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, or, if 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is not <SPAN
CLASS="TOKEN"
>NULL</SPAN
>-terminated, 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> + <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-STRCASESTR"
></A
>strcasestr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11512"
></A
><H2
>Name</H2
>strcasestr&nbsp;--&nbsp;locate a substring ignoring case</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11515"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11518"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strcasestr</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s2</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11529"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strcasestr()</TT
> shall behave as 
<TT
CLASS="FUNCTION"
>strstr()</TT
>, 
except that it shall ignore the case of both strings.
The <TT
CLASS="FUNCTION"
>strcasestr()</TT
> function shall be locale aware;
that is <TT
CLASS="FUNCTION"
>strcasestr()</TT
> shall behave as if both
strings had been converted to lower case in the current locale
before the comparison is performed.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11538"
></A
><H2
>Return Value</H2
><P
>Upon successful completion, 
<TT
CLASS="FUNCTION"
>strcasestr()</TT
> shall return a pointer to the located
string or a null pointer if the string is not found. 
If <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
> points to a string
with zero length, the function shall return <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-STRERROR-R"
></A
>strerror_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11548"
></A
><H2
>Name</H2
>strerror_r&nbsp;--&nbsp;reentrant version of strerror</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11551"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11552"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strerror_r</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>errnum</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buflen</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11566"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strerror_r()</TT
> shall behave as specified in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as described below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN11571"
></A
><H3
>Returns String, not Error Value</H3
><P
>The <TT
CLASS="FUNCTION"
>strerror_r()</TT
> function shall return a pointer to
the string corresponding to <TT
CLASS="PARAMETER"
><I
>errno</I
></TT
>. 
The returned pointer may point within 
the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> (at most 
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> bytes).</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11578"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>strerror_r()</TT
> shall return a pointer
to the generated message string (determined by the setting of the
<CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
> category in the current locale).
Otherwise, <TT
CLASS="FUNCTION"
>strerror_r()</TT
> shall return the string
corresponding to <SPAN
CLASS="RETURNVALUE"
>"Unknown error"</SPAN
>.</P
></DIV
><H1
><A
NAME="BASELIB-STRNDUP"
></A
>strndup</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11589"
></A
><H2
>Name</H2
>strndup&nbsp;--&nbsp;return a malloc'd copy of at most the specified number of bytes of a string </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11592"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11595"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strndup</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11606"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strndup()</TT
> function shall return a 
<TT
CLASS="FUNCTION"
>malloc()</TT
>'d copy of at most <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> 
bytes of <TT
CLASS="PARAMETER"
><I
>string</I
></TT
>. The resultant string shall be 
terminated even if no <SPAN
CLASS="TOKEN"
>NULL</SPAN
> terminator appears 
before <TT
CLASS="PARAMETER"
><I
>string</I
></TT
>+<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11618"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>strndup()</TT
> shall return a pointer to a newly
allocated block of memory containing a copy of at most <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>
bytes of <TT
CLASS="PARAMETER"
><I
>string</I
></TT
>. Otherwise, <TT
CLASS="FUNCTION"
>strndup()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>NULL</SPAN
> and set <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11627"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11630"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>ENOMEM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-STRNLEN-3"
></A
>strnlen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11639"
></A
><H2
>Name</H2
>strnlen&nbsp;--&nbsp;determine the length of a fixed-size string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11642"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11645"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>strnlen</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>maxlen</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11656"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>strnlen()</TT
> returns the number of characters in 
the string <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, not including the terminating 
<SPAN
CLASS="TOKEN"
>\0</SPAN
> character, but at most <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>. 
In doing this, <TT
CLASS="FUNCTION"
>strnlen()</TT
> looks only at the first 
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
> characters at <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> 
and never beyond <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> + <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11670"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>strnlen()</TT
> returns 
<TT
CLASS="LITERAL"
>strlen<TT
CLASS="PARAMETER"
><I
>(s)</I
></TT
></TT
>, if that is less 
than <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
> if 
there is no <SPAN
CLASS="TOKEN"
>\0</SPAN
> character among the first 
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
> characters pointed to by 
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-STRPTIME-3"
></A
>strptime</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11685"
></A
><H2
>Name</H2
>strptime&nbsp;--&nbsp;parse a time string</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11688"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strptime()</TT
> shall behave as specified in the
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
> with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN11694"
></A
><H3
>Number of leading zeroes may be limited</H3
><P
>The <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
> specifies fields for which "leading zeros are
permitted but not required"; however, applications shall not expect to 
be able to supply more leading zeroes for these fields than would be 
implied by the range of the field. Implementations may choose to 
either match an input with excess leading zeroes, or treat this as a 
non-matching input.  For example, <CODE
CLASS="VARNAME"
>%j</CODE
> has a range of 
<TT
CLASS="LITERAL"
>001</TT
> to <TT
CLASS="LITERAL"
>366</TT
>, so <TT
CLASS="LITERAL"
>0</TT
>, 
<TT
CLASS="LITERAL"
>00</TT
>, <TT
CLASS="LITERAL"
>000</TT
>, <TT
CLASS="LITERAL"
>001</TT
>, 
and <TT
CLASS="LITERAL"
>045</TT
> are acceptable inputs, but inputs such as 
<TT
CLASS="LITERAL"
>0000</TT
>, <TT
CLASS="LITERAL"
>0366</TT
> and the like are not.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11709"
></A
><H2
>Rationale</H2
><P
><I
CLASS="EMPHASIS"
>glibc</I
> developers consider it appropriate behavior 
to forbid excess leading zeroes.  When trying to parse a given input
against several format strings, forbidding excess leading zeroes could
be helpful.  For example, if one matches <TT
CLASS="LITERAL"
>0011-12-26</TT
> 
against <TT
CLASS="LITERAL"
>%m-%d-%Y</TT
> and then against 
<TT
CLASS="LITERAL"
>%Y-%m-%d</TT
>, it seems useful for the first match to fail, 
as it would be perverse to parse that date as November 12, year 26.  
The second pattern parses it as December 26, year 11.</P
><P
>The <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
> is 
not explicit that an unlimited number of leading zeroes are required, 
although it may imply this. The <ACRONYM
CLASS="ACRONYM"
>LSB</ACRONYM
> explicitly 
allows implementations to have either behavior. Future versions of this 
standard may require implementations to forbid excess leading zeroes.</P
><P
>An Interpretation Request is
currently pending against <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> for this matter.</P
></DIV
><H1
><A
NAME="BASELIB-STRSEP-3"
></A
>strsep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11726"
></A
><H2
>Name</H2
>strsep&nbsp;--&nbsp;extract token from string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11729"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11732"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strsep</TT
></CODE
>(char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>stringp</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>delim</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11743"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strsep()</TT
> function shall find the first token
in the string referenced by the pointer <TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
>,
using the characters in <TT
CLASS="PARAMETER"
><I
>delim</I
></TT
> as delimiters.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> is <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, 
<TT
CLASS="FUNCTION"
>strsep()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>NULL</SPAN
> 
and do nothing else. </P
><P
>If <TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> is non-<SPAN
CLASS="TOKEN"
>NULL</SPAN
>, 
<TT
CLASS="FUNCTION"
>strsep()</TT
> shall find the first token in the 
string referenced by
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
>, where tokens are delimited by characters 
in the string <TT
CLASS="PARAMETER"
><I
>delim</I
></TT
>. This token shall be terminated 
with a <SPAN
CLASS="TOKEN"
>\0</SPAN
> character by overwriting the delimiter, and 
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> shall be updated to point past the token. In 
case no delimiter was found, the token is taken to be the entire string 
referenced by
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
>, and the location referenced by
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> is 
made <SPAN
CLASS="TOKEN"
>NULL</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11767"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>strsep()</TT
> shall return a pointer to the 
beginning of the token.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11771"
></A
><H2
>Notes</H2
><P
>The <TT
CLASS="FUNCTION"
>strsep()</TT
> function was introduced as a replacement for 
<TT
CLASS="FUNCTION"
>strtok()</TT
>, since the latter cannot handle empty 
fields. However, <TT
CLASS="FUNCTION"
>strtok()</TT
> conforms to 
<A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> and to <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> and hence is more portable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11779"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>strtok()</TT
>, <TT
CLASS="FUNCTION"
>strtok_r()</TT
>. </P
></DIV
><H1
><A
NAME="BASELIB-STRSIGNAL-3"
></A
>strsignal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11788"
></A
><H2
>Name</H2
>strsignal&nbsp;--&nbsp;return string describing signal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11791"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11794"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strsignal</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sig</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern const char * const <CODE
CLASS="VARNAME"
>sys_siglist</CODE
>[];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11804"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strsignal()</TT
> function shall return a pointer to
a string describing the signal 
number <TT
CLASS="PARAMETER"
><I
>sig</I
></TT
>. 
The string can only be used until the next call to <TT
CLASS="FUNCTION"
>strsignal()</TT
>.</P
><P
>The array <CODE
CLASS="VARNAME"
>sys_siglist</CODE
> holds the signal description 
strings indexed by signal number. This array should not be accessed 
directly by applications.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11814"
></A
><H2
>Return Value</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>sig</I
></TT
> is a valid signal number,
<TT
CLASS="FUNCTION"
>strsignal()</TT
> shall return a pointer to
the appropriate description 
string. Otherwise, <TT
CLASS="FUNCTION"
>strsignal()</TT
> shall return
either a pointer to the string <TT
CLASS="LITERAL"
>"unknown signal"</TT
>, or
a null pointer.</P
><P
>Although the function is not declared as returning a pointer to a constant
character string, applications shall not modify the returned string.</P
></DIV
><H1
><A
NAME="BASELIB-STRTOQ-3"
></A
>strtoq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11826"
></A
><H2
>Name</H2
>strtoq&nbsp;--&nbsp;convert string value to a long or quad_t integer</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11829"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11832"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;limits.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long 
  <TT
CLASS="FUNCTION"
>strtoq</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11846"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>strtoq()</TT
> converts the string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> 
to a quadt value. The conversion is done according to the given base, which 
shall be between <TT
CLASS="LITERAL"
>2</TT
> and <TT
CLASS="LITERAL"
>36</TT
> inclusive, 
or be the special value <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> may begin with an arbitrary amount of white 
space (as determined by <TT
CLASS="FUNCTION"
>isspace()</TT
>), followed by a 
single optional <SPAN
CLASS="TOKEN"
>+</SPAN
> or <SPAN
CLASS="TOKEN"
>-</SPAN
> sign character. If 
<TT
CLASS="PARAMETER"
><I
>base</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
> or <TT
CLASS="LITERAL"
>16</TT
>, 
the string may then include a <SPAN
CLASS="TOKEN"
>0x</SPAN
> prefix, and the number will 
be read in base 16; otherwise, a <TT
CLASS="LITERAL"
>0</TT
> base is taken as 
10 (decimal), unless the next character is <TT
CLASS="LITERAL"
>0</TT
>, in which 
case it is taken as 8 (octal).</P
><P
>The remainder of the string is converted to a long value in the obvious 
manner, stopping at the first character which is not a valid digit in the 
given base. (In bases above 10, the letter <TT
CLASS="LITERAL"
>A</TT
> in either 
upper or lower case represents 10, <TT
CLASS="LITERAL"
>B</TT
> represents 11, and 
so forth, with <TT
CLASS="LITERAL"
>Z</TT
> representing 35.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11871"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>strtoq()</TT
> returns the result of the conversion, 
unless the value would underflow or overflow. If an underflow occurs, 
<TT
CLASS="FUNCTION"
>strtoq()</TT
> returns <CODE
CLASS="VARNAME"
>QUAD_MIN</CODE
>. If 
an overflow occurs, <TT
CLASS="FUNCTION"
>strtoq()</TT
> returns 
<CODE
CLASS="VARNAME"
>QUAD_MAX</CODE
>. In both cases, the global variable 
<CODE
CLASS="VARNAME"
>errno</CODE
> is set to <SPAN
CLASS="ERRORNAME"
>ERANGE</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11881"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11884"
></A
><SPAN
STYLE="white-space: nowrap"
>ERANGE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The given string was out of range; the value converted has been clamped.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-STRTOUQ-3"
></A
>strtouq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11892"
></A
><H2
>Name</H2
>strtouq&nbsp;--&nbsp;convert a string to an unsigned long long</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11895"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11898"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;limits.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long 
  <TT
CLASS="FUNCTION"
>strtouq</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11912"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>strtouq()</TT
> converts the string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> 
to an <SPAN
CLASS="TYPE"
>unsigned long long</SPAN
>
value. The conversion is done according to the given base, which 
shall be between <TT
CLASS="LITERAL"
>2</TT
> and <TT
CLASS="LITERAL"
>36</TT
> inclusive, 
or be the special value <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> may begin with an arbitrary amount of white 
space (as determined by <TT
CLASS="FUNCTION"
>isspace()</TT
>), followed by a 
single optional <SPAN
CLASS="TOKEN"
>+</SPAN
> or <SPAN
CLASS="TOKEN"
>-</SPAN
> sign character. If 
<TT
CLASS="PARAMETER"
><I
>base</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
> or <TT
CLASS="LITERAL"
>16</TT
>, 
the string may then include a <SPAN
CLASS="TOKEN"
>0x</SPAN
> prefix, and the number will 
be read in base 16; otherwise, a <TT
CLASS="LITERAL"
>0</TT
> base is taken as 
10 (decimal), unless the next character is <TT
CLASS="LITERAL"
>0</TT
>, in which 
case it is taken as 8 (octal).</P
><P
>The remainder of the string is converted to an unsigned long value in the 
obvious manner, stopping at the end of the string or at the first character 
that does not produce a valid digit in the given base. (In bases above 10, 
the letter <TT
CLASS="LITERAL"
>A</TT
> in either upper or lower case represents 10, 
<TT
CLASS="LITERAL"
>B</TT
> represents 11, and so forth, with <TT
CLASS="LITERAL"
>Z</TT
> 
representing 35.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11938"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>strtouq()</TT
> returns either the result of 
the conversion or, if there was a leading minus sign, the negation of 
the result of the conversion, unless the original (non-negated) value 
would overflow. In the case of an overflow the function returns 
<CODE
CLASS="VARNAME"
>UQUAD_MAX</CODE
> and the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> 
is set to <SPAN
CLASS="ERRORNAME"
>ERANGE</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11945"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN11948"
></A
><SPAN
STYLE="white-space: nowrap"
>ERANGE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The given string was out of range; the value converted has been clamped.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-SVC-REGISTER-3"
></A
>svc_register</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11956"
></A
><H2
>Name</H2
>svc_register&nbsp;--&nbsp;register Remote Procedure Call interface</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11959"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11962"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/rpc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t
  <TT
CLASS="FUNCTION"
>svc_register</TT
></CODE
>(SVCXPRT *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>xprt</I
></TT
></I
></TT
>, rpcprog_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>prognum</I
></TT
></I
></TT
>, rpcvers_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>versnum</I
></TT
></I
></TT
>, __dispatch_fn_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dispatch</I
></TT
></I
></TT
>, rpcprot_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>protocol</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11982"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>svc_register()</TT
> function shall associate
the program identified by <TT
CLASS="PARAMETER"
><I
>prognum</I
></TT
> at version
<TT
CLASS="PARAMETER"
><I
>versnum</I
></TT
>
with the service dispatch procedure, <TT
CLASS="PARAMETER"
><I
>dispatch</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> is zero, the service is not registered with the
<CODE
CLASS="VARNAME"
>portmap</CODE
> service.  If <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> is
non-zero, then a mapping of the triple [<TT
CLASS="PARAMETER"
><I
>prognum</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>versnum</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
>] to 
<CODE
CLASS="VARNAME"
>xprt-&#62;xp_port</CODE
> is established with the local 
<CODE
CLASS="VARNAME"
>portmap</CODE
> service.  The
procedure <TT
CLASS="PARAMETER"
><I
>dispatch</I
></TT
> has the following form:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12000"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>dispatch</TT
></CODE
>(struct svc_req *
<TT
CLASS="PARAMETER"
><I
>request</I
></TT
>, SVCXPRT *
<TT
CLASS="PARAMETER"
><I
>xprt</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12008"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>svc_register()</TT
> returns 
<SPAN
CLASS="RETURNVALUE"
>1</SPAN
> if it succeeds, and 
<SPAN
CLASS="RETURNVALUE"
>zero</SPAN
> 
otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-SVC-RUN-3"
></A
>svc_run</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12018"
></A
><H2
>Name</H2
>svc_run&nbsp;--&nbsp;waits for RPC requests to arrive and calls service procedure</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12021"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12024"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/svc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
  <TT
CLASS="FUNCTION"
>svc_run</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12030"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>svc_run()</TT
> function shall wait for RPC
requests to arrive, read and unpack each request, and dispatch
it to the appropriate registered handler.
Under normal conditions, <TT
CLASS="FUNCTION"
>svc_run()</TT
> shall not return;
it shall only return if serious errors occur that prevent further
processing.</P
></DIV
><H1
><A
NAME="BASELIB-SVC-SENDREPLY-3"
></A
>svc_sendreply</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12041"
></A
><H2
>Name</H2
>svc_sendreply&nbsp;--&nbsp;called by RPC service's dispatch routine</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12044"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12047"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t <TT
CLASS="FUNCTION"
>svc_sendreply</TT
></CODE
>(SVCXPRT *<TT
CLASS="PARAMETER"
><I
>xprt</I
></TT
>, xdrproc_t <TT
CLASS="PARAMETER"
><I
>outproc</I
></TT
>, caddr_t <TT
CLASS="PARAMETER"
><I
>out</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12057"
></A
><H2
>Description</H2
><P
>Called by an RPC service's dispatch routine to send the  results of a remote procedure call.  
The parameter <TT
CLASS="PARAMETER"
><I
>xprt</I
></TT
> is the request's associated transport handle; 
<TT
CLASS="PARAMETER"
><I
>outproc</I
></TT
> is the XDR routine which is used  to  encode  the  results;  
and  <TT
CLASS="PARAMETER"
><I
>out</I
></TT
>  is the address of the results.  
This routine returns one if it succeeds,  zero  other-wise.</P
></DIV
><H1
><A
NAME="BASELIB-SVCTCP-CREATE-3"
></A
>svctcp_create</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12067"
></A
><H2
>Name</H2
>svctcp_create&nbsp;--&nbsp;create a TCP/IP-based RPC service transport</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12070"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12073"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/rpc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>SVCXPRT *
  <TT
CLASS="FUNCTION"
>svctcp_create</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sock</I
></TT
></I
></TT
>, u_int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>send_buf_size</I
></TT
></I
></TT
>, u_int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>recv_buf_size</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12087"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>svctcp_create()</TT
> cretes a TCP/IP-based RPC service transport, 
to which it returns a pointer.  The transport is associated with the socket
<TT
CLASS="PARAMETER"
><I
>sock</I
></TT
>, which may be <CODE
CLASS="VARNAME"
>RPC_ANYSOCK</CODE
>, in 
which case a new socket is created.  If the socket is not bound to a local TCP
port, then this routine binds it to an arbitrary port.  Upon completion, 
<CODE
CLASS="VARNAME"
>xprt-&#62;xp_sock</CODE
> is the transport's socket descriptor,
and <CODE
CLASS="VARNAME"
>xprt-&#62;xp_port</CODE
> is the transport's port number.  Since 
TCP-based RPC uses buffered I/O, users may specify the size of buffers;
values of zero choose suitable defaults.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12097"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>svctcp_create()</TT
> returns NULL if it fails, or a pointer to 
the RPC service transport otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-SVCUDP-CREATE-3"
></A
>svcudp_create</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12105"
></A
><H2
>Name</H2
>svcudp_create&nbsp;--&nbsp;		create a UDP-based RPC service transport
		</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12108"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12109"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>SVCXPRT *</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="FUNCTION"
>svcudp_create</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>sock</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12116"
></A
><H2
>Description</H2
><P
>This call is equivalent to <TT
CLASS="LITERAL"
>svcudp_bufcreate(
<TT
CLASS="PARAMETER"
><I
>sock</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>SZ</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>SZ</I
></TT
>)</TT
>
for some default size SZ.</P
></DIV
><H1
><A
NAME="BASELIB-SWSCANF"
></A
>swscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12127"
></A
><H2
>Name</H2
>swscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12130"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12135"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-SYSTEM-3"
></A
>system</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12153"
></A
><H2
>Name</H2
>system&nbsp;--&nbsp;execute a shell command</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12156"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12159"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>system</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12167"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>system()</TT
> function shall behave as described in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12174"
></A
><H2
>Notes</H2
><P
>The fact that <TT
CLASS="FUNCTION"
>system()</TT
> ignores interrupts is often 
not what a program wants. <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
describes some of the consequences; an 
additional consequence is that a program calling <TT
CLASS="FUNCTION"
>system()</TT
> 
from a loop cannot be reliably interrupted. Many programs will want to use 
the <TT
CLASS="FUNCTION"
>exec()</TT
> family of functions instead.</P
><P
>Do not use <TT
CLASS="FUNCTION"
>system()</TT
> from a program with 
<CODE
CLASS="VARNAME"
>suid</CODE
> or <CODE
CLASS="VARNAME"
>sgid</CODE
> privileges, 
because unexpected values for some environment variables might be used 
to subvert system integrity. Use the <TT
CLASS="FUNCTION"
>exec()</TT
>
family of functions instead, but not <TT
CLASS="FUNCTION"
>execlp()</TT
>
or <TT
CLASS="FUNCTION"
>execvp()</TT
>. <TT
CLASS="FUNCTION"
>system()</TT
> will 
not, in fact, work properly from programs with <CODE
CLASS="VARNAME"
>suid</CODE
> 
or <CODE
CLASS="VARNAME"
>sgid</CODE
> privileges on systems on which 
<TT
CLASS="FILENAME"
>/bin/sh</TT
> is <B
CLASS="COMMAND"
>bash</B
> version 2, 
since <B
CLASS="COMMAND"
>bash</B
> 2 drops privileges on startup. 
(Debian uses a modified <B
CLASS="COMMAND"
>bash</B
> which does not do 
this when invoked as <B
CLASS="COMMAND"
>sh</B
>.)</P
><P
>The check for the availability of <TT
CLASS="FILENAME"
>/bin/sh</TT
> 
is not actually performed; it is always assumed to be available. 
<A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> specifies the check, but 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> specifies that the return shall 
always be nonzero, since a system without the 
shell is not conforming, and it is this that is implemented.</P
><P
>It is possible for the shell command to return 
<SPAN
CLASS="RETURNVALUE"
>127</SPAN
>, so that code is not a sure 
indication that the <TT
CLASS="FUNCTION"
>execve()</TT
> call failed; check 
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> to make sure.</P
></DIV
><H1
><A
NAME="BASELIB-TEXTDOMAIN"
></A
>textdomain</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12208"
></A
><H2
>Name</H2
>textdomain&nbsp;--&nbsp;set the current default message domain</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12211"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12214"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>textdomain</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12222"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>textdomain()</TT
> function shall set
the current default message 
domain to <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>. 
Subsequent calls to <TT
CLASS="FUNCTION"
>gettext()</TT
> and 
<TT
CLASS="FUNCTION"
>ngettext()</TT
> use the default message domain.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, 
the default message domain shall not be altered.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is "", <TT
CLASS="FUNCTION"
>textdomain()</TT
>
shall reset the default domain to the system default of "messages". </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12237"
></A
><H2
>Return</H2
><P
>On success, <TT
CLASS="FUNCTION"
>textdomain()</TT
> shall return the currently 
selected domain. Otherwise, a null pointer shall be returned, and
<CODE
CLASS="VARNAME"
>errno</CODE
> is set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12242"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12245"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>ENOMEM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficent memory available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-UNLINK-3"
></A
>unlink</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12254"
></A
><H2
>Name</H2
>unlink&nbsp;--&nbsp;remove a directory entry</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12257"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12258"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>unlink</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12265"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>unlink()</TT
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
but with differences as listed below.</P
><P
>See also <A
HREF="#EXEC-LINK-UNLINK"
>Section 18.1, Additional behaviors: unlink/link on directory</A
>.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN12272"
></A
><H3
>May return <SPAN
CLASS="ERRORNAME"
>EISDIR</SPAN
> on directories</H3
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> specifies a directory, the
implementation may return <SPAN
CLASS="ERRORNAME"
>EISDIR</SPAN
> 
instead of <SPAN
CLASS="ERRORNAME"
>EPERM</SPAN
> as specified by
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The Linux kernel has deliberately chosen <SPAN
CLASS="ERRORNAME"
>EISDIR</SPAN
> 
for this case and does not expect to change.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-USELOCALE-3"
></A
>uselocale</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12288"
></A
><H2
>Name</H2
>uselocale&nbsp;--&nbsp;set locale for thread</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12291"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12292"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>locale_t
<TT
CLASS="FUNCTION"
>uselocale</TT
></CODE
>(locale_t
<TT
CLASS="PARAMETER"
><I
>newloc</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12299"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>uselocale()</TT
> function shall set the locale for the
calling thread to the locale specified by <TT
CLASS="PARAMETER"
><I
>newloc</I
></TT
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>newloc</I
></TT
> is the value 
<CODE
CLASS="CONSTANT"
>LC_GLOBAL_LOCALE</CODE
>,
the thread's locale shall be set to the process current
global locale, as set
by <TT
CLASS="FUNCTION"
>setlocale()</TT
>.
If <TT
CLASS="PARAMETER"
><I
>newloc</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, the
thread's locale is not altered.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12310"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>uselocale()</TT
> function shall return the previous locale,
or <CODE
CLASS="CONSTANT"
>LC_GLOBAL_LOCALE</CODE
> if the thread local locale
has not been previously set.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12315"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12318"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setlocale()</TT
>, <TT
CLASS="FUNCTION"
>freelocale()</TT
>, <TT
CLASS="FUNCTION"
>duplocale()</TT
>, <TT
CLASS="FUNCTION"
>newlocale()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-UTMPNAME-3"
></A
>utmpname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12334"
></A
><H2
>Name</H2
>utmpname&nbsp;--&nbsp;set user accounting database</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12337"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12338"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>utmpname</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>dbname</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12345"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>utmpname()</TT
> function shall cause the user
accounting database
used by the <TT
CLASS="FUNCTION"
>getutent()</TT
>, <TT
CLASS="FUNCTION"
>getutent_r()</TT
>, <TT
CLASS="FUNCTION"
>getutxent()</TT
>, <TT
CLASS="FUNCTION"
>getutxid()</TT
>, <TT
CLASS="FUNCTION"
>getutxline()</TT
>, and <TT
CLASS="FUNCTION"
>pututxline()</TT
> functions to be that named by <TT
CLASS="PARAMETER"
><I
>dbname</I
></TT
>,
instead of the system default database. See
<A
HREF="#FHS-USER-ACCOUNTING-DBS"
>Section 16.3</A
> for further information.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not specify the format of the user accounting database,
nor the names of the file or files that may contain it. </P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12368"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12371"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="BASELIB-VASPRINTF"
></A
>vasprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12378"
></A
><H2
>Name</H2
>vasprintf&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12381"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12384"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdarg.h&#62;
#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>vasprintf</TT
></CODE
>(char * * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ptr</I
></TT
></I
></TT
>, const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>, va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12398"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>vasprintf()</TT
> function shall write
formatted output to a 
dynamically allocated string, and store
the address of that string in the location
referenced by <TT
CLASS="PARAMETER"
><I
>ptr</I
></TT
>.
It shall behave as <TT
CLASS="FUNCTION"
>asprintf()</TT
>,
except that instead of being called with a variable number
of arguments, it is called with an argument list as defined
by <TT
CLASS="FILENAME"
>&#60;stdarg.h&#62;</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12407"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12411"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-VDPRINTF"
></A
>vdprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12419"
></A
><H2
>Name</H2
>vdprintf&nbsp;--&nbsp;write formatted output to a file descriptor</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12422"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12425"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>vdprintf</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>, va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12439"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>vdprintf()</TT
> function shall behave as 
<TT
CLASS="FUNCTION"
>vfprintf()</TT
>, except that 
<TT
CLASS="FUNCTION"
>vdprintf()</TT
> shall write output to the file associated with the file descriptor
specified by the <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> argument, rather than place output on a
stream (as defined by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12449"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12453"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-VERRX-3"
></A
>verrx</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12461"
></A
><H2
>Name</H2
>verrx&nbsp;--&nbsp;display formatted error message and exit</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12464"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12465"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdarg.h&#62;
#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>verrx</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>eval</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>, va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>args</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12479"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>verrx()</TT
> shall behave as <TT
CLASS="FUNCTION"
>errx()</TT
>
except that instead of being called with a variable number
of arguments, it is called with an argument list as defined by
<TT
CLASS="FILENAME"
>&#60;stdarg.h&#62;</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>verrx()</TT
> does not return, but exits with the value 
of <TT
CLASS="PARAMETER"
><I
>eval</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12488"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12491"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-VFSCANF"
></A
>vfscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12498"
></A
><H2
>Name</H2
>vfscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12501"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12506"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VFWSCANF"
></A
>vfwscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12524"
></A
><H2
>Name</H2
>vfwscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12527"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12532"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSCANF"
></A
>vscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12550"
></A
><H2
>Name</H2
>vscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12553"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12558"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSSCANF"
></A
>vsscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12576"
></A
><H2
>Name</H2
>vsscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12579"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12584"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSWSCANF"
></A
>vswscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12602"
></A
><H2
>Name</H2
>vswscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12605"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12610"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSYSLOG-3"
></A
>vsyslog</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12628"
></A
><H2
>Name</H2
>vsyslog&nbsp;--&nbsp;log to system log</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12631"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12632"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdarg.h&#62;
#include &#60;syslog.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>vsyslog</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>priority</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>message</I
></TT
></I
></TT
>, va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arglist</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12646"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>vsyslog()</TT
> function
is identical to <TT
CLASS="FUNCTION"
>syslog()</TT
> 
as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that <TT
CLASS="PARAMETER"
><I
>arglist</I
></TT
> 
(as defined by <TT
CLASS="FILENAME"
>stdarg.h</TT
>) replaces the variable 
number of arguments.</P
></DIV
><H1
><A
NAME="BASELIB-VWSCANF"
></A
>vwscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12658"
></A
><H2
>Name</H2
>vwscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12661"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12666"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-WAIT4-2"
></A
>wait4</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12684"
></A
><H2
>Name</H2
>wait4&nbsp;--&nbsp;wait for process termination, BSD style</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12687"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12690"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;sys/resource.h&#62;
#include &#60;sys/wait.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>pid_t 
  <TT
CLASS="FUNCTION"
>wait4</TT
></CODE
>(pid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pid</I
></TT
></I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>status</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
></I
></TT
>, struct rusage *
  <TT
CLASS="PARAMETER"
><I
>rusage</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12706"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wait4()</TT
> suspends execution of the current process 
until a child (as specified by <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>) has exited, 
or until a signal is delivered whose action is to terminate the 
current process or to call a signal handling function. If a child (as 
requested by <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>) has already exited by the 
time of the call (a so-called "zombie" process), the function returns 
immediately. Any system resources used by the child are freed.</P
><P
>The value of <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> can be one of:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12717"
></A
><SPAN
STYLE="white-space: nowrap"
>&#60; -1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for any child process whose process group ID is equal to the 
absolute value of <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12722"
></A
><SPAN
STYLE="white-space: nowrap"
>-1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for any child process; this is equivalent to calling 
<TT
CLASS="FUNCTION"
>wait3()</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12727"
></A
><SPAN
STYLE="white-space: nowrap"
>0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for any child process whose process group ID is equal to that of 
the calling process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12731"
></A
><SPAN
STYLE="white-space: nowrap"
>&#62; 0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for the child whose process ID is equal to the value of 
<TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
><P
>The value of options is a bitwise or of zero or more of the following 
constants:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12738"
></A
><SPAN
STYLE="white-space: nowrap"
>WNOHANG</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>return immediately if no child is there to be waited for.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12742"
></A
><SPAN
STYLE="white-space: nowrap"
>WUNTRACED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>return for children that are stopped, and whose status has not been 
reported.</P
></TD
></TR
></TBODY
></TABLE
><P
>If status is not <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, <TT
CLASS="FUNCTION"
>wait4()</TT
> 
stores status information in the location 
<TT
CLASS="PARAMETER"
><I
>status</I
></TT
>. This status can be evaluated with the 
following macros:
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These macros take the <CODE
CLASS="VARNAME"
>status</CODE
> value (an 
<TT
CLASS="LITERAL"
>int</TT
>) as an argument -- not a pointer to the 
value!</P
></BLOCKQUOTE
></DIV
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12755"
></A
><SPAN
STYLE="white-space: nowrap"
>WIFEXITED(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is nonzero if the child exited normally.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12759"
></A
><SPAN
STYLE="white-space: nowrap"
>WEXITSTATUS(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>evaluates to the least significant eight bits of the return code of 
the child that terminated, which may have been set as the argument to 
a call to <TT
CLASS="FUNCTION"
>exit()</TT
> or as the argument for a return 
statement in the main program. This macro can only be evaluated if 
<TT
CLASS="FUNCTION"
>WIFEXITED()</TT
> returned nonzero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12765"
></A
><SPAN
STYLE="white-space: nowrap"
>WIFSIGNALED(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns true if the child process exited because of a signal that was 
not caught.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12769"
></A
><SPAN
STYLE="white-space: nowrap"
>WTERMSIG(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns the number of the signal that caused the child process to 
terminate. This macro can only be evaluated if 
<TT
CLASS="FUNCTION"
>WIFSIGNALED()</TT
> returned nonzero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12774"
></A
><SPAN
STYLE="white-space: nowrap"
>WIFSTOPPED(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns true if the child process that caused the return is currently 
stopped; this is only possible if the call was done using 
<TT
CLASS="FUNCTION"
>WUNTRACED()</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12779"
></A
><SPAN
STYLE="white-space: nowrap"
>WSTOPSIG(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns the number of the signal that caused the child to stop. This 
macro can only be evaluated if <TT
CLASS="FUNCTION"
>WIFSTOPPED()</TT
> 
returned nonzero.</P
></TD
></TR
></TBODY
></TABLE
><P
>If <TT
CLASS="PARAMETER"
><I
>rusage</I
></TT
> is not <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, the 
struct <TT
CLASS="STRUCTNAME"
>rusage</TT
> (as defined in 
<TT
CLASS="FILENAME"
>sys/resource.h</TT
>) that it points to will be filled 
with accounting information. See <TT
CLASS="FUNCTION"
>getrusage()</TT
> 
for details.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12790"
></A
><H2
>Return Value</H2
><P
>On success, the process ID of the child that exited is returned. On 
error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned (in particular, when 
no unwaited-for child processes of the specified kind exist), or 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
> if <TT
CLASS="FUNCTION"
>WNOHANG()</TT
> was used 
and no child was available yet. In the latter two cases, the global 
variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12797"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12800"
></A
><SPAN
STYLE="white-space: nowrap"
>ECHILD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No unwaited-for child process as specified does exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12804"
></A
><SPAN
STYLE="white-space: nowrap"
>ERESTARTSYS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A <TT
CLASS="FUNCTION"
>WNOHANG()</TT
> was not set and an unblocked signal or
a <CODE
CLASS="VARNAME"
>SIGCHILD</CODE
> was caught. This error is returned by 
the system call. The library interface is not allowed to return 
<SPAN
CLASS="ERRORNAME"
>ERESTARTSYS</SPAN
>, but will return
<SPAN
CLASS="ERRORNAME"
>EINTR</SPAN
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-WAITPID-3"
></A
>waitpid</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12816"
></A
><H2
>Name</H2
>waitpid&nbsp;--&nbsp;wait for child process</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12819"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>waitpid()</TT
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN12824"
></A
><H3
>Need not support <TT
CLASS="SYMBOL"
>WCONTINUED</TT
> or
<TT
CLASS="SYMBOL"
>WIFCONTINUED</TT
></H3
><P
>Implementations need not support the XSI optional functionality of 
<TT
CLASS="FUNCTION"
>WCONTINUED()</TT
> or <TT
CLASS="FUNCTION"
>WIFCONTINUED()</TT
>.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-WARN-3"
></A
>warn</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12835"
></A
><H2
>Name</H2
>warn&nbsp;--&nbsp;formatted error messages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12838"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12841"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>warn</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12850"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>warn()</TT
> function
shall display a formatted error message on the standard
error stream.
The output shall consist of the last component of the program name, a colon
character, and a space character. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is non-NULL, it shall be used as a
format string for the <TT
CLASS="FUNCTION"
>printf()</TT
>
family of functions, and the formatted message, a
colon character, and a space are written to <CODE
CLASS="VARNAME"
>stderr</CODE
>.
Finally,  the error message
string affiliated with the current value of the global variable 
<CODE
CLASS="VARNAME"
>errno</CODE
> shall be
written to <CODE
CLASS="VARNAME"
>stderr</CODE
>, followed by a newline character.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12861"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12864"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-WARNX-3"
></A
>warnx</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12871"
></A
><H2
>Name</H2
>warnx&nbsp;--&nbsp;formatted error messages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12874"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12875"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>warnx</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12884"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>warnx()</TT
> function shall display a formatted error message on the 
standard error stream. The last component of the program name, a colon 
character, and a space shall be output. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is 
non-<TT
CLASS="LITERAL"
>NULL</TT
>, it shall be used as the format string
for the <TT
CLASS="FUNCTION"
>printf()</TT
> family of functions, and
the formatted error message, a colon 
character, and a space shall be output. The output shall be followed by a 
newline character.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12891"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12894"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-WCPCPY-3"
></A
>wcpcpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12901"
></A
><H2
>Name</H2
>wcpcpy&nbsp;--&nbsp;copy a wide character string, returning a pointer to its end</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12904"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12907"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
  <TT
CLASS="FUNCTION"
>wcpcpy</TT
></CODE
>(wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12918"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcpcpy()</TT
> is the wide-character equivalent of 
<TT
CLASS="FUNCTION"
>stpcpy()</TT
>. It copies the wide character string 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, including the terminating 
null wide character code, to the array <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The strings may not overlap.</P
><P
>The programmer shall ensure that there is room for at least 
<TT
CLASS="FUNCTION"
>wcslen()</TT
><TT
CLASS="PARAMETER"
><I
>(src)</I
></TT
><TT
CLASS="LITERAL"
>+1</TT
> 
wide characters at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12933"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>wcpcpy()</TT
> returns a pointer to the end of the 
wide-character string <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, that is, a pointer to 
the terminating null wide character code.</P
></DIV
><H1
><A
NAME="BASELIB-WCPNCPY-3"
></A
>wcpncpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12942"
></A
><H2
>Name</H2
>wcpncpy&nbsp;--&nbsp;copy a fixed-size string of wide characters, returning a pointer to its end</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12945"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12948"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
  <TT
CLASS="FUNCTION"
>wcpncpy</TT
></CODE
>(wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12962"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcpncpy()</TT
> is the wide-character equivalent of 
<TT
CLASS="FUNCTION"
>stpncpy()</TT
>. It copies at most <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> 
wide characters from the wide-character string <TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, 
including the terminating null wide character code, to the 
array <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. Exactly <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> 
wide characters are written at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If the 
length <TT
CLASS="FUNCTION"
>wcslen()</TT
><TT
CLASS="PARAMETER"
><I
>(src)</I
></TT
> is 
smaller than <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, the remaining wide characters 
in the array <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> are filled 
with null wide character codes. If the length 
<TT
CLASS="FUNCTION"
>wcslen()</TT
><TT
CLASS="PARAMETER"
><I
>(src)</I
></TT
> is greater 
than or equal to <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, the string 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> will not be 
terminated with a null wide character code.</P
><P
>The strings may not overlap.</P
><P
>The programmer shall ensure that there is room for at least 
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
> wide characters at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12986"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>wcpncpy()</TT
> returns a pointer to the wide character one past
the last non-null wide character written.</P
></DIV
><H1
><A
NAME="BASELIB-WCSCASECMP-3"
></A
>wcscasecmp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12994"
></A
><H2
>Name</H2
>wcscasecmp&nbsp;--&nbsp;compare two wide-character strings, ignoring case</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12997"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13000"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>wcscasecmp</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s1</I
></TT
></I
></TT
>, const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s2</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13011"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcscasecmp()</TT
> is the wide-character equivalent of 
<TT
CLASS="FUNCTION"
>strcasecmp()</TT
>. It compares the wide-character string 
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> and the wide-character string 
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, ignoring case differences (towupper, towlower).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13020"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>wcscasecmp()</TT
> function shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> 
if the wide-character strings <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
> are equal except for case distinctions. It 
shall return a positive integer if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> is greater 
than <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, ignoring case. It shall return a negative 
integer if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> is less than 
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, ignoring case.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13031"
></A
><H2
>Notes</H2
><P
>The behavior of <TT
CLASS="FUNCTION"
>wcscasecmp()</TT
> depends upon the 
<CODE
CLASS="VARNAME"
>LC_CTYPE</CODE
> category of the current locale.</P
></DIV
><H1
><A
NAME="BASELIB-WCSDUP-3"
></A
>wcsdup</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13040"
></A
><H2
>Name</H2
>wcsdup&nbsp;--&nbsp;duplicate a wide-character string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13043"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13046"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
  <TT
CLASS="FUNCTION"
>wcsdup</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13054"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcsdup()</TT
> is the wide-character equivalent of 
<TT
CLASS="FUNCTION"
>strdup()</TT
>. It allocates and returns a new wide-character 
string whose initial contents is a duplicate of the wide-character string 
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.</P
><P
>Memory for the new wide-character string is obtained with 
<TT
CLASS="FUNCTION"
>malloc()</TT
>, and can be freed with 
<TT
CLASS="FUNCTION"
>free()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13065"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>wcsdup()</TT
> returns a pointer to the new wide-character 
string, or <SPAN
CLASS="RETURNVALUE"
>NULL</SPAN
> if sufficient memory was not 
available.</P
></DIV
><H1
><A
NAME="BASELIB-WCSNCASECMP-3"
></A
>wcsncasecmp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13074"
></A
><H2
>Name</H2
>wcsncasecmp&nbsp;--&nbsp;compare two fixed-size wide-character strings, ignoring case</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13077"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13078"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>wcsncasecmp</TT
></CODE
>(const wchar_t *
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13089"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcsncasecmp()</TT
> is the wide-character equivalent of 
<TT
CLASS="FUNCTION"
>strncasecmp()</TT
>. It compares the wide-character string 
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> and the wide-character string 
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, but at most <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> wide
characters from each string, ignoring case differences (towupper, towlower).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13099"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>wcscasecmp()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> 
if the wide-character strings <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, truncated to at most length 
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, are equal except for case distinctions. It 
returns a positive integer if truncated <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> is 
greater than truncated <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, ignoring case. It 
returns a negative integer if truncated <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> is 
smaller than truncated <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, ignoring case.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13111"
></A
><H2
>Notes</H2
><P
>The behavior of <TT
CLASS="FUNCTION"
>wcsncasecmp()</TT
> depends upon the 
<CODE
CLASS="VARNAME"
>LC_CTYPE</CODE
> category of the current locale.</P
></DIV
><H1
><A
NAME="BASELIB-WCSNLEN-3"
></A
>wcsnlen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13120"
></A
><H2
>Name</H2
>wcsnlen&nbsp;--&nbsp;determine the length of a fixed-size wide-character string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13123"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13126"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>wcsnlen</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>maxlen</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13137"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcsnlen()</TT
> is the wide-character equivalent of 
<TT
CLASS="FUNCTION"
>strnlen()</TT
>. It returns the number of wide-characters in 
the string <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, not including the terminating 
null wide character code, but at most <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>. 
In doing this, <TT
CLASS="FUNCTION"
>wcsnlen()</TT
> looks only at the first 
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
> wide-characters at <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> 
and never beyond <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> + <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13151"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>wcsnlen()</TT
> returns 
<TT
CLASS="FUNCTION"
>wcslen()</TT
><TT
CLASS="PARAMETER"
><I
>(s)</I
></TT
> if that is less than 
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
> if there is 
no null wide character code among the first 
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
> wide characters pointed to by 
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-WCSNRTOMBS-3"
></A
>wcsnrtombs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13165"
></A
><H2
>Name</H2
>wcsnrtombs&nbsp;--&nbsp;convert a wide character string to a multi-byte string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13168"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13171"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>wcsnrtombs</TT
></CODE
>(char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nwc</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>len</I
></TT
></I
></TT
>, mbstate_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ps</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13191"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wcsnrtombs()</TT
> is like <TT
CLASS="FUNCTION"
>wcsrtombs()</TT
>,
except that the number of wide characters to be converted, starting at 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, is limited to <TT
CLASS="PARAMETER"
><I
>nwc</I
></TT
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is not a <SPAN
CLASS="TOKEN"
>NULL</SPAN
> pointer, 
<TT
CLASS="FUNCTION"
>wcsnrtombs()</TT
> converts at most 
<TT
CLASS="PARAMETER"
><I
>nwc</I
></TT
> wide characters from the wide-character 
string <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> to a multibyte string starting at 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. At most <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes 
are written to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. The  state 
<TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> is updated.</P
><P
>The conversion is effectively performed by repeatedly calling:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>wcrtomb(dest, *src, ps)</PRE
></TD
></TR
></TABLE
>
as long as this call succeeds, and then incrementing 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> by the number of bytes written and 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> by <TT
CLASS="LITERAL"
>1</TT
>.</P
><P
>The conversion can stop for three reasons:</P
><P
><P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>A wide character has been encountered that cannot be represented as a
multibyte sequence (according to the current locale). In this case 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> is left pointing to the invalid wide character, 
(size_t)(-1) is returned, and <CODE
CLASS="VARNAME"
>errno</CODE
> is 
set to <SPAN
CLASS="ERRORNAME"
>EILSEQ</SPAN
>.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
><TT
CLASS="PARAMETER"
><I
>nws</I
></TT
> wide characters have been converted without
encountering a null wide character code, or the length limit forces a stop. 
In this case, <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> is left pointing to the next 
wide character to be converted, and the number bytes written to 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is returned.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The wide-character string has been completely converted, including the 
terminating null wide character code (which has the side effect of bringing 
back <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> to the initial state). In this case, 
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
> is set to <TT
CLASS="LITERAL"
>NULL</TT
>, and the 
number of bytes written to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, excluding the 
terminating null wide character code, is returned.</P
></LI
></UL
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>, 
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> is ignored, and the conversion proceeds 
as above, except that the converted bytes are not written 
out to memory, and that no destination length limit exists.</P
><P
>In both of the above cases, if <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> is a 
<TT
CLASS="LITERAL"
>NULL</TT
> pointer, a static anonymous state only known 
to <TT
CLASS="FUNCTION"
>wcsnrtombs()</TT
> is used instead.</P
><P
>The programmer shall ensure that there is room for at least 
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes at <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13245"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>wcsnrtombs()</TT
> returns the number of bytes that 
make up the converted part of multibyte sequence, not including 
the terminating null wide character code. If a wide character was 
encountered which could not be converted, (size_t)(-1) is returned, 
and the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> set to 
<SPAN
CLASS="ERRORNAME"
>EILSEQ</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13251"
></A
><H2
>Notes</H2
><P
>The behavior of <TT
CLASS="FUNCTION"
>wcsnrtombs()</TT
> depends on the 
<CODE
CLASS="VARNAME"
>LC_CTYPE</CODE
> category of the current locale.</P
><P
>Passing <SPAN
CLASS="TOKEN"
>NULL</SPAN
> as <TT
CLASS="PARAMETER"
><I
>ps</I
></TT
> is not 
multi-thread safe.</P
></DIV
><H1
><A
NAME="BASELIB-WCSTOQ"
></A
>wcstoq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13263"
></A
><H2
>Name</H2
>wcstoq&nbsp;--&nbsp;convert wide string to long long int representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13266"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13269"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long int 
  <TT
CLASS="FUNCTION"
>wcstoq</TT
></CODE
>(const wchar_t * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t ** restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13283"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>wcstoq()</TT
> function shall convert
the initial portion of the wide 
string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> to <TT
CLASS="LITERAL"
>long long int</TT
> 
representation. It is identical to <TT
CLASS="FUNCTION"
>wcstoll()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13292"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoll()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13296"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoll()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-WCSTOUQ"
></A
>wcstouq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13304"
></A
><H2
>Name</H2
>wcstouq&nbsp;--&nbsp;convert wide string to unsigned long long int representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13307"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13310"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long 
  <TT
CLASS="FUNCTION"
>wcstouq</TT
></CODE
>(const wchar_t * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t ** restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13324"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>wcstouq()</TT
> function shall convert
the initial portion of the wide 
string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> to <TT
CLASS="LITERAL"
>unsigned long long 
int</TT
> representation.
It is identical to <TT
CLASS="FUNCTION"
>wcstoull()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13333"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoull()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13337"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoull()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-WSCANF"
></A
>wscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13345"
></A
><H2
>Name</H2
>wscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13348"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13353"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-XDR-U-INT-3"
></A
>xdr_u_int</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13371"
></A
><H2
>Name</H2
>xdr_u_int&nbsp;--&nbsp;library routines for external data representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13374"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13377"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>xdr_u_int</TT
></CODE
>(XDR * 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>xdrs</I
></TT
></I
></TT
>, unsigned int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>up</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13387"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>xdr_u_int()</TT
> is a filter primitive that translates between
C unsigned integers and their external representations.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13393"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>1</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBM"
>13.6. Interfaces for libm</A
></H2
><P
><A
HREF="#LIB-LIBM-DEF"
>Table 13-24</A
> defines the library name and shared object name
for the libm library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBM-DEF"
></A
><P
><B
>Table 13-24. libm Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libm</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>See archLSB.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBM.1"
></A
>[ISOC99] <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBM.2"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBM.3"
></A
>[SUSv2] <A
HREF="#STD.SUSV2"
>SUSv2</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBM.4"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN13422"
>13.6.1. Math</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN13425"
>13.6.1.1. Interfaces for Math</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Math specified in <A
HREF="#TBL-LIBM-MAT-INTS"
>Table 13-25</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBM-MAT-INTS"
></A
><P
><B
>Table 13-25. libm - Math Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__finite <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>__finitef <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>__finitel <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>__fpclassify <A
HREF="#REFSTD.LIBM.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fpclassifyf <A
HREF="#REFSTD.LIBM.2"
>[LSB]</A
></TD
><TD
>__signbit <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>__signbitf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>acos <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>acosf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>acosh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>acoshf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>acoshl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>acosl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>asin <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>asinf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>asinh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>asinhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>asinhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>asinl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atan <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>atan2 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atan2f <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atan2l <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atanf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>atanh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atanhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atanhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>atanl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cabs <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cabsf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cabsl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cacos <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cacosf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cacosh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cacoshf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cacoshl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cacosl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>carg <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cargf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cargl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>casin <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>casinf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>casinh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>casinhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>casinhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>casinl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>catan <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>catanf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>catanh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>catanhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>catanhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>catanl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cbrt <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cbrtf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cbrtl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ccos <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ccosf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ccosh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ccoshf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ccoshl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ccosl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ceil <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ceilf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ceill <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cexp <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cexpf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cexpl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cimag <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cimagf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cimagl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>clog <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>clog10 <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>clog10f <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>clog10l <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>clogf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>clogl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>conj <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>conjf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>conjl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>copysign <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>copysignf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>copysignl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cos <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cosf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cosh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>coshf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>coshl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cosl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cpow <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cpowf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cpowl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cproj <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>cprojf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>cprojl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>creal <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>crealf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>creall <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csin <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csinf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csinh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>csinhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csinhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csinl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csqrt <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>csqrtf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>csqrtl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ctan <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ctanf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ctanh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ctanhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ctanhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ctanl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>dremf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>dreml <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>erf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>erfc <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>erfcf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>erfcl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>erff <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>erfl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>exp <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>exp2 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>exp2f <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>expf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>expl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>expm1 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>expm1f <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>expm1l <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fabs <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fabsf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fabsl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fdim <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fdimf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fdiml <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>feclearexcept <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fegetenv <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fegetexceptflag <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fegetround <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>feholdexcept <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>feraiseexcept <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fesetenv <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fesetexceptflag <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fesetround <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fetestexcept <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>feupdateenv <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>finite <A
HREF="#REFSTD.LIBM.3"
>[SUSv2]</A
></TD
><TD
>finitef <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>finitel <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>floor <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>floorf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>floorl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fma <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fmaf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fmal <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fmax <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fmaxf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fmaxl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fmin <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fminf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fminl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fmod <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fmodf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>fmodl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>frexp <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>frexpf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>frexpl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>gamma <A
HREF="#REFSTD.LIBM.3"
>[SUSv2]</A
></TD
><TD
>gammaf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>gammal <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>hypot <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>hypotf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>hypotl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ilogb <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ilogbf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ilogbl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>j0 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>j0f <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>j0l <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>j1 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>j1f <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>j1l <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>jn <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>jnf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>jnl <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>ldexp <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ldexpf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ldexpl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lgamma <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>lgamma_r <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>lgammaf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lgammaf_r <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>lgammal <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>lgammal_r <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>llrint <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>llrintf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>llrintl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>llround <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>llroundf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>llroundl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>log10 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log10f <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log10l <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log1p <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>log1pf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log1pl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log2 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>log2f <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>log2l <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>logb <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>logbf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>logbl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>logf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>logl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lrint <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lrintf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>lrintl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lround <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lroundf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>lroundl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>matherr <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>modf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>modff <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>modfl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>nan <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nanf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nanl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nearbyint <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>nearbyintf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nearbyintl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nextafter <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nextafterf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>nextafterl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nexttoward <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nexttowardf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>nexttowardl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pow <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>pow10 <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>pow10f <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>pow10l <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>powf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>powl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>remainder <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>remainderf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>remainderl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>remquo <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>remquof <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>remquol <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>rint <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>rintf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>rintl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>round <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>roundf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>roundl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>scalb <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>scalbf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>scalbl <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>scalbln <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>scalblnf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>scalblnl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>scalbn <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>scalbnf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>scalbnl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>significand <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>significandf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>significandl <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>sin <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>sincos <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>sincosf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>sincosl <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>sinf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>sinh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sinhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>sinhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>sinl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>sqrt <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sqrtf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>sqrtl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tan <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tanf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>tanh <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tanhf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tanhl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tanl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>tgamma <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tgammaf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>tgammal <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>trunc <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>truncf <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>truncl <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>y0 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>y0f <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>y0l <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>y1 <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>y1f <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>y1l <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
></TR
><TR
><TD
>yn <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>ynf <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>ynl <A
HREF="#REFSTD.LIBM.1"
>[ISOC99]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Math specified in <A
HREF="#TBL-LIBM-MAT-DATA"
>Table 13-26</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBM-MAT-DATA"
></A
><P
><B
>Table 13-26. libm - Math Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>signgam <A
HREF="#REFSTD.LIBM.4"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBM-DDEFS"
>13.7. Data Definitions for libm</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libm.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN14725"
>13.7.1. complex.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define complex	_Complex

extern double cabs(double complex);
extern float cabsf(float complex);
extern long double cabsl(long double complex);
extern double complex cacos(double complex);
extern float complex cacosf(float complex);
extern double complex cacosh(double complex);
extern float complex cacoshf(float complex);
extern long double complex cacoshl(long double complex);
extern long double complex cacosl(long double complex);
extern double carg(double complex);
extern float cargf(float complex);
extern long double cargl(long double complex);
extern double complex casin(double complex);
extern float complex casinf(float complex);
extern double complex casinh(double complex);
extern float complex casinhf(float complex);
extern long double complex casinhl(long double complex);
extern long double complex casinl(long double complex);
extern double complex catan(double complex);
extern float complex catanf(float complex);
extern double complex catanh(double complex);
extern float complex catanhf(float complex);
extern long double complex catanhl(long double complex);
extern long double complex catanl(long double complex);
extern double complex ccos(double complex);
extern float complex ccosf(float complex);
extern double complex ccosh(double complex);
extern float complex ccoshf(float complex);
extern long double complex ccoshl(long double complex);
extern long double complex ccosl(long double complex);
extern double complex cexp(double complex);
extern float complex cexpf(float complex);
extern long double complex cexpl(long double complex);
extern double cimag(double complex);
extern float cimagf(float complex);
extern long double cimagl(long double complex);
extern double complex clog(double complex);
extern float complex clog10f(float complex);
extern long double complex clog10l(long double complex);
extern float complex clogf(float complex);
extern long double complex clogl(long double complex);
extern double complex conj(double complex);
extern float complex conjf(float complex);
extern long double complex conjl(long double complex);
extern double complex cpow(double complex, double complex);
extern float complex cpowf(float complex, float complex);
extern long double complex cpowl(long double complex, long double complex);
extern double complex cproj(double complex);
extern float complex cprojf(float complex);
extern long double complex cprojl(long double complex);
extern double creal(double complex);
extern float crealf(float complex);
extern long double creall(long double complex);
extern double complex csin(double complex);
extern float complex csinf(float complex);
extern double complex csinh(double complex);
extern float complex csinhf(float complex);
extern long double complex csinhl(long double complex);
extern long double complex csinl(long double complex);
extern double complex csqrt(double complex);
extern float complex csqrtf(float complex);
extern long double complex csqrtl(long double complex);
extern double complex ctan(double complex);
extern float complex ctanf(float complex);
extern double complex ctanh(double complex);
extern float complex ctanhf(float complex);
extern long double complex ctanhl(long double complex);
extern long double complex ctanl(long double complex);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN14729"
>13.7.2. fenv.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int feclearexcept(int);
extern int fegetenv(fenv_t *);
extern int fegetexceptflag(fexcept_t *, int);
extern int fegetround(void);
extern int feholdexcept(fenv_t *);
extern int feraiseexcept(int);
extern int fesetenv(const fenv_t *);
extern int fesetexceptflag(const fexcept_t *, int);
extern int fesetround(int);
extern int fetestexcept(int);
extern int feupdateenv(const fenv_t *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN14733"
>13.7.3. math.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define DOMAIN	1
#define SING	2

struct exception {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
};

#define FP_NAN	0
#define FP_INFINITE	1
#define FP_ZERO	2
#define FP_SUBNORMAL	3
#define FP_NORMAL	4

#define isnormal(x)	(fpclassify (x) == FP_NORMAL)
#define isfinite(x)	\
	(sizeof (x) == sizeof (float) ? __finitef (x) : sizeof (x) == sizeof (double)? __finite (x) : __finitel (x))
#define isinf(x)	\
	(sizeof (x) == sizeof (float) ? __isinff (x): sizeof (x) == sizeof (double) ? __isinf (x) : __isinfl (x))
#define isnan(x)	\
	(sizeof (x) == sizeof (float) ? __isnanf (x)  : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x))

#define HUGE_VAL	0x1.0p2047
#define HUGE_VALF	0x1.0p255f
#define HUGE_VALL	0x1.0p32767L

#define NAN	((float)0x7fc00000UL)
#define M_1_PI	0.31830988618379067154
#define M_LOG10E	0.43429448190325182765
#define M_2_PI	0.63661977236758134308
#define M_LN2	0.69314718055994530942
#define M_SQRT1_2	0.70710678118654752440
#define M_PI_4	0.78539816339744830962
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2	1.41421356237309504880
#define M_LOG2E	1.4426950408889634074
#define M_PI_2	1.57079632679489661923
#define M_LN10	2.30258509299404568402
#define M_E	2.7182818284590452354
#define M_PI	3.14159265358979323846
#define INFINITY	HUGE_VALF

#define MATH_ERRNO	1
#define MATH_ERREXCEPT	2

#define isunordered(u, v)	\
	(__extension__({ __typeof__(u) __u = (u); __typeof__(v) __v = (v);fpclassify (__u) == FP_NAN || fpclassify (__v) == FP_NAN; }))
#define islessgreater(x, y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; (__x &#60; __y || __y &#60; __x); }))
#define isless(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#60; __y; }))
#define islessequal(x, y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#60;= __y; }))
#define isgreater(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#62; __y; }))
#define isgreaterequal(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#62;= __y; }))

extern int __finite(double);
extern int __finitef(float);
extern int __finitel(long double);
extern int __isinf(double);
extern int __isinff(float);
extern int __isinfl(long double);
extern int __isnan(double);
extern int __isnanf(float);
extern int __isnanl(long double);
extern int __signbit(double);
extern int __signbitf(float);
extern int __fpclassify(double);
extern int __fpclassifyf(float);
extern int __fpclassifyl(long double);
extern int signgam(void);
extern double copysign(double, double);
extern int finite(double);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double modf(double, double *);
extern double acos(double);
extern double acosh(double);
extern double asinh(double);
extern double atanh(double);
extern double asin(double);
extern double atan(double);
extern double atan2(double, double);
extern double cbrt(double);
extern double ceil(double);
extern double cos(double);
extern double cosh(double);
extern double erf(double);
extern double erfc(double);
extern double exp(double);
extern double expm1(double);
extern double fabs(double);
extern double floor(double);
extern double fmod(double, double);
extern double gamma(double);
extern double hypot(double, double);
extern int ilogb(double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double lgamma(double);
extern double log(double);
extern double log10(double);
extern double log1p(double);
extern double logb(double);
extern double nextafter(double, double);
extern double pow(double, double);
extern double remainder(double, double);
extern double rint(double);
extern double scalb(double, double);
extern double sin(double);
extern double sinh(double);
extern double sqrt(double);
extern double tan(double);
extern double tanh(double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
extern float copysignf(float, float);
extern long double copysignl(long double, long double);
extern int finitef(float);
extern int finitel(long double);
extern float frexpf(float, int *);
extern long double frexpl(long double, int *);
extern float ldexpf(float, int);
extern long double ldexpl(long double, int);
extern float modff(float, float *);
extern long double modfl(long double, long double *);
extern double scalbln(double, long int);
extern float scalblnf(float, long int);
extern long double scalblnl(long double, long int);
extern double scalbn(double, int);
extern float scalbnf(float, int);
extern long double scalbnl(long double, int);
extern float acosf(float);
extern float acoshf(float);
extern long double acoshl(long double);
extern long double acosl(long double);
extern float asinf(float);
extern float asinhf(float);
extern long double asinhl(long double);
extern long double asinl(long double);
extern float atan2f(float, float);
extern long double atan2l(long double, long double);
extern float atanf(float);
extern float atanhf(float);
extern long double atanhl(long double);
extern long double atanl(long double);
extern float cbrtf(float);
extern long double cbrtl(long double);
extern float ceilf(float);
extern long double ceill(long double);
extern float cosf(float);
extern float coshf(float);
extern long double coshl(long double);
extern long double cosl(long double);
extern float dremf(float, float);
extern long double dreml(long double, long double);
extern float erfcf(float);
extern long double erfcl(long double);
extern float erff(float);
extern long double erfl(long double);
extern double exp2(double);
extern float exp2f(float);
extern long double exp2l(long double);
extern float expf(float);
extern long double expl(long double);
extern float expm1f(float);
extern long double expm1l(long double);
extern float fabsf(float);
extern long double fabsl(long double);
extern double fdim(double, double);
extern float fdimf(float, float);
extern long double fdiml(long double, long double);
extern float floorf(float);
extern long double floorl(long double);
extern double fma(double, double, double);
extern float fmaf(float, float, float);
extern long double fmal(long double, long double, long double);
extern double fmax(double, double);
extern float fmaxf(float, float);
extern long double fmaxl(long double, long double);
extern double fmin(double, double);
extern float fminf(float, float);
extern long double fminl(long double, long double);
extern float fmodf(float, float);
extern long double fmodl(long double, long double);
extern float gammaf(float);
extern long double gammal(long double);
extern float hypotf(float, float);
extern long double hypotl(long double, long double);
extern int ilogbf(float);
extern int ilogbl(long double);
extern float j0f(float);
extern long double j0l(long double);
extern float j1f(float);
extern long double j1l(long double);
extern float jnf(int, float);
extern long double jnl(int, long double);
extern double lgamma_r(double, int *);
extern float lgammaf(float);
extern float lgammaf_r(float, int *);
extern long double lgammal(long double);
extern long double lgammal_r(long double, int *);
extern long long int llrint(double);
extern long long int llrintf(float);
extern long long int llrintl(long double);
extern long long int llround(double);
extern long long int llroundf(float);
extern long long int llroundl(long double);
extern float log10f(float);
extern long double log10l(long double);
extern float log1pf(float);
extern long double log1pl(long double);
extern double log2(double);
extern float log2f(float);
extern long double log2l(long double);
extern float logbf(float);
extern long double logbl(long double);
extern float logf(float);
extern long double logl(long double);
extern long int lrint(double);
extern long int lrintf(float);
extern long int lrintl(long double);
extern long int lround(double);
extern long int lroundf(float);
extern long int lroundl(long double);
extern int matherr(struct exception *);
extern double nan(const char *);
extern float nanf(const char *);
extern long double nanl(const char *);
extern double nearbyint(double);
extern float nearbyintf(float);
extern long double nearbyintl(long double);
extern float nextafterf(float, float);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern double pow10(double);
extern float pow10f(float);
extern long double pow10l(long double);
extern float powf(float, float);
extern long double powl(long double, long double);
extern float remainderf(float, float);
extern long double remainderl(long double, long double);
extern double remquo(double, double, int *);
extern float remquof(float, float, int *);
extern long double remquol(long double, long double, int *);
extern float rintf(float);
extern long double rintl(long double);
extern double round(double);
extern float roundf(float);
extern long double roundl(long double);
extern float scalbf(float, float);
extern long double scalbl(long double, long double);
extern double significand(double);
extern float significandf(float);
extern long double significandl(long double);
extern void sincos(double, double *, double *);
extern void sincosf(float, float *, float *);
extern void sincosl(long double, long double *, long double *);
extern float sinf(float);
extern float sinhf(float);
extern long double sinhl(long double);
extern long double sinl(long double);
extern float sqrtf(float);
extern long double sqrtl(long double);
extern float tanf(float);
extern float tanhf(float);
extern long double tanhl(long double);
extern long double tanl(long double);
extern double tgamma(double);
extern float tgammaf(float);
extern long double tgammal(long double);
extern double trunc(double);
extern float truncf(float);
extern long double truncl(long double);
extern float y0f(float);
extern long double y0l(long double);
extern float y1f(float);
extern long double y1l(long double);
extern float ynf(int, float);
extern long double ynl(int, long double);
extern int __fpclassifyl(long double);
extern int __fpclassifyl(long double);
extern int __signbitl(long double);
extern int __signbitl(long double);
extern int __signbitl(long double);
extern long double exp2l(long double);
extern long double exp2l(long double);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBMMAN"
>13.8. Interface Definitions for libm</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB---FPCLASSIFY"
>__fpclassify</A
>&nbsp;--&nbsp;Classify real floating type</DT
><DT
><A
HREF="#BASELIB---FPCLASSIFYF"
>__fpclassifyf</A
>&nbsp;--&nbsp;Classify real floating type</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libm and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBM"
>Section 13.6</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB---FPCLASSIFY"
></A
>__fpclassify</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14746"
></A
><H2
>Name</H2
>__fpclassify&nbsp;--&nbsp;Classify real floating type</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14749"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14750"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fpclassify</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14757"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__fpclassify()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>fpclassify()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__fpclassify()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__fpclassify()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FPCLASSIFYF"
></A
>__fpclassifyf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14770"
></A
><H2
>Name</H2
>__fpclassifyf&nbsp;--&nbsp;Classify real floating type</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14773"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14774"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fpclassifyf</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14781"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__fpclassifyf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>fpclassifyf()</TT
> in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__fpclassifyf()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__fpclassifyf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPTHREAD"
>13.9. Interfaces for libpthread</A
></H2
><P
><A
HREF="#LIB-LIBPTHREAD-DEF"
>Table 13-27</A
> defines the library name and shared object name
for the libpthread library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBPTHREAD-DEF"
></A
><P
><B
>Table 13-27. libpthread Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libpthread</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libpthread.so.0</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.1"
></A
>[LFS] <A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.2"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.3"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN14812"
>13.9.1. Realtime Threads</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN14815"
>13.9.1.1. Interfaces for Realtime Threads</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Realtime Threads specified in <A
HREF="#TBL-LIBPTHREAD-REA-INTS"
>Table 13-28</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-REA-INTS"
></A
><P
><B
>Table 13-28. libpthread - Realtime Threads Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pthread_attr_getinheritsched <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_getschedpolicy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_getscope <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setinheritsched <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedpolicy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setscope <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_getschedparam <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_setschedparam <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_setschedprio(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN14865"
>13.9.2. Advanced Realtime Threads</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN14868"
>13.9.2.1. Interfaces for Advanced Realtime Threads</A
></H4
><P
>No external functions are defined for libpthread - Advanced Realtime Threads
in this part of the specification. See also the relevant architecture specific supplement.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN14871"
>13.9.3. Posix Threads</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN14874"
>13.9.3.1. Interfaces for Posix Threads</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Posix Threads specified in <A
HREF="#TBL-LIBPTHREAD-POS-INTS"
>Table 13-29</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-POS-INTS"
></A
><P
><B
>Table 13-29. libpthread - Posix Threads Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_pthread_cleanup_pop <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>_pthread_cleanup_push <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>pthread_attr_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_getdetachstate <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_attr_getguardsize <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_getschedparam <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_getstack <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_getstackaddr <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstacksize <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setdetachstate <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setguardsize <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedparam <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setstack <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setstackaddr <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setstacksize <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_cancel <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_cond_broadcast <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_cond_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_cond_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_cond_signal <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_cond_timedwait <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_cond_wait <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_condattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_condattr_getpshared <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_condattr_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_condattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_create <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_detach <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_equal <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_exit <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_getconcurrency <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_getspecific <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_join <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_key_create <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_key_delete <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_kill <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutex_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutex_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutex_lock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_mutex_trylock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutex_unlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutexattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutexattr_getpshared <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_mutexattr_gettype <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutexattr_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutexattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_mutexattr_settype <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_once <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_rdlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_rwlock_timedrdlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_timedwrlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_tryrdlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_trywrlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_rwlock_unlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlock_wrlock <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlockattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlockattr_getpshared <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_rwlockattr_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_rwlockattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_self <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_setcancelstate <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_setcanceltype <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_setconcurrency <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_setspecific <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_sigmask <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_testcancel <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_close <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_destroy <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_getvalue <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sem_init <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_open <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_post <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_timedwait <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>sem_trywait <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_unlink <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>sem_wait <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15219"
>13.9.4. Thread aware versions of libc interfaces</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15222"
>13.9.4.1. Interfaces for Thread aware versions of libc interfaces</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Thread aware versions of libc interfaces specified in <A
HREF="#TBL-LIBPTHREAD-THR-INTS"
>Table 13-30</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-THR-INTS"
></A
><P
><B
>Table 13-30. libpthread - Thread aware versions of libc interfaces Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>lseek64 <A
HREF="#REFSTD.LIBPTHREAD.1"
>[LFS]</A
></TD
><TD
>open64 <A
HREF="#REFSTD.LIBPTHREAD.1"
>[LFS]</A
></TD
><TD
>pread <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pread64 <A
HREF="#REFSTD.LIBPTHREAD.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>pwrite <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pwrite64 <A
HREF="#REFSTD.LIBPTHREAD.1"
>[LFS]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPTHREAD-DDEFS"
>13.10. Data Definitions for libpthread</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libpthread.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15264"
>13.10.1. pthread.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define PTHREAD_SCOPE_SYSTEM	0
#define PTHREAD_MUTEX_DEFAULT	1
#define PTHREAD_MUTEX_NORMAL	1
#define PTHREAD_SCOPE_PROCESS	1
#define PTHREAD_MUTEX_RECURSIVE	2
#define PTHREAD_RWLOCK_DEFAULT_NP	2
#define PTHREAD_MUTEX_ERRORCHECK	3
#define PTHREAD_MUTEX_INITIALIZER	\
	{0,0,0,PTHREAD_MUTEX_NORMAL,__LOCK_INITIALIZER}
#define PTHREAD_RWLOCK_INITIALIZER	\
        { __LOCK_INITIALIZER, 0, NULL, NULL, NULL,PTHREAD_RWLOCK_DEFAULT_NP,\
        PTHREAD_PROCESS_PRIVATE }
#define pthread_cleanup_push(routine,arg)	\
        {struct _pthread_cleanup_buffer _buffer;\
        _pthread_cleanup_push(&#38;_buffer,(routine),(arg));
#define pthread_cleanup_pop(execute)	_pthread_cleanup_pop(&#38;_buffer,(execute));}
#define __LOCK_INITIALIZER	{ 0, 0 }
#define PTHREAD_COND_INITIALIZER	{__LOCK_INITIALIZER,0}

struct _pthread_cleanup_buffer {
    void (*__routine) (void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef long long int __pthread_cond_align_t;

typedef unsigned long int pthread_t;
struct _pthread_fastlock {
    long int __status;
    int __spinlock;
};

typedef struct _pthread_descr_struct *_pthread_descr;

typedef struct {
    int __m_reserved;
    int __m_count;
    _pthread_descr __m_owner;
    int __m_kind;
    struct _pthread_fastlock __m_lock;
} pthread_mutex_t;
typedef struct {
    int __mutexkind;
} pthread_mutexattr_t;

typedef struct {
    int __detachstate;
    int __schedpolicy;
    struct sched_param __schedparam;
    int __inheritsched;
    int __scope;
    size_t __guardsize;
    int __stackaddr_set;
    void *__stackaddr;
    unsigned long int __stacksize;
} pthread_attr_t;

typedef struct {
    struct _pthread_fastlock __c_lock;
    _pthread_descr __c_waiting;
    char __padding[48 - sizeof(struct _pthread_fastlock) -
		   sizeof(_pthread_descr) -
		   sizeof(__pthread_cond_align_t)];
    __pthread_cond_align_t __align;
} pthread_cond_t;
typedef struct {
    int __dummy;
} pthread_condattr_t;

typedef struct _pthread_rwlock_t {
    struct _pthread_fastlock __rw_lock;
    int __rw_readers;
    _pthread_descr __rw_writer;
    _pthread_descr __rw_read_waiting;
    _pthread_descr __rw_write_waiting;
    int __rw_kind;
    int __rw_pshared;
} pthread_rwlock_t;
typedef struct {
    int __lockkind;
    int __pshared;
} pthread_rwlockattr_t;

#define PTHREAD_CREATE_JOINABLE	0
#define PTHREAD_INHERIT_SCHED	0
#define PTHREAD_ONCE_INIT	0
#define PTHREAD_PROCESS_PRIVATE	0
#define PTHREAD_CREATE_DETACHED	1
#define PTHREAD_EXPLICIT_SCHED	1
#define PTHREAD_PROCESS_SHARED	1

#define PTHREAD_CANCELED	((void*)-1)
#define PTHREAD_CANCEL_DEFERRED	0
#define PTHREAD_CANCEL_ENABLE	0
#define PTHREAD_CANCEL_ASYNCHRONOUS	1
#define PTHREAD_CANCEL_DISABLE	1

extern void _pthread_cleanup_pop(struct _pthread_cleanup_buffer *, int);
extern void _pthread_cleanup_push(struct _pthread_cleanup_buffer *,
				  void (*__routine) (void *)
				  , void *);
extern int pthread_attr_destroy(pthread_attr_t *);
extern int pthread_attr_getdetachstate(const typedef struct {
				       int __detachstate;
				       int __schedpolicy;
				       struct sched_param __schedparam;
				       int __inheritsched;
				       int __scope;
				       size_t __guardsize;
				       int __stackaddr_set;
				       void *__stackaddr;
				       unsigned long int __stacksize;}
				       pthread_attr_t *, int *);
extern int pthread_attr_getinheritsched(const typedef struct {
					int __detachstate;
					int __schedpolicy;
					struct sched_param __schedparam;
					int __inheritsched;
					int __scope;
					size_t __guardsize;
					int __stackaddr_set;
					void *__stackaddr;
					unsigned long int __stacksize;}
					pthread_attr_t *, int *);
extern int pthread_attr_getschedparam(const typedef struct {
				      int __detachstate;
				      int __schedpolicy;
				      struct sched_param __schedparam;
				      int __inheritsched;
				      int __scope;
				      size_t __guardsize;
				      int __stackaddr_set;
				      void *__stackaddr;
				      unsigned long int __stacksize;}
				      pthread_attr_t *, struct sched_param {
				      int sched_priority;}

				      *);
extern int pthread_attr_getschedpolicy(const typedef struct {
				       int __detachstate;
				       int __schedpolicy;
				       struct sched_param __schedparam;
				       int __inheritsched;
				       int __scope;
				       size_t __guardsize;
				       int __stackaddr_set;
				       void *__stackaddr;
				       unsigned long int __stacksize;}
				       pthread_attr_t *, int *);
extern int pthread_attr_getscope(const typedef struct {
				 int __detachstate;
				 int __schedpolicy;
				 struct sched_param __schedparam;
				 int __inheritsched;
				 int __scope;
				 size_t __guardsize;
				 int __stackaddr_set;
				 void *__stackaddr;
				 unsigned long int __stacksize;}
				 pthread_attr_t *, int *);
extern int pthread_attr_init(pthread_attr_t *);
extern int pthread_attr_setdetachstate(pthread_attr_t *, int);
extern int pthread_attr_setinheritsched(pthread_attr_t *, int);
extern int pthread_attr_setschedparam(pthread_attr_t *, const struct sched_param {
				      int sched_priority;}

				      *);
extern int pthread_attr_setschedpolicy(pthread_attr_t *, int);
extern int pthread_attr_setscope(pthread_attr_t *, int);
extern int pthread_cancel(typedef unsigned long int pthread_t);
extern int pthread_cond_broadcast(pthread_cond_t *);
extern int pthread_cond_destroy(pthread_cond_t *);
extern int pthread_cond_init(pthread_cond_t *, const typedef struct {
			     int __dummy;}

			     pthread_condattr_t *);
extern int pthread_cond_signal(pthread_cond_t *);
extern int pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec {
				  time_t tv_sec; long int tv_nsec;}

				  *);
extern int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
extern int pthread_condattr_destroy(pthread_condattr_t *);
extern int pthread_condattr_init(pthread_condattr_t *);
extern int pthread_create(pthread_t *, const typedef struct {
			  int __detachstate;
			  int __schedpolicy;
			  struct sched_param __schedparam;
			  int __inheritsched;
			  int __scope;
			  size_t __guardsize;
			  int __stackaddr_set;
			  void *__stackaddr;
			  unsigned long int __stacksize;}
			  pthread_attr_t *,
			  void *(*__start_routine) (void *p1)
			  , void *);
extern int pthread_detach(typedef unsigned long int pthread_t);
extern int pthread_equal(typedef unsigned long int pthread_t,
			 typedef unsigned long int pthread_t);
extern void pthread_exit(void *);
extern int pthread_getschedparam(typedef unsigned long int pthread_t,
				 int *, struct sched_param {
				 int sched_priority;}

				 *);
extern void *pthread_getspecific(typedef unsigned int pthread_key_t);
extern int pthread_join(typedef unsigned long int pthread_t, void **);
extern int pthread_key_create(pthread_key_t *, void (*destr_func) (void *)
    );
extern int pthread_key_delete(typedef unsigned int pthread_key_t);
extern int pthread_mutex_destroy(pthread_mutex_t *);
extern int pthread_mutex_init(pthread_mutex_t *, const typedef struct {
			      int __mutexkind;}

			      pthread_mutexattr_t *);
extern int pthread_mutex_lock(pthread_mutex_t *);
extern int pthread_mutex_trylock(pthread_mutex_t *);
extern int pthread_mutex_unlock(pthread_mutex_t *);
extern int pthread_mutexattr_destroy(pthread_mutexattr_t *);
extern int pthread_mutexattr_init(pthread_mutexattr_t *);
extern int pthread_once(pthread_once_t *, void (*init_routine) (void)
    );
extern int pthread_rwlock_destroy(pthread_rwlock_t *);
extern int pthread_rwlock_init(pthread_rwlock_t *, pthread_rwlockattr_t *);
extern int pthread_rwlock_rdlock(pthread_rwlock_t *);
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *);
extern int pthread_rwlock_unlock(pthread_rwlock_t *);
extern int pthread_rwlock_wrlock(pthread_rwlock_t *);
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
extern int pthread_rwlockattr_getpshared(const typedef struct {
					 int __lockkind; int __pshared;}
					 pthread_rwlockattr_t *, int *);
extern int pthread_rwlockattr_init(pthread_rwlockattr_t *);
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
extern typedef unsigned long int pthread_t pthread_self(void);
extern int pthread_setcancelstate(int, int *);
extern int pthread_setcanceltype(int, int *);
extern int pthread_setschedparam(typedef unsigned long int pthread_t, int, const struct sched_param {
				 int sched_priority;}

				 *);
extern int pthread_setspecific(typedef unsigned int pthread_key_t,
			       const void *);
extern void pthread_testcancel(void);
extern int pthread_attr_getguardsize(const typedef struct {
				     int __detachstate;
				     int __schedpolicy;
				     struct sched_param __schedparam;
				     int __inheritsched;
				     int __scope;
				     size_t __guardsize;
				     int __stackaddr_set;
				     void *__stackaddr;
				     unsigned long int __stacksize;}
				     pthread_attr_t *, size_t *);
extern int pthread_attr_setguardsize(pthread_attr_t *,
				     typedef unsigned long int size_t);
extern int pthread_attr_setstackaddr(pthread_attr_t *, void *);
extern int pthread_attr_getstackaddr(const typedef struct {
				     int __detachstate;
				     int __schedpolicy;
				     struct sched_param __schedparam;
				     int __inheritsched;
				     int __scope;
				     size_t __guardsize;
				     int __stackaddr_set;
				     void *__stackaddr;
				     unsigned long int __stacksize;}
				     pthread_attr_t *, void **);
extern int pthread_attr_setstacksize(pthread_attr_t *,
				     typedef unsigned long int size_t);
extern int pthread_attr_getstacksize(const typedef struct {
				     int __detachstate;
				     int __schedpolicy;
				     struct sched_param __schedparam;
				     int __inheritsched;
				     int __scope;
				     size_t __guardsize;
				     int __stackaddr_set;
				     void *__stackaddr;
				     unsigned long int __stacksize;}
				     pthread_attr_t *, size_t *);
extern int pthread_mutexattr_gettype(const typedef struct {
				     int __mutexkind;}
				     pthread_mutexattr_t *, int *);
extern int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
extern int pthread_getconcurrency(void);
extern int pthread_setconcurrency(int);
extern int pthread_attr_getstack(const typedef struct {
				 int __detachstate;
				 int __schedpolicy;
				 struct sched_param __schedparam;
				 int __inheritsched;
				 int __scope;
				 size_t __guardsize;
				 int __stackaddr_set;
				 void *__stackaddr;
				 unsigned long int __stacksize;}
				 pthread_attr_t *, void **, size_t *);
extern int pthread_attr_setstack(pthread_attr_t *, void *,
				 typedef unsigned long int size_t);
extern int pthread_condattr_getpshared(const typedef struct {
				       int __dummy;}
				       pthread_condattr_t *, int *);
extern int pthread_condattr_setpshared(pthread_condattr_t *, int);
extern int pthread_mutexattr_getpshared(const typedef struct {
					int __mutexkind;}
					pthread_mutexattr_t *, int *);
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *, const struct timespec {
				      time_t tv_sec; long int tv_nsec;}

				      *);
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *, const struct timespec {
				      time_t tv_sec; long int tv_nsec;}

				      *);
extern int __register_atfork(void (*prepare) (void)
			     , void (*parent) (void)
			     , void (*child) (void)
			     , void *);
extern int pthread_setschedprio(typedef unsigned long int pthread_t, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15268"
>13.10.2. semaphore.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct {
    struct _pthread_fastlock __sem_lock;
    int __sem_value;
    _pthread_descr __sem_waiting;
} sem_t;

#define SEM_FAILED	((sem_t*)0)

#define SEM_VALUE_MAX	((int)((~0u)&#62;&#62;1))

extern int sem_close(sem_t *);
extern int sem_destroy(sem_t *);
extern int sem_getvalue(sem_t *, int *);
extern int sem_init(sem_t *, int, unsigned int);
extern sem_t *sem_open(const char *, int, ...);
extern int sem_post(sem_t *);
extern int sem_trywait(sem_t *);
extern int sem_unlink(const char *);
extern int sem_wait(sem_t *);
extern int sem_timedwait(sem_t *, const struct timespec *);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPTHREADMAN"
>13.11. Interface Definitions for libpthread</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-POP"
>_pthread_cleanup_pop</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-PUSH"
>_pthread_cleanup_push</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libpthread and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBPTHREAD"
>Section 13.9</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB--PTHREAD-CLEANUP-POP"
></A
>_pthread_cleanup_pop</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15281"
></A
><H2
>Name</H2
>_pthread_cleanup_pop&nbsp;--&nbsp;establish cancellation handlers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15284"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15285"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>_pthread_cleanup_pop</TT
></CODE
>(struct _pthread_cleanup_buffer *, int);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15292"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_pop()</TT
> function provides
an implementation of the <TT
CLASS="FUNCTION"
>pthread_cleanup_pop()</TT
> macro
described in
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>.</P
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_pop()</TT
> function is not in the
source standard; it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--PTHREAD-CLEANUP-PUSH"
></A
>_pthread_cleanup_push</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15305"
></A
><H2
>Name</H2
>_pthread_cleanup_push&nbsp;--&nbsp;establish cancellation handlers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15308"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15309"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>_pthread_cleanup_push</TT
></CODE
>(struct _pthread_cleanup_buffer *, void (*) (void *), void *);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15317"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_push()</TT
> function provides
an implementation of the <TT
CLASS="FUNCTION"
>pthread_cleanup_push()</TT
> macro
described in
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>.</P
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_push()</TT
> function is not in the
source standard; it is only in the binary standard.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBGCC-S"
>13.12. Interfaces for libgcc_s</A
></H2
><P
><A
HREF="#LIB-LIBGCC-S-DEF"
>Table 13-31</A
> defines the library name and shared object name
for the libgcc_s library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBGCC-S-DEF"
></A
><P
><B
>Table 13-31. libgcc_s Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libgcc_s</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libgcc_s.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15341"
>13.12.1. Unwind Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15344"
>13.12.1.1. Interfaces for Unwind Library</A
></H4
><P
>No external functions are defined for libgcc_s - Unwind Library
in this part of the specification. See also the relevant architecture specific supplement.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBGCC-S-DDEFS"
>13.13. Data Definitions for libgcc_s</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libgcc_s.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15353"
>13.13.1. unwind.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct _Unwind_Context;

typedef void *_Unwind_Ptr;
typedef unsigned int _Unwind_Word;

typedef enum {
    _URC_NO_REASON, _URC_FOREIGN_EXCEPTION_CAUGHT =
	1, _URC_FATAL_PHASE2_ERROR = 2, _URC_FATAL_PHASE1_ERROR =
	3, _URC_NORMAL_STOP = 4, _URC_END_OF_STACK =
	5, _URC_HANDLER_FOUND = 6, _URC_INSTALL_CONTEXT =
	7, _URC_CONTINUE_UNWIND = 8
} _Unwind_Reason_Code;

struct _Unwind_Exception {
    u_int64_t exception_class;
    _Unwind_Exception_Cleanup_Fn exception_cleanup;
    u_int64_t private_1;
    u_int64_t private_2;
};

#define _UA_SEARCH_PHASE	1
#define _UA_END_OF_STACK	16
#define _UA_CLEANUP_PHASE	2
#define _UA_HANDLER_FRAME	4
#define _UA_FORCE_UNWIND	8

extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern fde *_Unwind_Find_FDE(void *, struct dwarf_eh_base *);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(struct _Unwind_Context
						   *);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern fde *_Unwind_Find_FDE(void *, struct dwarf_eh_base *);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Ptr _Unwind_GetDataRelBase(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(struct _Unwind_Context
						   *);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetTextRelBase(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Ptr _Unwind_GetDataRelBase(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(struct _Unwind_Context
						   *);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetTextRelBase(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern fde *_Unwind_Find_FDE(void *, struct dwarf_eh_base *);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Ptr _Unwind_GetDataRelBase(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(struct _Unwind_Context
						   *);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetTextRelBase(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern fde *_Unwind_Find_FDE(void *, struct dwarf_eh_base *);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Ptr _Unwind_GetDataRelBase(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(struct _Unwind_Context
						   *);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetTextRelBase(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern fde *_Unwind_Find_FDE(void *, struct dwarf_eh_base *);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Ptr _Unwind_GetDataRelBase(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(void);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetTextRelBase(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern fde *_Unwind_Find_FDE(void *, struct dwarf_eh_base *);
extern _Unwind_Ptr _Unwind_ForcedUnwind(struct _Unwind_Exception *,
					_Unwind_Stop_Fn, void *);
extern _Unwind_Ptr _Unwind_GetDataRelBase(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetLanguageSpecificData(void);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetTextRelBase(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern _Unwind_Word _Unwind_GetBSP(struct _Unwind_Context *);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBDL"
>13.14. Interfaces for libdl</A
></H2
><P
><A
HREF="#LIB-LIBDL-DEF"
>Table 13-32</A
> defines the library name and shared object name
for the libdl library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBDL-DEF"
></A
><P
><B
>Table 13-32. libdl Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libdl</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libdl.so.2</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBDL.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBDL.2"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15377"
>13.14.1. Dynamic Loader</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15380"
>13.14.1.1. Interfaces for Dynamic Loader</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Dynamic Loader specified in <A
HREF="#TBL-LIBDL-DYN-INTS"
>Table 13-33</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBDL-DYN-INTS"
></A
><P
><B
>Table 13-33. libdl - Dynamic Loader Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>dladdr <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
><TD
>dlclose <A
HREF="#REFSTD.LIBDL.2"
>[SUSv3]</A
></TD
><TD
>dlerror <A
HREF="#REFSTD.LIBDL.2"
>[SUSv3]</A
></TD
><TD
>dlopen <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>dlsym <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBDL-DDEFS"
>13.15. Data Definitions for libdl</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libdl.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15419"
>13.15.1. dlfcn.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RTLD_NEXT	((void *) -1l)
#define RTLD_LOCAL	0
#define RTLD_LAZY	0x00001
#define RTLD_NOW	0x00002
#define RTLD_GLOBAL	0x00100

typedef struct {
    char *dli_fname;
    void *dli_fbase;
    char *dli_sname;
    void *dli_saddr;
} Dl_info;
extern int dladdr(const void *, Dl_info *);
extern int dlclose(void *);
extern char *dlerror(void);
extern void *dlopen(char *, int);
extern void *dlsym(void *, char *);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBDLMAN"
>13.16. Interface Definitions for libdl</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB-DLADDR-3"
>dladdr</A
>&nbsp;--&nbsp;find the shared object containing a given address</DT
><DT
><A
HREF="#BASELIB-DLOPEN-1"
>dlopen</A
>&nbsp;--&nbsp;open dynamic object</DT
><DT
><A
HREF="#BASELIB-DLSYM-1"
>dlsym</A
>&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libdl and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBDL"
>Section 13.14</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB-DLADDR-3"
></A
>dladdr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15432"
></A
><H2
>Name</H2
>dladdr&nbsp;--&nbsp;find the shared object containing a given address</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15435"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;dlfcn.h&#62;

typedef struct {
             const char  <CODE
CLASS="STRUCTFIELD"
>*dli_fname</CODE
>;
             void        <CODE
CLASS="STRUCTFIELD"
>*dli_fbase</CODE
>;
             const char  <CODE
CLASS="STRUCTFIELD"
>*dli_sname</CODE
>;
             void        <CODE
CLASS="STRUCTFIELD"
>*dli_saddr</CODE
>;
} <TT
CLASS="STRUCTNAME"
>Dl_info</TT
>;</PRE
></TD
></TR
></TABLE
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15444"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>dladdr</TT
></CODE
>(const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>addr</I
></TT
></I
></TT
>, Dl_info *
  <TT
CLASS="PARAMETER"
><I
>dlip</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15453"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dladdr()</TT
> function shall query the dynamic
linker for information about the shared object containing the 
address <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>. The information shall be returned
in the user supplied data structure referenced by <TT
CLASS="PARAMETER"
><I
>dlip</I
></TT
>.</P
><P
>The structure shall contain at least the following members:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15463"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_fname</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The pathname of the shared object containing the address</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15468"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_fbase</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The base address at which the shared object is
mapped into the address space of the calling process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15473"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of the nearest runtime symbol with  value
less than or equal to <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>.
Where possible, the symbol name shall be returned as it
would appear in C source code.</P
><P
>If no symbol with a suitable value is found,
both this field and <CODE
CLASS="STRUCTFIELD"
>dli_saddr</CODE
>
shall be set to <TT
CLASS="LITERAL"
>NULL</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15482"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_saddr</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The address of the symbol returned in
<CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
>. This address has type 
"pointer to <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>", where
<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> is the type of the symbol
<CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Example: </B
>If the symbol in <CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
> is a function,
then the type of <CODE
CLASS="STRUCTFIELD"
>dli_saddr</CODE
> is of type
"pointer to function".</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The behavior of <TT
CLASS="FUNCTION"
>dladdr()</TT
> is only
specified in dynamically linked programs.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15498"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>dladdr()</TT
> shall return non-zero, and
the structure referenced by <TT
CLASS="PARAMETER"
><I
>dlip</I
></TT
> shall be filled in
as described. Otherwise, <TT
CLASS="FUNCTION"
>dladdr()</TT
> shall return zero,
and the cause of the error can be fetched with <TT
CLASS="FUNCTION"
>dlerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15505"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>dlerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15509"
></A
><H2
>Environment</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15512"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>LD_LIBRARY_PATH</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>directory search-path for object files</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-DLOPEN-1"
></A
>dlopen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15521"
></A
><H2
>Name</H2
>dlopen&nbsp;--&nbsp;open dynamic object</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15526"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;dlfcn.h&#62;</PRE
></TD
></TR
></TABLE
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15530"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * 
  <TT
CLASS="FUNCTION"
>dlopen</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flag</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15540"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dlopen()</TT
> function shall behave as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with additional behaviors listed below.</P
><P
>If the file argument does not contain a slash character, then the
system shall look for a library of that name in at least the following
directories, and use the first one which is found:

<P
></P
><UL
><LI
><P
>The directories specified by the 
<CODE
CLASS="CONSTANT"
>DT_RPATH</CODE
> dynamic entry.</P
></LI
><LI
><P
>The directories specified in the 
<CODE
CLASS="CONSTANT"
>LD_LIBRARY_PATH</CODE
>
environment variable (which is a colon separated list of pathnames).
This step shall be skipped for setuid
and setgid executables.</P
></LI
><LI
><P
>A set of directories sufficient to contain the
libraries specified in this standard.

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Traditionally, <TT
CLASS="FILENAME"
>/lib</TT
> and
<TT
CLASS="FILENAME"
>/usr/lib</TT
>.  This case would also cover cases in
which the system used the mechanism of
<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
> and
<TT
CLASS="FILENAME"
>/etc/ld.so.cache</TT
> to provide access.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Example: An application which is not linked against libm may
choose to dlopen libm.</P
></BLOCKQUOTE
></DIV
>&#13;</P
></LI
></UL
>&#13;</P
></DIV
><H1
><A
NAME="BASELIB-DLSYM-1"
></A
>dlsym</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15566"
></A
><H2
>Name</H2
>dlsym&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15571"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dlsym()</TT
> is as specified in the
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN15576"
></A
><H3
>The special purpose value for handle RTLD_NEXT</H3
><P
>The value RTLD_NEXT, which is reserved for future use shall be available,
with the behavior as described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBRT"
>13.17. Interfaces for librt</A
></H2
><P
><A
HREF="#LIB-LIBRT-DEF"
>Table 13-34</A
> defines the library name and shared object name
for the librt library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBRT-DEF"
></A
><P
><B
>Table 13-34. librt Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>librt</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>librt.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBRT.1"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15598"
>13.17.1. Shared Memory Objects</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15601"
>13.17.1.1. Interfaces for Shared Memory Objects</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Shared Memory Objects specified in <A
HREF="#TBL-LIBRT-SHA-INTS"
>Table 13-35</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-SHA-INTS"
></A
><P
><B
>Table 13-35. librt - Shared Memory Objects Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>shm_open <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>shm_unlink <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15620"
>13.17.2. Clock</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15623"
>13.17.2.1. Interfaces for Clock</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Clock specified in <A
HREF="#TBL-LIBRT-CLO-INTS"
>Table 13-36</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-CLO-INTS"
></A
><P
><B
>Table 13-36. librt - Clock Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>clock_getcpuclockid <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>clock_getres <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>clock_gettime <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>clock_nanosleep <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>clock_settime <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15656"
>13.17.3. Timers</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15659"
>13.17.3.1. Interfaces for Timers</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Timers specified in <A
HREF="#TBL-LIBRT-TIM-INTS"
>Table 13-37</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-TIM-INTS"
></A
><P
><B
>Table 13-37. librt - Timers Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>timer_create <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>timer_delete <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>timer_getoverrun <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>timer_gettime <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>timer_settime <A
HREF="#REFSTD.LIBRT.1"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBCRYPT"
>13.18. Interfaces for libcrypt</A
></H2
><P
><A
HREF="#LIB-LIBCRYPT-DEF"
>Table 13-38</A
> defines the library name and shared object name
for the libcrypt library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBCRYPT-DEF"
></A
><P
><B
>Table 13-38. libcrypt Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libcrypt</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libcrypt.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBCRYPT.1"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15710"
>13.18.1. Encryption</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15713"
>13.18.1.1. Interfaces for Encryption</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Encryption specified in <A
HREF="#TBL-LIBCRYPT-ENC-INTS"
>Table 13-39</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBCRYPT-ENC-INTS"
></A
><P
><B
>Table 13-39. libcrypt - Encryption Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>crypt <A
HREF="#REFSTD.LIBCRYPT.1"
>[SUSv3]</A
></TD
><TD
>encrypt <A
HREF="#REFSTD.LIBCRYPT.1"
>[SUSv3]</A
></TD
><TD
>setkey <A
HREF="#REFSTD.LIBCRYPT.1"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPAM"
>13.19. Interfaces for libpam</A
></H2
><P
><A
HREF="#LIB-LIBPAM-DEF"
>Table 13-40</A
> defines the library name and shared object name
for the libpam library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBPAM-DEF"
></A
><P
><B
>Table 13-40. libpam Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libpam</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libpam.so.0</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Pluggable Authentication Module (PAM) interfaces allow
applications to request authentication via a system administrator
defined mechanism, known as a <I
CLASS="FIRSTTERM"
>service</I
>.</P
><P
>A single service name, <CODE
CLASS="VARNAME"
>other</CODE
>, shall always be present.
The behavior of this service shall be determined by the system administrator.
Additional service names may also exist.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Future versions of this specification might define additional
service names.</P
></BLOCKQUOTE
></DIV
></P
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBPAM.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15759"
>13.19.1. Pluggable Authentication API</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN15762"
>13.19.1.1. Interfaces for Pluggable Authentication API</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Pluggable Authentication API specified in <A
HREF="#TBL-LIBPAM-PLU-INTS"
>Table 13-41</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPAM-PLU-INTS"
></A
><P
><B
>Table 13-41. libpam - Pluggable Authentication API Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pam_acct_mgmt <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_authenticate <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_chauthtok <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_close_session <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_end <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_fail_delay <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_get_item <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_getenvlist <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_open_session <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_set_item <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_setcred <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_start <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_strerror <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPAM-DDEFS"
>13.20. Data Definitions for libpam</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libpam.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN15835"
>13.20.1. security/pam_appl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct pam_handle pam_handle_t;
struct pam_message {
    int msg_style;
    const char *msg;
};
struct pam_response {
    char *resp;
    int resp_retcode;
};

struct pam_conv {
    int (*conv) (int num_msg, const struct pam_message * *msg,
		 struct pam_response * *resp, void *appdata_ptr);
    void *appdata_ptr;
};

#define PAM_PROMPT_ECHO_OFF	1
#define PAM_PROMPT_ECHO_ON	2
#define PAM_ERROR_MSG	3
#define PAM_TEXT_INFO	4

#define PAM_SERVICE	1
#define PAM_USER	2
#define PAM_TTY	3
#define PAM_RHOST	4
#define PAM_CONV	5
#define PAM_RUSER	8
#define PAM_USER_PROMPT	9

#define PAM_SUCCESS	0
#define PAM_OPEN_ERR	1
#define PAM_USER_UNKNOWN	10
#define PAM_MAXTRIES	11
#define PAM_NEW_AUTHTOK_REQD	12
#define PAM_ACCT_EXPIRED	13
#define PAM_SESSION_ERR	14
#define PAM_CRED_UNAVAIL	15
#define PAM_CRED_EXPIRED	16
#define PAM_CRED_ERR	17
#define PAM_CONV_ERR	19
#define PAM_SYMBOL_ERR	2
#define PAM_AUTHTOK_ERR	20
#define PAM_AUTHTOK_RECOVER_ERR	21
#define PAM_AUTHTOK_LOCK_BUSY	22
#define PAM_AUTHTOK_DISABLE_AGING	23
#define PAM_TRY_AGAIN	24
#define PAM_ABORT	26
#define PAM_AUTHTOK_EXPIRED	27
#define PAM_BAD_ITEM	29
#define PAM_SERVICE_ERR	3
#define PAM_SYSTEM_ERR	4
#define PAM_BUF_ERR	5
#define PAM_PERM_DENIED	6
#define PAM_AUTH_ERR	7
#define PAM_CRED_INSUFFICIENT	8
#define PAM_AUTHINFO_UNAVAIL	9

#define PAM_DISALLOW_NULL_AUTHTOK	0x0001U
#define PAM_ESTABLISH_CRED	0x0002U
#define PAM_DELETE_CRED	0x0004U
#define PAM_REINITIALIZE_CRED	0x0008U
#define PAM_REFRESH_CRED	0x0010U
#define PAM_CHANGE_EXPIRED_AUTHTOK	0x0020U
#define PAM_SILENT	0x8000U

extern int pam_set_item(pam_handle_t *, int, const void *);
extern int pam_get_item(const pam_handle_t *, int, const void **);
extern const char *pam_strerror(pam_handle_t *, int);
extern char **pam_getenvlist(pam_handle_t *);
extern int pam_fail_delay(pam_handle_t *, unsigned int);
extern int pam_start(const char *, const char *, const struct pam_conv *,
		     pam_handle_t * *);
extern int pam_end(pam_handle_t *, int);
extern int pam_authenticate(pam_handle_t *, int);
extern int pam_setcred(pam_handle_t *, int);
extern int pam_acct_mgmt(pam_handle_t *, int);
extern int pam_open_session(pam_handle_t *, int);
extern int pam_close_session(pam_handle_t *, int);
extern int pam_chauthtok(pam_handle_t *, int);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPAMMAN"
>13.21. Interface Definitions for libpam</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB-PAM-ACCT-MGMT"
>pam_acct_mgmt</A
>&nbsp;--&nbsp;establish the status of a user's account</DT
><DT
><A
HREF="#BASELIB-PAM-AUTHENTICATE"
>pam_authenticate</A
>&nbsp;--&nbsp;authenticate the user</DT
><DT
><A
HREF="#BASELIB-PAM-CHAUTHTOK"
>pam_chauthtok</A
>&nbsp;--&nbsp;change the authentication token for a given user</DT
><DT
><A
HREF="#BASELIB-PAM-CLOSE-SESSION"
>pam_close_session</A
>&nbsp;--&nbsp;indicate that an authenticated session has ended</DT
><DT
><A
HREF="#BASELIB-PAM-END"
>pam_end</A
>&nbsp;--&nbsp;terminate the use of the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-FAIL-DELAY"
>pam_fail_delay</A
>&nbsp;--&nbsp;specify delay time to use on authentication error</DT
><DT
><A
HREF="#BASELIB-PAM-GET-ITEM"
>pam_get_item</A
>&nbsp;--&nbsp;obtain the value of the indicated item.</DT
><DT
><A
HREF="#BASELIB-PAM-GETENVLIST"
>pam_getenvlist</A
>&nbsp;--&nbsp;returns a pointer to the complete PAM environment.</DT
><DT
><A
HREF="#BASELIB-PAM-OPEN-SESSION"
>pam_open_session</A
>&nbsp;--&nbsp;indicate session has started</DT
><DT
><A
HREF="#BASELIB-PAM-SET-ITEM"
>pam_set_item</A
>&nbsp;--&nbsp;(re)set the value of an item.</DT
><DT
><A
HREF="#BASELIB-PAM-SETCRED"
>pam_setcred</A
>&nbsp;--&nbsp;set the module-specific credentials of the user</DT
><DT
><A
HREF="#BASELIB-PAM-START"
>pam_start</A
>&nbsp;--&nbsp;initialize the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-STRERROR"
>pam_strerror</A
>&nbsp;--&nbsp;returns a string describing the PAM error</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libpam and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBPAM"
>Section 13.19</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB-PAM-ACCT-MGMT"
></A
>pam_acct_mgmt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15848"
></A
><H2
>Name</H2
>pam_acct_mgmt&nbsp;--&nbsp;establish the status of a user's account</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15851"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15854"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_acct_mgmt</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15865"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_acct_mgmt()</TT
> establishes the account's usability 
and the user's accessibility to the system. It is typically called 
after the user has been authenticated.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be specified as any valid flag (namely, 
one of those applicable to the <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> argument of 
<TT
CLASS="FUNCTION"
>pam_authenticate()</TT
>). Additionally, the value of 
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be logically or'd 
with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15877"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15880"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15884"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_NEW_AUTHTOK_REQD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is valid, but user's authentication token has expired.
The correct response to this return-value is to require that the
user satisfy the <TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
> function before 
obtaining service. It may not be possible for an application to do 
this. In such a case, the user should be denied access until the
account password is updated.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15889"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_ACCT_EXPIRED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is no longer permitted access to the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15893"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_AUTH_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Authentication error.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15897"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is not permitted to gain access at this time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15901"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER_UNKNOWN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is not known to a module's account management component.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-AUTHENTICATE"
></A
>pam_authenticate</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15912"
></A
><H2
>Name</H2
>pam_authenticate&nbsp;--&nbsp;authenticate the user</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15915"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15918"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_authenticate</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15929"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_authenticate()</TT
> serves as an interface to the 
authentication mechanisms of the loaded modules. </P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> is an optional parameter that may
be specified by the following value:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_DISALLOW_NULL_AUTHTOK</DT
><DD
><P
>Instruct the authentication modules to return <CODE
CLASS="CONSTANT"
>PAM_AUTH_ERR</CODE
>
if the user does not have a registered authorization token.</P
></DD
></DL
></DIV
><P
>Additionally, the value of <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be 
logically or'd with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
><P
>The process may need to be privileged in order to successfully
call this function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15947"
></A
><H2
>Return Value</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_SUCCESS</DT
><DD
><P
>Success.</P
></DD
><DT
>PAM_AUTH_ERR</DT
><DD
><P
>User was not authenticated or process did not have sufficient privileges
to perform authentication.</P
></DD
><DT
>PAM_CRED_INSUFFICIENT</DT
><DD
><P
>Application does not have sufficient credentials to
authenticate the user.</P
></DD
><DT
>PAM_AUTHINFO_UNAVAIL</DT
><DD
><P
>Modules were not able to access the authentication information. This
might be due to a network or hardware failure, etc.</P
></DD
><DT
>PAM_USER_UNKNOWN</DT
><DD
><P
>Supplied username is not known to the authentication service.</P
></DD
><DT
>PAM_MAXTRIES</DT
><DD
><P
>One or more authentication modules has reached its limit of tries
authenticating the user. Do not try again.</P
></DD
><DT
>PAM_ABORT</DT
><DD
><P
>One or more authentication modules failed to load.</P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-CHAUTHTOK"
></A
>pam_chauthtok</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15985"
></A
><H2
>Name</H2
>pam_chauthtok&nbsp;--&nbsp;change the authentication token for a given user</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15988"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15991"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_chauthtok</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, const int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16002"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
> is used to change the 
authentication token for a given user as indicated by the state 
associated with the handle <TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> is an optional parameter that may
be specified by the following value:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_CHANGE_EXPIRED_AUTHTOK</DT
><DD
><P
>User's authentication token should only be changed if it has expired.</P
></DD
></DL
></DIV
><P
>Additionally, the value of <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be 
logically or'd with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16019"
></A
><H2
>RETURN VALUE</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_SUCCESS</DT
><DD
><P
>Success.</P
></DD
><DT
>PAM_AUTHTOK_ERR</DT
><DD
><P
>A module was unable to obtain the new authentication token.</P
></DD
><DT
>PAM_AUTHTOK_RECOVER_ERR</DT
><DD
><P
>A module was unable to obtain the old authentication token.</P
></DD
><DT
>PAM_AUTHTOK_LOCK_BUSY</DT
><DD
><P
>One or more modules were unable to change the authentication token
since it is currently locked.</P
></DD
><DT
>PAM_AUTHTOK_DISABLE_AGING</DT
><DD
><P
>Authentication token aging has been disabled for at least one of the modules.</P
></DD
><DT
>PAM_PERM_DENIED</DT
><DD
><P
>Permission denied.</P
></DD
><DT
>PAM_TRY_AGAIN</DT
><DD
><P
>Not all modules were in a position to update the authentication
token(s). In such a case, none of the user's authentication tokens 
are updated.</P
></DD
><DT
>PAM_USER_UNKNOWN</DT
><DD
><P
>User is not known to the authentication token changing service.</P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-CLOSE-SESSION"
></A
>pam_close_session</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16061"
></A
><H2
>Name</H2
>pam_close_session&nbsp;--&nbsp;indicate that an authenticated session has ended</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16064"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16067"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_close_session</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16078"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_close_session()</TT
> is used to indicate that 
an authenticated session has ended. It is used to inform the module 
that the user is exiting a session. It should be possible for the 
PAM library to open a session and close the same session from 
different applications.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may have the value
<CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
> to indicate that no output 
should be generated as a result of this function call.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16087"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16090"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16094"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SESSION_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of the required loaded modules was unable to close a session for the user.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-END"
></A
>pam_end</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16105"
></A
><H2
>Name</H2
>pam_end&nbsp;--&nbsp;terminate the use of the PAM library</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16108"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16111"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_end</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pam_status</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16122"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_end()</TT
> terminates use of the PAM library.
On success, the contents of <TT
CLASS="PARAMETER"
><I
>*pamh</I
></TT
> are no 
longer valid, and all memory associated with it is invalid.</P
><P
>Normally, <TT
CLASS="PARAMETER"
><I
>pam_status</I
></TT
> is passed the value 
<CODE
CLASS="CONSTANT"
>PAM_SUCCESS</CODE
>, but in the event of an
unsuccessful service application, the appropriate PAM error 
return value should be used.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16132"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16135"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-FAIL-DELAY"
></A
>pam_fail_delay</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16146"
></A
><H2
>Name</H2
>pam_fail_delay&nbsp;--&nbsp;specify delay time to use on authentication error</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16149"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16152"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_fail_delay</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, unsigned int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>micro_sec</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16163"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_fail_delay()</TT
> specifies the minimum delay for the 
PAM library to use when an authentication error occurs. The actual delay 
can vary by as much at 25%. If this function is called multiple times, 
the longest time specified by any of the call will be used.</P
><P
>The delay is invoked if an authentication error occurs during the
<TT
CLASS="FUNCTION"
>pam_authenticate()</TT
> or <TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
>
function calls.</P
><P
>Independent of the success of
<TT
CLASS="FUNCTION"
>pam_authenticate()</TT
> or <TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
>,
the delay time is reset to its default value of 0 when the PAM library returns 
control to the application from these two functions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16175"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16178"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-GET-ITEM"
></A
>pam_get_item</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16189"
></A
><H2
>Name</H2
>pam_get_item&nbsp;--&nbsp;obtain the value of the indicated item.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16192"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16195"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_get_item</TT
></CODE
>(const pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item_type</I
></TT
></I
></TT
>, const void * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16209"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_get_item()</TT
> obtains the value of the indicated
<TT
CLASS="PARAMETER"
><I
>item_type</I
></TT
>. The possible values of
<TT
CLASS="PARAMETER"
><I
>item_type</I
></TT
> are the same as listed for
<TT
CLASS="FUNCTION"
>pam_set_item()</TT
>.</P
><P
>On success, <TT
CLASS="PARAMETER"
><I
>item</I
></TT
> contains a pointer to the
value of the corresponding item. Note that this is a pointer to the 
actual data and should not be <TT
CLASS="FUNCTION"
>free()</TT
>'d or over-written.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16221"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16224"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16228"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Application passed a <CODE
CLASS="CONSTANT"
>NULL</CODE
> pointer for
<CODE
CLASS="VARNAME"
>item</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16234"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BAD_ITEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Application attempted to get an undefined item.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-GETENVLIST"
></A
>pam_getenvlist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16245"
></A
><H2
>Name</H2
>pam_getenvlist&nbsp;--&nbsp;returns a pointer to the complete PAM environment.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16248"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16251"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char * const *
  <TT
CLASS="FUNCTION"
>pam_getenvlist</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16259"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_getenvlist()</TT
> returns a pointer to the complete 
PAM environment. This pointer points to an array of pointers to
<CODE
CLASS="CONSTANT"
>NUL</CODE
>-terminated strings and must be terminated by a
<CODE
CLASS="CONSTANT"
>NULL</CODE
> pointer. Each string has the form "name=value".</P
><P
>The PAM library module allocates memory for the returned value and the
associated strings. The calling application is responsible for freeing this
memory. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16268"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>pam_getenvlist()</TT
> returns an array of string pointers 
containing the PAM environment. On error, <CODE
CLASS="CONSTANT"
>NULL</CODE
> 
is returned.</P
></DIV
><H1
><A
NAME="BASELIB-PAM-OPEN-SESSION"
></A
>pam_open_session</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16277"
></A
><H2
>Name</H2
>pam_open_session&nbsp;--&nbsp;indicate session has started</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16280"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16283"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_open_session</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16294"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pam_open_session()</TT
> function is used to indicate that an 
authenticated session has begun, after the user has been
identified (see <TT
CLASS="FUNCTION"
>pam_authenticate()</TT
>) and,
if necessary, granted credentials (see <TT
CLASS="FUNCTION"
>pam_setcred()</TT
>).
It is used to inform the module that 
the user is currently in a session. It should be possible for the PAM 
library to open a session and close the same session from different 
applications.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may have the value
<CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
> to indicate that no output be
generated as a result of this function call.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16305"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16308"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16312"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SESSION_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of the loaded modules was unable to open a session for the user.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-SET-ITEM"
></A
>pam_set_item</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16323"
></A
><H2
>Name</H2
>pam_set_item&nbsp;--&nbsp;(re)set the value of an item.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16326"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16329"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_set_item</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item_type</I
></TT
></I
></TT
>, const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16343"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_set_item()</TT
> (re)sets the value of one of the 
following item_types:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16350"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SERVICE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>service name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16354"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>user name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16358"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_TTY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>terminal name</P
><P
>The value for a device file should include the <TT
CLASS="FILENAME"
>/dev/</TT
> 
prefix. The value for graphical, X-based, applications should be the 
<CODE
CLASS="VARNAME"
>$DISPLAY</CODE
> variable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16365"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_RHOST</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>remote host name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16369"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CONV</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>conversation structure</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16373"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_RUSER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>remote user name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16377"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER_PROMPT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>string to be used when prompting for a user's name</P
><P
>The default value for this string is <TT
CLASS="LITERAL"
>Please enter 
username: </TT
>.</P
></TD
></TR
></TBODY
></TABLE
><P
>For all <TT
CLASS="PARAMETER"
><I
>item_types</I
></TT
> other than
<CODE
CLASS="CONSTANT"
>PAM_CONV</CODE
>, <TT
CLASS="PARAMETER"
><I
>item</I
></TT
> is a pointer 
to a <CODE
CLASS="CONSTANT"
>NULL</CODE
>-terminated character string. In the case 
of <CODE
CLASS="CONSTANT"
>PAM_CONV</CODE
>, <TT
CLASS="PARAMETER"
><I
>item</I
></TT
> points to
an initialized <TT
CLASS="STRUCTNAME"
>pam_conv</TT
> structure.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16391"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16394"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16398"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An attempt was made to replace the conversation structure with a
<CODE
CLASS="CONSTANT"
>NULL</CODE
> value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16403"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BUF_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Function ran out of memory making a copy of the item.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16407"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BAD_ITEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Application attempted to set an undefined item.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-SETCRED"
></A
>pam_setcred</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16418"
></A
><H2
>Name</H2
>pam_setcred&nbsp;--&nbsp;set the module-specific credentials of the user</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16421"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16424"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>extern int 
  <TT
CLASS="FUNCTION"
>pam_setcred</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16435"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_setcred()</TT
> sets the module-specific credentials of 
the user. It is usually called after the user has been authenticated,
after the account management function has been called and after a
session has been opened for the user.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> maybe specified from among the following 
values:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_ESTABLISH_CRED</DT
><DD
><P
>set credentials for the authentication service</P
></DD
><DT
>PAM_DELETE_CRED</DT
><DD
><P
>delete credentials associated with the authentication service</P
></DD
><DT
>PAM_REINITIALIZE_CRED</DT
><DD
><P
>reinitialize the user credentials</P
></DD
><DT
>PAM_REFRESH_CRED</DT
><DD
><P
>extend lifetime of the user credentials</P
></DD
></DL
></DIV
><P
>Additionally, the value of <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be 
logically or'd with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16463"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16466"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16470"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CRED_UNAVAIL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Module cannot retrieve the user's credentials.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16474"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CRED_EXPIRED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User's credentials have expired.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16478"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER_UNKNOWN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is not known to an authentication module.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16482"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CRED_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Module was unable to set the credentials of the user.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-START"
></A
>pam_start</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16493"
></A
><H2
>Name</H2
>pam_start&nbsp;--&nbsp;initialize the PAM library</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16496"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16499"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_start</TT
></CODE
>(const char * 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>service_name</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
></I
></TT
>, const struct pam_conv *
  <TT
CLASS="PARAMETER"
><I
>pam_conversation</I
></TT
>, pam_handle_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16515"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_start()</TT
> is used to initialize the PAM 
library. It must be called prior to any other usage of the PAM 
library. On success, <TT
CLASS="PARAMETER"
><I
>*pamh</I
></TT
> becomes a handle 
that provides continuity for successive calls to the PAM library. 
<TT
CLASS="FUNCTION"
>pam_start()</TT
> expects arguments as follows: the 
<TT
CLASS="PARAMETER"
><I
>service_name</I
></TT
> of the program, the 
<TT
CLASS="PARAMETER"
><I
>username</I
></TT
> of the individual to be
authenticated, a pointer to an application-supplied
<TT
CLASS="STRUCTNAME"
>pam_conv</TT
> structure, and a pointer to a
<TT
CLASS="PARAMETER"
><I
>pam_handle_t</I
></TT
> pointer.</P
><P
>An application must provide the <I
CLASS="EMPHASIS"
>conversation function</I
> 
used for direct communication between a loaded module and the application. 
The application also typically provides a means for the module to prompt 
the user for a password, etc.</P
><P
>The structure, pam_conv, is defined to be,
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  struct pam_conv {
               int (*conv) (int num_msg,
                            const struct pam_message * *msg,
                            struct pam_response * *resp,
                            void *appdata_ptr);
               void *appdata_ptr;
  };</PRE
></TD
></TR
></TABLE
>
It is initialized by the application before it is passed to the
library. The contents of this structure are attached to the
<TT
CLASS="PARAMETER"
><I
>*pamh</I
></TT
> handle. The point of this argument is to
provide a mechanism for any loaded module to interact directly with the
application program; this is why it is called a conversation structure.</P
><P
>When a module calls the referenced <TT
CLASS="FUNCTION"
>conv()</TT
> function, 
<TT
CLASS="PARAMETER"
><I
>appdata_ptr</I
></TT
> is set to the second element of this
structure.</P
><P
>The other arguments of a call to <TT
CLASS="FUNCTION"
>conv()</TT
> 
concern the information exchanged by module and application. 
<TT
CLASS="PARAMETER"
><I
>num_msg</I
></TT
> holds the length of the array of
pointers passed via <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
>. On success,
the pointer <TT
CLASS="PARAMETER"
><I
>resp</I
></TT
> points to an array of
<TT
CLASS="PARAMETER"
><I
>num_msg</I
></TT
> <TT
CLASS="STRUCTNAME"
>pam_response</TT
>
structures, holding the application-supplied text. Note that 
<TT
CLASS="PARAMETER"
><I
>resp</I
></TT
> is a struct 
<TT
CLASS="STRUCTNAME"
>pam_response</TT
> array and not an array of 
pointers.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16544"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16547"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16551"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BUF_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Memory allocation error.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16555"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_ABORT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Internal failure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16559"
></A
><H2
>ERRORS</H2
><P
>May be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-PAM-STRERROR"
></A
>pam_strerror</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16567"
></A
><H2
>Name</H2
>pam_strerror&nbsp;--&nbsp;returns a string describing the PAM error</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16570"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16573"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
  <TT
CLASS="FUNCTION"
>pam_strerror</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>errnum</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16584"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_strerror()</TT
> returns a string describing the PAM 
error associated with <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16591"
></A
><H2
>Return Value</H2
><P
>On success, this function returns a description of the indicated error.
The application 
should not free or modify this string. 
Otherwise, a string
indicating that the error is unknown shall be returned.
It is unspecified whether or not the string returned is translated according to
the setting of <CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
>.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCUTILLIB"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>IV. Utility Libraries</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>14. <A
HREF="#UTILLIB"
>Utility Libraries</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN16599"
>Introduction</A
></DT
><DT
>14.2. <A
HREF="#LIBZ"
>Interfaces for libz</A
></DT
><DD
><DL
><DT
>14.2.1. <A
HREF="#AEN16629"
>Compression Library</A
></DT
></DL
></DD
><DT
>14.3. <A
HREF="#LIBZ-DDEFS"
>Data Definitions for libz</A
></DT
><DD
><DL
><DT
>14.3.1. <A
HREF="#AEN16830"
>zlib.h</A
></DT
></DL
></DD
><DT
>14.4. <A
HREF="#LIBZMAN"
>Interface Definitions for libz</A
></DT
><DD
><DL
><DT
><A
HREF="#ZLIB-ADLER32-1"
>adler32</A
>&nbsp;--&nbsp;compute Adler 32 Checksum</DT
><DT
><A
HREF="#ZLIB-COMPRESS-1"
>compress</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-COMPRESS2-1"
>compress2</A
>&nbsp;--&nbsp;compress data at a specified level</DT
><DT
><A
HREF="#ZLIB-COMPRESSBOUND-1"
>compressBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-CRC32-1"
>crc32</A
>&nbsp;--&nbsp;compute CRC-32 Checksum</DT
><DT
><A
HREF="#ZLIB-DEFLATE-1"
>deflate</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-DEFLATEBOUND-1"
>deflateBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-DEFLATECOPY-1"
>deflateCopy</A
>&nbsp;--&nbsp;copy compression stream</DT
><DT
><A
HREF="#ZLIB-DEFLATEEND-1"
>deflateEnd</A
>&nbsp;--&nbsp;free compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT2"
>deflateInit2_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT"
>deflateInit_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEPARAMS-1"
>deflateParams</A
>&nbsp;--&nbsp;set compression parameters</DT
><DT
><A
HREF="#ZLIB-DEFLATERESET-1"
>deflateReset</A
>&nbsp;--&nbsp;reset compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATESETDICTIONARY-1"
>deflateSetDictionary</A
>&nbsp;--&nbsp;initialize compression dictionary</DT
><DT
><A
HREF="#ZLIB-GET-CRC-TABLE-1"
>get_crc_table</A
>&nbsp;--&nbsp;generate a table for crc calculations</DT
><DT
><A
HREF="#ZLIB-GZCLOSE-1"
>gzclose</A
>&nbsp;--&nbsp;close a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZDOPEN-1"
>gzdopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZEOF-1"
>gzeof</A
>&nbsp;--&nbsp;check for end-of-file on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZERROR-1"
>gzerror</A
>&nbsp;--&nbsp;decode an error on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZFLUSH-1"
>gzflush</A
>&nbsp;--&nbsp;flush a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZGETC-1"
>gzgetc</A
>&nbsp;--&nbsp;read a character from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZGETS-1"
>gzgets</A
>&nbsp;--&nbsp;read a string from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZOPEN-1"
>gzopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPRINTF-1"
>gzprintf</A
>&nbsp;--&nbsp;format data and compress</DT
><DT
><A
HREF="#ZLIB-GZPUTC-1"
>gzputc</A
>&nbsp;--&nbsp;write character to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPUTS-1"
>gzputs</A
>&nbsp;--&nbsp;string write to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREAD-1"
>gzread</A
>&nbsp;--&nbsp;read from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREWIND-1"
>gzrewind</A
>&nbsp;--&nbsp;reset the file-position indicator on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSEEK-1"
>gzseek</A
>&nbsp;--&nbsp;reposition a file-position indicator in a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSETPARAMS-1"
>gzsetparams</A
>&nbsp;--&nbsp;dynamically set compression parameters</DT
><DT
><A
HREF="#ZLIB-GZTELL-1"
>gztell</A
>&nbsp;--&nbsp;find position on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZWRITE-1"
>gzwrite</A
>&nbsp;--&nbsp;write to a compressed file</DT
><DT
><A
HREF="#ZLIB-INFLATE-1"
>inflate</A
>&nbsp;--&nbsp;decompress data</DT
><DT
><A
HREF="#ZLIB-INFLATEEND-1"
>inflateEnd</A
>&nbsp;--&nbsp;free decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT2"
>inflateInit2_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT"
>inflateInit_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATERESET-1"
>inflateReset</A
>&nbsp;--&nbsp;reset decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATESETDICTIONARY-1"
>inflateSetDictionary</A
>&nbsp;--&nbsp;initialize decompression dictionary</DT
><DT
><A
HREF="#ZLIB-INFLATESYNC-1"
>inflateSync</A
>&nbsp;--&nbsp;advance compression stream to next sync point</DT
><DT
><A
HREF="#ZLIB-INFLATESYNCPOINT-1"
>inflateSyncPoint</A
>&nbsp;--&nbsp;test for synchronization point</DT
><DT
><A
HREF="#ZLIB-UNCOMPRESS-1"
>uncompress</A
>&nbsp;--&nbsp;uncompress data</DT
><DT
><A
HREF="#ZLIB-ZERROR-1"
>zError</A
>&nbsp;--&nbsp;translate error number to string</DT
><DT
><A
HREF="#ZLIB-ZLIBVERSION-1"
>zlibVersion</A
>&nbsp;--&nbsp;discover library version at run time</DT
></DL
></DD
><DT
>14.5. <A
HREF="#LIBNCURSES"
>Interfaces for libncurses</A
></DT
><DD
><DL
><DT
>14.5.1. <A
HREF="#AEN19760"
>Curses</A
></DT
></DL
></DD
><DT
>14.6. <A
HREF="#LIBNCURSES-DDEFS"
>Data Definitions for libncurses</A
></DT
><DD
><DL
><DT
>14.6.1. <A
HREF="#AEN20987"
>curses.h</A
></DT
><DT
>14.6.2. <A
HREF="#AEN20991"
>term.h</A
></DT
></DL
></DD
><DT
>14.7. <A
HREF="#LIBUTIL"
>Interfaces for libutil</A
></DT
><DD
><DL
><DT
>14.7.1. <A
HREF="#AEN21013"
>Utility Functions</A
></DT
></DL
></DD
><DT
>14.8. <A
HREF="#LIBUTILMAN"
>Interface Definitions for libutil</A
></DT
><DD
><DL
><DT
><A
HREF="#LIBUTIL-FORKPTY-3"
>forkpty</A
>&nbsp;--&nbsp;Create a new process attached to an available pseudo-terminal</DT
><DT
><A
HREF="#LIBUTIL-LOGIN-3"
>login</A
>&nbsp;--&nbsp;login utility function</DT
><DT
><A
HREF="#LIBUTIL-LOGIN-TTY-3"
>login_tty</A
>&nbsp;--&nbsp;Prepare a terminal for login</DT
><DT
><A
HREF="#LIBUTIL-LOGOUT-3"
>logout</A
>&nbsp;--&nbsp;logout utility function</DT
><DT
><A
HREF="#BASELIB-LOGWTMP-3"
>logwtmp</A
>&nbsp;--&nbsp;append an entry to the wtmp file</DT
><DT
><A
HREF="#LIBUTIL-OPENPTY-3"
>openpty</A
>&nbsp;--&nbsp;find and open an available pseudo-terminal</DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="UTILLIB"
></A
>Chapter 14. Utility Libraries</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN16599"
>14.1. Introduction</A
></H2
><P
>An LSB-conforming implementation shall also support the following utility
libraries which
are built on top of the interfaces provided by the base libraries. These
libraries implement common functionality, and hide additional system dependent
information such as file formats and device names.
<P
></P
><UL
><LI
><P
>libz</P
></LI
><LI
><P
>libcurses</P
></LI
><LI
><P
>libutil</P
></LI
></UL
></P
><P
>The structure of the definitions for these libraries follows the
same model as used for <A
HREF="#BASELIB"
>Base Libraries</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBZ"
>14.2. Interfaces for libz</A
></H2
><P
><A
HREF="#LIB-LIBZ-DEF"
>Table 14-1</A
> defines the library name and shared object name
for the libz library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBZ-DEF"
></A
><P
><B
>Table 14-1. libz Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libz</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libz.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBZ.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN16629"
>14.2.1. Compression Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN16632"
>14.2.1.1. Interfaces for Compression Library</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Compression Library specified in <A
HREF="#TBL-LIBZ-COM-INTS"
>Table 14-2</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBZ-COM-INTS"
></A
><P
><B
>Table 14-2. libz - Compression Library Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>adler32 <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>compress <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>compress2 <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>compressBound <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>crc32 <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflate <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateBound <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateCopy <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateEnd <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateInit2_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateInit_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateParams <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateReset <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateSetDictionary <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>get_crc_table <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzclose <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzdopen <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzeof <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzerror <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzflush <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzgetc <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzgets <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzopen <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzprintf <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzputc <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzputs <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzread <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzrewind <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzseek <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzsetparams <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gztell <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzwrite <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>inflate <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateEnd <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateInit2_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateInit_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>inflateReset <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateSetDictionary <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateSync <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateSyncPoint <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>uncompress <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>zError <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>zlibVersion <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBZ-DDEFS"
>14.3. Data Definitions for libz</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libz.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN16830"
>14.3.1. zlib.h</A
></H3
><P
>In addition to the values below, the <TT
CLASS="FILENAME"
>zlib.h</TT
> 
header shall define the
<CODE
CLASS="CONSTANT"
>ZLIB_VERSION</CODE
> macro. This macro may be used
to check that the version of the library at run time matches that
at compile time.</P
><P
>See also the <TT
CLASS="FUNCTION"
>zlibVersion()</TT
> function, which returns
the library version at run time. The first character of the version 
at compile time should always match the first character at run time.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define Z_NULL	0
#define MAX_WBITS	15
#define MAX_MEM_LEVEL	9
#define deflateInit2(strm,level,method,windowBits,memLevel,strategy)	\
	deflateInit2_((strm),(level),(method),(windowBits),(memLevel),(strategy),ZLIB_VERSION,sizeof(z_stream))
#define deflateInit(strm,level)	\
	deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm,windowBits)	\
	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm)	\
	inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))

typedef char charf;
typedef int intf;

typedef void *voidpf;
typedef unsigned int uInt;
typedef unsigned long int uLong;
typedef uLong uLongf;
typedef void *voidp;
typedef unsigned char Byte;
typedef off_t z_off_t;
typedef void *const voidpc;

typedef voidpf(*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);
struct internal_state {
    int dummy;
};
typedef Byte Bytef;
typedef uInt uIntf;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;
    Bytef *next_out;
    uInt avail_out;
    uLong total_out;
    char *msg;
    struct internal_state *state;
    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;
    int data_type;
    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;
typedef voidp gzFile;

#define Z_NO_FLUSH	0
#define Z_PARTIAL_FLUSH	1
#define Z_SYNC_FLUSH	2
#define Z_FULL_FLUSH	3
#define Z_FINISH	4

#define Z_ERRNO	(-1)
#define Z_STREAM_ERROR	(-2)
#define Z_DATA_ERROR	(-3)
#define Z_MEM_ERROR	(-4)
#define Z_BUF_ERROR	(-5)
#define Z_VERSION_ERROR	(-6)
#define Z_OK	0
#define Z_STREAM_END	1
#define Z_NEED_DICT	2

#define Z_DEFAULT_COMPRESSION	(-1)
#define Z_NO_COMPRESSION	0
#define Z_BEST_SPEED	1
#define Z_BEST_COMPRESSION	9

#define Z_DEFAULT_STRATEGY	0
#define Z_FILTERED	1
#define Z_HUFFMAN_ONLY	2

#define Z_BINARY	0
#define Z_ASCII	1
#define Z_UNKNOWN	2

#define Z_DEFLATED	8

extern int gzread(gzFile, voidp, unsigned int);
extern int gzclose(gzFile);
extern gzFile gzopen(const char *, const char *);
extern gzFile gzdopen(int, const char *);
extern int gzwrite(gzFile, voidpc, unsigned int);
extern int gzflush(gzFile, int);
extern const char *gzerror(gzFile, int *);
extern uLong adler32(uLong, const Bytef *, uInt);
extern int compress(Bytef *, uLongf *, const Bytef *, uLong);
extern int compress2(Bytef *, uLongf *, const Bytef *, uLong, int);
extern uLong crc32(uLong, const Bytef *, uInt);
extern int deflate(z_streamp, int);
extern int deflateCopy(z_streamp, z_streamp);
extern int deflateEnd(z_streamp);
extern int deflateInit2_(z_streamp, int, int, int, int, int, const char *,
			 int);
extern int deflateInit_(z_streamp, int, const char *, int);
extern int deflateParams(z_streamp, int, int);
extern int deflateReset(z_streamp);
extern int deflateSetDictionary(z_streamp, const Bytef *, uInt);
extern const uLongf *get_crc_table(void);
extern int gzeof(gzFile);
extern int gzgetc(gzFile);
extern char *gzgets(gzFile, char *, int);
extern int gzprintf(gzFile, const char *, ...);
extern int gzputc(gzFile, int);
extern int gzputs(gzFile, const char *);
extern int gzrewind(gzFile);
extern z_off_t gzseek(gzFile, z_off_t, int);
extern int gzsetparams(gzFile, int, int);
extern z_off_t gztell(gzFile);
extern int inflate(z_streamp, int);
extern int inflateEnd(z_streamp);
extern int inflateInit2_(z_streamp, int, const char *, int);
extern int inflateInit_(z_streamp, const char *, int);
extern int inflateReset(z_streamp);
extern int inflateSetDictionary(z_streamp, const Bytef *, uInt);
extern int inflateSync(z_streamp);
extern int inflateSyncPoint(z_streamp);
extern int uncompress(Bytef *, uLongf *, const Bytef *, uLong);
extern const char *zError(int);
extern const char *zlibVersion(void);
extern uLong deflateBound(z_streamp, uLong);
extern uLong compressBound(uLong);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBZMAN"
>14.4. Interface Definitions for libz</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#ZLIB-ADLER32-1"
>adler32</A
>&nbsp;--&nbsp;compute Adler 32 Checksum</DT
><DT
><A
HREF="#ZLIB-COMPRESS-1"
>compress</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-COMPRESS2-1"
>compress2</A
>&nbsp;--&nbsp;compress data at a specified level</DT
><DT
><A
HREF="#ZLIB-COMPRESSBOUND-1"
>compressBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-CRC32-1"
>crc32</A
>&nbsp;--&nbsp;compute CRC-32 Checksum</DT
><DT
><A
HREF="#ZLIB-DEFLATE-1"
>deflate</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-DEFLATEBOUND-1"
>deflateBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-DEFLATECOPY-1"
>deflateCopy</A
>&nbsp;--&nbsp;copy compression stream</DT
><DT
><A
HREF="#ZLIB-DEFLATEEND-1"
>deflateEnd</A
>&nbsp;--&nbsp;free compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT2"
>deflateInit2_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT"
>deflateInit_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEPARAMS-1"
>deflateParams</A
>&nbsp;--&nbsp;set compression parameters</DT
><DT
><A
HREF="#ZLIB-DEFLATERESET-1"
>deflateReset</A
>&nbsp;--&nbsp;reset compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATESETDICTIONARY-1"
>deflateSetDictionary</A
>&nbsp;--&nbsp;initialize compression dictionary</DT
><DT
><A
HREF="#ZLIB-GET-CRC-TABLE-1"
>get_crc_table</A
>&nbsp;--&nbsp;generate a table for crc calculations</DT
><DT
><A
HREF="#ZLIB-GZCLOSE-1"
>gzclose</A
>&nbsp;--&nbsp;close a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZDOPEN-1"
>gzdopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZEOF-1"
>gzeof</A
>&nbsp;--&nbsp;check for end-of-file on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZERROR-1"
>gzerror</A
>&nbsp;--&nbsp;decode an error on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZFLUSH-1"
>gzflush</A
>&nbsp;--&nbsp;flush a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZGETC-1"
>gzgetc</A
>&nbsp;--&nbsp;read a character from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZGETS-1"
>gzgets</A
>&nbsp;--&nbsp;read a string from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZOPEN-1"
>gzopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPRINTF-1"
>gzprintf</A
>&nbsp;--&nbsp;format data and compress</DT
><DT
><A
HREF="#ZLIB-GZPUTC-1"
>gzputc</A
>&nbsp;--&nbsp;write character to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPUTS-1"
>gzputs</A
>&nbsp;--&nbsp;string write to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREAD-1"
>gzread</A
>&nbsp;--&nbsp;read from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREWIND-1"
>gzrewind</A
>&nbsp;--&nbsp;reset the file-position indicator on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSEEK-1"
>gzseek</A
>&nbsp;--&nbsp;reposition a file-position indicator in a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSETPARAMS-1"
>gzsetparams</A
>&nbsp;--&nbsp;dynamically set compression parameters</DT
><DT
><A
HREF="#ZLIB-GZTELL-1"
>gztell</A
>&nbsp;--&nbsp;find position on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZWRITE-1"
>gzwrite</A
>&nbsp;--&nbsp;write to a compressed file</DT
><DT
><A
HREF="#ZLIB-INFLATE-1"
>inflate</A
>&nbsp;--&nbsp;decompress data</DT
><DT
><A
HREF="#ZLIB-INFLATEEND-1"
>inflateEnd</A
>&nbsp;--&nbsp;free decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT2"
>inflateInit2_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT"
>inflateInit_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATERESET-1"
>inflateReset</A
>&nbsp;--&nbsp;reset decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATESETDICTIONARY-1"
>inflateSetDictionary</A
>&nbsp;--&nbsp;initialize decompression dictionary</DT
><DT
><A
HREF="#ZLIB-INFLATESYNC-1"
>inflateSync</A
>&nbsp;--&nbsp;advance compression stream to next sync point</DT
><DT
><A
HREF="#ZLIB-INFLATESYNCPOINT-1"
>inflateSyncPoint</A
>&nbsp;--&nbsp;test for synchronization point</DT
><DT
><A
HREF="#ZLIB-UNCOMPRESS-1"
>uncompress</A
>&nbsp;--&nbsp;uncompress data</DT
><DT
><A
HREF="#ZLIB-ZERROR-1"
>zError</A
>&nbsp;--&nbsp;translate error number to string</DT
><DT
><A
HREF="#ZLIB-ZLIBVERSION-1"
>zlibVersion</A
>&nbsp;--&nbsp;discover library version at run time</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libz and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBZ"
>Section 14.2</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="ZLIB-ADLER32-1"
></A
>adler32</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16847"
></A
><H2
>Name</H2
>adler32&nbsp;--&nbsp;compute Adler 32 Checksum</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16852"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16853"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>uLong
<TT
CLASS="FUNCTION"
>adler32</TT
></CODE
>(uLong
<TT
CLASS="PARAMETER"
><I
>adler</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16864"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>adler32()</TT
> function shall compute a running
Adler-32 checksum (as described in <A
HREF="#STD.RFC1950"
>RFC 1950: ZLIB Compressed Data Format Specication</A
>).
On entry, <TT
CLASS="PARAMETER"
><I
>adler</I
></TT
> is the previous value for the
checksum, and <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall point to an array of
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes of data to be added to this checksum.
The <TT
CLASS="FUNCTION"
>adler32()</TT
> function shall return the new checksum.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
> (or 
<CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>), <TT
CLASS="FUNCTION"
>adler32()</TT
>
shall return the initial checksum.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16878"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>adler32()</TT
> function shall return  
the new checksum value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16882"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16885"
></A
><H2
>Application Usage (informative)</H2
><P
>The following code fragment demonstrates typical usage of
the <TT
CLASS="FUNCTION"
>adler32()</TT
> function:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-COMPRESS-1"
></A
>compress</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16894"
></A
><H2
>Name</H2
>compress&nbsp;--&nbsp;compress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16899"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16900"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>compress</TT
></CODE
>(Bytef *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, uLongf *
<TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16913"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>compress()</TT
> function shall attempt to compress
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data in the buffer 
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, placing the result in the buffer
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. </P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
> should point to a value describing
the size of the <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer. 
The application should ensure that this value
be at least 
<TT
CLASS="GRAPHIC"
>(sourceLen × 1.001) + 12</TT
>.
On successful exit, the variable referenced by <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>
shall be updated to hold the length of compressed data in
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>compress()</TT
> function is equivalent to 
<TT
CLASS="FUNCTION"
>compress2()</TT
> with a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_LEVEL</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16933"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>compress()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>compress()</TT
> shall return a value to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16939"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>compress()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16944"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was not large enough to hold the
compressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16950"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-COMPRESS2-1"
></A
>compress2</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16959"
></A
><H2
>Name</H2
>compress2&nbsp;--&nbsp;compress data at a specified level</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16964"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16965"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>compress2</TT
></CODE
>(Bytef *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, uLongf *
<TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16980"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>compress2()</TT
> function shall attempt to compress
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data in the buffer 
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, placing the result in the buffer
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, at the level described by 
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>. 
The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.</P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
> should point to a value describing
the size of the <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer. 
The application should ensure that this value
be at least 
<TT
CLASS="GRAPHIC"
>(sourceLen × 1.001) + 12</TT
>.
On successful exit, the variable referenced by <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>
shall be updated to hold the length of compressed data in
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>compress()</TT
> function is equivalent to 
<TT
CLASS="FUNCTION"
>compress2()</TT
> with a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_LEVEL</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17011"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>compress2()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>compress2()</TT
> shall return a value to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17017"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>compress2()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17022"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was not large enough to hold the
compressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17028"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17033"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> was not <CODE
CLASS="CONSTANT"
>Z_DEFAULT_LEVEL</CODE
>,
or was not between 0 and 9.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-COMPRESSBOUND-1"
></A
>compressBound</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17044"
></A
><H2
>Name</H2
>compressBound&nbsp;--&nbsp;compute compressed data size</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17049"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17050"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>compressBound</TT
></CODE
>(uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17057"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>compressBound()</TT
> function shall estimate the size
of buffer required to compress <TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>
bytes of data using the <TT
CLASS="FUNCTION"
>compress()</TT
>
or <TT
CLASS="FUNCTION"
>compress2()</TT
> functions.
If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data, using the
parameters stored in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, 
in a single
call to <TT
CLASS="FUNCTION"
>compress()</TT
> or 
<TT
CLASS="FUNCTION"
>compress2()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17068"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>compressBound()</TT
> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <TT
CLASS="FUNCTION"
>compress()</TT
>
or <TT
CLASS="FUNCTION"
>compress2()</TT
>.
This function may return a conservative value that may be larger than 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17075"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-CRC32-1"
></A
>crc32</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17082"
></A
><H2
>Name</H2
>crc32&nbsp;--&nbsp;compute CRC-32 Checksum</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17087"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17088"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>uLong
<TT
CLASS="FUNCTION"
>crc32</TT
></CODE
>(uLong
<TT
CLASS="PARAMETER"
><I
>crc</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17099"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>crc32()</TT
> function shall compute a running
Cyclic Redundancy Check checksum, as defined in <A
HREF="#STD.ITUV42"
>ITU-T V.42</A
>.
On entry, <TT
CLASS="PARAMETER"
><I
>crc</I
></TT
> is the previous value for the
checksum, and <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall point to an array of
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes of data to be added to this checksum.
The <TT
CLASS="FUNCTION"
>crc32()</TT
> function shall return the new checksum.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
> (or 
<CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>), <TT
CLASS="FUNCTION"
>crc32()</TT
>
shall return the initial checksum.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17113"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>crc32()</TT
> function shall return  
the new checksum value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17117"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17120"
></A
><H2
>Application Usage (informative)</H2
><P
>The following code fragment demonstrates typical usage of
the <TT
CLASS="FUNCTION"
>crc32()</TT
> function:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATE-1"
></A
>deflate</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17129"
></A
><H2
>Name</H2
>deflate&nbsp;--&nbsp;compress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17134"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17135"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflate</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17144"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall attempt to compress
data until either the input buffer is empty or the output buffer is full.
The <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> references a
<TT
CLASS="STRUCTNAME"
>z_stream</TT
> structure. Before the first call to
<TT
CLASS="FUNCTION"
>deflate()</TT
>, this structure
should have been initialized by a call to 
<TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> is only in the binary standard; source
level applications should initialize <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
via a call to <TT
CLASS="FUNCTION"
>deflateInit()</TT
> or 
<TT
CLASS="FUNCTION"
>deflateInit2()</TT
>.</P
></BLOCKQUOTE
></DIV
>
In addition, the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> input and output buffers
should have been initialized as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17160"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to the data to be compressed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17165"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the number of bytes of data in the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17171"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to a buffer where compressed data may be placed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17176"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the size in bytes of the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="FUNCTION"
>deflate()</TT
> function
shall perform one or both of the following actions:
<P
></P
><OL
TYPE="1"
><LI
><P
>Compress input data from <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>
and update <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> to reflect the data that has been 
compressed.</P
></LI
><LI
><P
>Fill the output buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
and update <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
> to reflect the compressed data that 
has been placed there. If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is not
<CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).</P
></LI
></OL
></P
><P
>The <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall return when either
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> reaches zero (indicating that all the input
data has been compressed), or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> reaches
zero (indicating that the output buffer is full).</P
><P
>On success, the <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall set the
<CODE
CLASS="STRUCTFIELD"
>adler</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
to the <TT
CLASS="FUNCTION"
>adler32()</TT
> checksum of all the input data compressed
so far (represented by <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
>).</P
><P
>If the <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall attempt to determine
the type of input data, and set field <CODE
CLASS="STRUCTFIELD"
>data_type</CODE
>
in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to <CODE
CLASS="CONSTANT"
>Z_ASCII</CODE
> if the
majority of the data bytes fall within the ASCII (ISO 646) printable
character range. Otherwise, it shall set <CODE
CLASS="STRUCTFIELD"
>data_type</CODE
>
to <CODE
CLASS="CONSTANT"
>Z_BINARY</CODE
>.
This data type is informational only, and does not affect the compression
algorithm.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Future versions of the LSB may remove this requirement, since it is based
on an outdated character set that does not support Internationalization,
and does not affect the algorithm. It is included for information
only at this release. Applications should not depend on this field.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN17219"
></A
><H3
>Flush Operation</H3
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> determines when compressed bits 
are added to the output buffer in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>.
If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>deflate()</TT
>
may return with some data pending output, and not yet added to the 
output buffer.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>deflate()</TT
> shall flush all pending output to
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and align the output to a byte 
boundary. A synchronization point is generated in  the output.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>,
all output shall be flushed, as for <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
and the compression state shall be reset. 
A synchronization point is generated in  the output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
><CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.</P
></BLOCKQUOTE
></DIV
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>,
all pending input shall be processed and <TT
CLASS="FUNCTION"
>deflate()</TT
>
shall return with <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
> if there is
sufficient space in the output buffer at <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
as indicated by <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>. If
<TT
CLASS="FUNCTION"
>deflate()</TT
> is called with <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>
set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
> and there is insufficient space to store
the compressed data, and no other error has occurred during compression,
<TT
CLASS="FUNCTION"
>deflate()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>,
and the application should call <TT
CLASS="FUNCTION"
>deflate()</TT
> again with
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> unchanged, and having updated <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>.</P
><P
>If all the compression is to be done in a single step, 
<TT
CLASS="FUNCTION"
>deflate()</TT
>
may be called with <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> set to 
<CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
> immediately after the stream
has been initialized if <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>
is set to at least the value returned by <TT
CLASS="FUNCTION"
>deflateBound()</TT
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17263"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflate()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, unless <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> was set 
to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
> and there was sufficient space in the output buffer
to compress all of the input data. In this case, <TT
CLASS="FUNCTION"
>deflate()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
>.
On error, <TT
CLASS="FUNCTION"
>deflate()</TT
> shall return a value to indicate
the error.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If <TT
CLASS="FUNCTION"
>deflate()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>
and has set <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> to zero, the function should
be called again with the same value for <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>, and with
updated <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> until <TT
CLASS="FUNCTION"
>deflate()</TT
>
returns with <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
> (or <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
>
if <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>) and a non-zero 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17287"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflate()</TT
> shall return a value as described 
below, and set the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to point to a string describing the error:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17294"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No progress is possible; either <CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
>
or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> was zero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17301"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17306"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEBOUND-1"
></A
>deflateBound</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17318"
></A
><H2
>Name</H2
>deflateBound&nbsp;--&nbsp;compute compressed data size</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17323"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17324"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateBound</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17333"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateBound()</TT
> function shall estimate the size
of buffer required to compress <TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>
bytes of data. If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data, using the
parameters stored in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, 
in a single
call to <TT
CLASS="FUNCTION"
>deflate()</TT
> with flush set to
<CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>.</P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
should
have been initialized via a call to <TT
CLASS="FUNCTION"
>deflateInit_()</TT
>
or <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17346"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateBound()</TT
> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <TT
CLASS="FUNCTION"
>deflate()</TT
>.
If the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is not correctly initialized,
or is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, then <TT
CLASS="FUNCTION"
>deflateBound()</TT
>
may return a conservative value that may be larger than 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17355"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATECOPY-1"
></A
>deflateCopy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17362"
></A
><H2
>Name</H2
>deflateCopy&nbsp;--&nbsp;copy compression stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17367"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17368"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateCopy</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, z_streamp
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17377"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateCopy()</TT
> function shall copy the compression state
information in <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> to the uninitialized
<TT
CLASS="STRUCTNAME"
>z_stream</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>On successful return, <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> will be an exact copy
of the stream referenced by <TT
CLASS="PARAMETER"
><I
>source</I
></TT
>. The input and
output buffer pointers in <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> will reference the same data.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17389"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateCopy()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return a value less than zero to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17394"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateCopy()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17399"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state in <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> is inconsistent, or
either <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> or
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17408"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17413"
></A
><H2
>Application Usage (informative)</H2
><P
>This function can be useful when several compression strategies will
be tried, for example when there are several ways of pre-processing the
input data with a filter. The streams that will be discarded should then
be freed by calling <TT
CLASS="FUNCTION"
>deflateEnd()</TT
>. Note that 
<TT
CLASS="FUNCTION"
>deflateCopy()</TT
> duplicates the
internal compression state which can be quite large, so this strategy
may be slow and can consume lots of memory.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEEND-1"
></A
>deflateEnd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17422"
></A
><H2
>Name</H2
>deflateEnd&nbsp;--&nbsp;free compression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17427"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17428"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateEnd</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17435"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateEnd()</TT
> function shall free all allocated
state information referenced by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output is discarded, and unprocessed input is ignored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17440"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateEnd()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, or <SPAN
CLASS="RETURNVALUE"
>Z_DATA_ERROR</SPAN
>
if there was pending output discarded or input unprocessed.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17447"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateEnd()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent or inappropriate.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEINIT2"
></A
>deflateInit2_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17464"
></A
><H2
>Name</H2
>deflateInit2_&nbsp;--&nbsp;initialize compression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17469"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17470"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>deflateInit2_</TT
>
  </CODE
>(z_streamp <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>method</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>memLevel</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
>, char * <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17491"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> function shall initialize the compression
system.
On entry, <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
> shall refer to a user supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17499"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17506"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17514"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and <CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with the version
implemented, or if the size of the <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size in the library 
implementation, <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>method</I
></TT
> selects the compression algorithm to use. LSB
conforming implementation shall support the <CODE
CLASS="CONSTANT"
>Z_DEFLATED</CODE
> method,
and may support other implementation defined methods.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
> parameter shall be a base 2 logarithm of the window 
size to use, and shall be a value between <CODE
CLASS="CONSTANT"
>8</CODE
> and <CODE
CLASS="CONSTANT"
>15</CODE
>.
A smaller value will use less memory, but will result in a poorer compression ratio, 
while a higher value will
give better compression but utilize more memory.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>memLevel</I
></TT
> parameter specifies how much memory to use for the 
internal state. The value of <TT
CLASS="PARAMETER"
><I
>memLevel</I
></TT
> shall be between
<CODE
CLASS="CONSTANT"
>1</CODE
> and <CODE
CLASS="CONSTANT"
>MAX_MEM_LEVEL</CODE
>. Smaller values
use less memory but are slower, while higher values use more memory to gain compression speed.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
> parameter selects the compression strategy to use:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17556"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use the system default compression strategy. <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>
is particularly appropriate for text data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17562"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
> uses more Huffman encoding
and less string matching than <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17569"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_HUFFMAN_ONLY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>force Huffman encoding only, with no string match.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>deflateInit2()</TT
> macro.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17577"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17583"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17588"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17593"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17598"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEINIT"
></A
>deflateInit_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17611"
></A
><H2
>Name</H2
>deflateInit_&nbsp;--&nbsp;initialize compression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17616"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17617"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateInit_</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17630"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function shall initialize 
the compression
system.
On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall refer to a user 
supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). 
The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17638"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17645"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory
allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is
<CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17653"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data
that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with
the version implemented, or if the size of the
<TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size
in the library
implementation, <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.</P
><P
>The <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>deflateInit()</TT
> macro.</P
><P
>The <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function is equivalent to
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> deflateInit2_(stream, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17686"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17692"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17697"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17702"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17707"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEPARAMS-1"
></A
>deflateParams</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17720"
></A
><H2
>Name</H2
>deflateParams&nbsp;--&nbsp;set compression parameters</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17725"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17726"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateParams</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17737"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateParams()</TT
> function shall dynamically
alter the compression parameters for the compression stream object
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall refer to a user supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure), already initialized
via a call to <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> or
<TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.
If the compression level is altered by <TT
CLASS="FUNCTION"
>deflateParams()</TT
>,
and some data has already been compressed with this <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
(i.e. <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> is not zero),
and the new <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> requires a different
underlying compression method, then <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
shall be flushed by a call to <TT
CLASS="FUNCTION"
>deflate()</TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
> parameter selects the compression strategy to use:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17767"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use the system default compression strategy. <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>
is particularly appropriate for text data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17773"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
> uses more Huffman encoding
and less string matching than <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17780"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_HUFFMAN_ONLY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>force Huffman encoding only, with no string match.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17786"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>deflateParams()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>deflateParams()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17792"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateParams()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17797"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17802"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17807"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient space in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
to flush the current output.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17816"
></A
><H2
>Application Usage (Informative)</H2
><P
>Applications should ensure that the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is flushed,
e.g. by a call to <KBD
CLASS="USERINPUT"
>deflate(stream, Z_SYNC_FLUSH)</KBD
>
before calling <TT
CLASS="FUNCTION"
>deflateParams()</TT
>, or ensure that there is
sufficient space in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> (as identified by
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>) to ensure that all pending output and
all uncompressed input can be flushed in a single call to
<TT
CLASS="FUNCTION"
>deflate()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Although the <TT
CLASS="FUNCTION"
>deflateParams()</TT
> function should flush pending output
and compress all pending input, the result is unspecified if there is insufficient
space in the output buffer. Applications should only call <TT
CLASS="FUNCTION"
>deflateParams()</TT
>
when the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is effectively empty (flushed).</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>The <TT
CLASS="FUNCTION"
>deflateParams()</TT
> can be used to switch between
compression and straight copy of the
input data, or to switch to a different kind of input data requiring a
different strategy.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATERESET-1"
></A
>deflateReset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17837"
></A
><H2
>Name</H2
>deflateReset&nbsp;--&nbsp;reset compression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17842"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17843"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateReset</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17850"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateReset()</TT
> function shall reset all state
associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output shall be discarded, and the counts of processed
bytes (<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
>) shall be reset to zero.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17857"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateReset()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17863"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateReset()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent or inappropriate.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATESETDICTIONARY-1"
></A
>deflateSetDictionary</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17880"
></A
><H2
>Name</H2
>deflateSetDictionary&nbsp;--&nbsp;initialize compression dictionary</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17885"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17886"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateSetDictionary</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17897"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
> function shall initialize the
compression dictionary associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
using the <TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
> bytes referenced by
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>.</P
><P
>The implementation may silently use a subset of the provided dictionary
if the dictionary cannot fit in the current window associated with
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> (see <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>).
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.</P
><P
>If the dictionary is successfully set, the Adler32 checksum of the entire
provided dictionary
shall be stored in the <CODE
CLASS="STRUCTFIELD"
>adler</CODE
> member of 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>. This value may be used by the decompression
system to select the correct dictionary. The compression and decompression 
systems must use the same dictionary.</P
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall reference an initialized compression
stream, with <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> zero (i.e. no data
has been compressed since the stream was initialized).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17913"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate an error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17919"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17924"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17932"
></A
><H2
>Application Usage (informative)</H2
><P
>The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.</P
><P
>The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.</P
></DIV
><H1
><A
NAME="ZLIB-GET-CRC-TABLE-1"
></A
>get_crc_table</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17940"
></A
><H2
>Name</H2
>get_crc_table&nbsp;--&nbsp;generate a table for crc calculations</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17945"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17946"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const uLongf *
<TT
CLASS="FUNCTION"
>get_crc_table</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17952"
></A
><H2
>Description</H2
><P
>Generate tables for a byte-wise 32-bit CRC calculation based on the polynomial:
<TT
CLASS="LITERAL"
>x<SUP
>32</SUP
>+x<SUP
>26</SUP
>+x<SUP
>23</SUP
>+x<SUP
>22</SUP
>+x<SUP
>16</SUP
>+x<SUP
>12</SUP
>+x<SUP
>11</SUP
>+x<SUP
>10</SUP
>+x<SUP
>8</SUP
>+x<SUP
>7</SUP
>+x<SUP
>5</SUP
>+x<SUP
>4</SUP
>+x<SUP
>2</SUP
>+x+1</TT
></P
><P
>In a multi-threaded application, <TT
CLASS="FUNCTION"
>get_crc_table()</TT
>
should be called by one thread to initialize the tables before any other
thread calls any <TT
CLASS="LITERAL"
>libz</TT
> function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17972"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>get_crc_table()</TT
> function shall return a
pointer to the first of a set of tables used internally to calculate
CRC-32 values (see <TT
CLASS="FUNCTION"
>crc32()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17977"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-GZCLOSE-1"
></A
>gzclose</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17984"
></A
><H2
>Name</H2
>gzclose&nbsp;--&nbsp;close a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17989"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17990"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzclose</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17997"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzclose()</TT
> function shall close the compressed file stream
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> was open for writing, <TT
CLASS="FUNCTION"
>gzclose()</TT
>
shall first flush any pending output. Any state information allocated shall
be freed.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18004"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzclose()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>gzclose()</TT
> shall return an error value as described below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18010"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzclose()</TT
> may set
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.
The <TT
CLASS="FUNCTION"
>gzclose()</TT
> shall return a value other than <CODE
CLASS="CONSTANT"
>Z_OK</CODE
>
on error.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18018"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
> (or <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>),
or did not refer to an open compressed file stream.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18026"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred in the underlying base libraries, and the application should check
<CODE
CLASS="VARNAME"
>errno</CODE
> for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18032"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible during buffer flush (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZDOPEN-1"
></A
>gzdopen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18042"
></A
><H2
>Name</H2
>gzdopen&nbsp;--&nbsp;open a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18047"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18048"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   gzFile <TT
CLASS="FUNCTION"
>gzdopen</TT
>
  </CODE
>( int <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,  const char *<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18057"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzdopen()</TT
> function shall attempt to associate
the open file
referenced by <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> with a <SPAN
CLASS="TYPE"
>gzFile</SPAN
>
object.
The <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> argument is based on that of 
<TT
CLASS="FUNCTION"
>fopen()</TT
>, but the 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> parameter may also contain the following characters:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18067"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression level to <TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <TT
CLASS="FUNCTION"
>defaultInit2_()</TT
> for further details.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18074"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression strategy to <TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
>.
The letter <TT
CLASS="LITERAL"
>f</TT
> corresponds to filtered data, 
the letter <TT
CLASS="LITERAL"
>h</TT
>
corresponds to Huffman only compression, and 
the letter <TT
CLASS="LITERAL"
>R</TT
>
corresponds to Run Length Encoding.
See <TT
CLASS="FUNCTION"
>defaultInit2_()</TT
> for further details.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
><P
>If <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> refers to an uncompressed file, and 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> refers to a read mode, 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall attempt to open the file and return
a <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object suitable for reading directly from the file
without any decompression.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>
is <TT
CLASS="LITERAL"
>NULL</TT
>, or if <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> does not contain
one of <TT
CLASS="LITERAL"
>r</TT
>, <TT
CLASS="LITERAL"
>w</TT
>, or <TT
CLASS="LITERAL"
>a</TT
>,
<TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>,
and need not set any other error condition.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18102"
></A
><H2
>Example</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>gzdopen(fileno(stdin), "r");</PRE
></TD
></TR
></TABLE
>
Attempt to associate the standard input with a <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18107"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall return a 
<SPAN
CLASS="TYPE"
>gzFile</SPAN
> object. On failure, 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
> and
may set <CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>At version 1.2.2, <CODE
CLASS="VARNAME"
>zlib</CODE
>
does not set <CODE
CLASS="VARNAME"
>errno</CODE
> for several
error conditions. Applications may not be able to
determine the cause of an error.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18119"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzdopen()</TT
> may set
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><H1
><A
NAME="ZLIB-GZEOF-1"
></A
>gzeof</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18128"
></A
><H2
>Name</H2
>gzeof&nbsp;--&nbsp;check for end-of-file on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18133"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18134"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzeof</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18141"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzeof()</TT
> function shall test the compressed file stream
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> for end of file.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18146"
></A
><H2
>Return Value</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> was open for reading
and end of file has been reached, <TT
CLASS="FUNCTION"
>gzeof()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>1</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>gzeof()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18154"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-GZERROR-1"
></A
>gzerror</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18161"
></A
><H2
>Name</H2
>gzerror&nbsp;--&nbsp;decode an error on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18166"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18167"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   const char * <TT
CLASS="FUNCTION"
>gzerror</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int * <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18176"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzerror()</TT
> function shall return a string describing
the last error to have occurred associated with the open compressed file stream
referred to by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
It shall also set the location referenced by
<TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
> to an integer value that further identifies the
error.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18182"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>gzerror()</TT
> function shall return a string that
describes the last error associated with the given
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> compressed file stream.
This string shall have the format
<TT
CLASS="LITERAL"
>"%s: %s"</TT
>, with the name of the file, followed by a colon,
a space, and the description of the error. If the compressed file stream
was opened by a call to <TT
CLASS="FUNCTION"
>gzdopen()</TT
>, the format of the
filename is unspecified.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Although in all current implementations of libz file descriptors
are named <TT
CLASS="LITERAL"
>"&#60;fd:%d&#62;"</TT
>, the code suggests that this
is for debugging purposes only, and may change in a future release.</P
></BLOCKQUOTE
></DIV
></P
><P
>It is unspecified if the string returned is determined by the setting
of the <CODE
CLASS="CONSTANT"
>LC_MESSAGES</CODE
> category in the current locale.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18195"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-GZFLUSH-1"
></A
>gzflush</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18202"
></A
><H2
>Name</H2
>gzflush&nbsp;--&nbsp;flush a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18207"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18208"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>gzflush</TT
></CODE
>(gzFile
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18217"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzflush()</TT
> function shall flush pending
output to the compressed file stream identified by
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which must be open for writing.&#13;</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN18222"
></A
><H3
>Flush Operation</H3
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> determines which compressed bits 
are added to the output file.
If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>gzflush()</TT
>
may return with some data pending output, and not yet written to the file.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>gzflush()</TT
> shall flush all pending output to
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> and align the output to a byte 
boundary.
There may still be data pending compression that is not flushed.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>,
all output shall be flushed, as for <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
and the compression state shall be reset.
There may still be data pending compression that is not flushed.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
><CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.</P
></BLOCKQUOTE
></DIV
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>,
all pending uncompressed data shall be compressed
and all output shall be flushed.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18246"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzflush()</TT
> shall return the value
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise <TT
CLASS="FUNCTION"
>gzflush()</TT
> shall return
a value to indicate the error, and may set the error number
associated with the compressed file stream 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>
and the flush operation is successful, <TT
CLASS="FUNCTION"
>gzflush()</TT
>
will return <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, but the compressed
file stream error value may be set to <CODE
CLASS="CONSTANT"
>Z_STREAM_END</CODE
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18260"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall return an error
value, and may set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications may use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18268"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18274"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, is not open for writing, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18279"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18285"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to compress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZGETC-1"
></A
>gzgetc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18294"
></A
><H2
>Name</H2
>gzgetc&nbsp;--&nbsp;read a character from a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18299"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18300"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzgetc</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18307"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzgetc()</TT
> function shall read the next single
character from the compressed file stream
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a read mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18314"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzgetc()</TT
> shall return the uncompressed
character read,
otherwise, on end of file or error, <TT
CLASS="FUNCTION"
>gzgetc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18320"
></A
><H2
>Errors</H2
><P
>On end of file or error, <TT
CLASS="FUNCTION"
>gzgetc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>. Further information can be found
by calling <TT
CLASS="FUNCTION"
>gzerror()</TT
> with a pointer to the 
compressed file stream.</P
></DIV
><H1
><A
NAME="ZLIB-GZGETS-1"
></A
>gzgets</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18330"
></A
><H2
>Name</H2
>gzgets&nbsp;--&nbsp;read a string from a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18335"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18336"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   char * <TT
CLASS="FUNCTION"
>gzgets</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, char * <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18347"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzgets()</TT
> function shall attempt to read
data from the compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>,
uncompressing it into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> until
either <TT
CLASS="PARAMETER"
><I
>len</I
></TT
><TT
CLASS="LITERAL"
>-1</TT
> bytes
have been inserted into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, or until
a newline character has been uncompressed into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
A null byte shall be appended to the uncompressed data. The
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> shall have been opened
in for reading (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18360"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzgets()</TT
> shall return a pointer to 
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. Otherwise, <TT
CLASS="FUNCTION"
>gzgets()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>Z_NULL</SPAN
>.
Applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18368"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzgets()</TT
> shall 
return <SPAN
CLASS="RETURNVALUE"
>Z_NULL</SPAN
>. The following conditions shall
always be treated as an error:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
or does not refer to a file open for reading;</TD
></TR
><TR
><TD
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>;</TD
></TR
><TR
><TD
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
> is less than or equal to zero.</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></DIV
><H1
><A
NAME="ZLIB-GZOPEN-1"
></A
>gzopen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18386"
></A
><H2
>Name</H2
>gzopen&nbsp;--&nbsp;open a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18391"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18392"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   gzFile <TT
CLASS="FUNCTION"
>gzopen</TT
>
  </CODE
>(const char *<TT
CLASS="PARAMETER"
><I
>path</I
></TT
> , const char *<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18401"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzopen()</TT
> function shall open the compressed file
named by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> argument is based on that of 
<TT
CLASS="FUNCTION"
>fopen()</TT
>, but the 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> parameter may also contain the following characters:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18410"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression level to <TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <TT
CLASS="FUNCTION"
>defaultInit2_()</TT
> for further details.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18417"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression strategy to <TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
>.
The letter <TT
CLASS="LITERAL"
>f</TT
> corresponds to filtered data, 
the letter <TT
CLASS="LITERAL"
>h</TT
>
corresponds to Huffman only compression, and 
the letter <TT
CLASS="LITERAL"
>R</TT
>
corresponds to Run Length Encoding.
See <TT
CLASS="FUNCTION"
>defaultInit2_()</TT
> for further details.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> refers to an uncompressed file, and 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> refers to a read mode, 
<TT
CLASS="FUNCTION"
>gzopen()</TT
> shall attempt to open the file and return
a <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object suitable for reading directly from the file
without any decompression.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>
is <TT
CLASS="LITERAL"
>NULL</TT
>, or if <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> does not contain
one of <TT
CLASS="LITERAL"
>r</TT
>, <TT
CLASS="LITERAL"
>w</TT
>, or <TT
CLASS="LITERAL"
>a</TT
>,
<TT
CLASS="FUNCTION"
>gzopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>,
and need not set any other error condition.</P
><P
>The <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object is also referred to as a compressed file stream.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18448"
></A
><H2
>Example</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>gzopen("file.gz", "w6h");</PRE
></TD
></TR
></TABLE
>
Attempt to create a new compressed file, <TT
CLASS="FILENAME"
>file.gz</TT
>,
at compression level 6 using Huffman only compression.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18453"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzopen()</TT
> shall return a 
<SPAN
CLASS="TYPE"
>gzFile</SPAN
> object (also known as a <I
CLASS="EMPHASIS"
>compressed
file stream</I
>). On failure, 
<TT
CLASS="FUNCTION"
>gzopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
> and
may set <CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>At version 1.2.2, <CODE
CLASS="VARNAME"
>zlib</CODE
>
does not set <CODE
CLASS="VARNAME"
>errno</CODE
> for several
error conditions. Applications may not be able to
determine the cause of an error.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18466"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzopen()</TT
> may set
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><H1
><A
NAME="ZLIB-GZPRINTF-1"
></A
>gzprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18475"
></A
><H2
>Name</H2
>gzprintf&nbsp;--&nbsp;format data and compress</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18480"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18481"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzprintf</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, const char * <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18491"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzprintf()</TT
> function shall format data as for
<TT
CLASS="FUNCTION"
>fprintf()</TT
>, and write the resulting string to the compressed
file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18497"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>gzprintf()</TT
> function
shall return the number of uncompressed bytes
actually written, or a value less than or equal to 
<CODE
CLASS="CONSTANT"
>0</CODE
> in the event of an error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18502"
></A
><H2
>Errors</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, or refers to a 
compressed file stream that has not been opened for writing,
<TT
CLASS="FUNCTION"
>gzprintf()</TT
> shall return <TT
CLASS="LITERAL"
>Z_STREAM_ERROR</TT
>.
Otherwise, errors are as for <TT
CLASS="FUNCTION"
>gzwrite()</TT
>.</P
></DIV
><H1
><A
NAME="ZLIB-GZPUTC-1"
></A
>gzputc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18514"
></A
><H2
>Name</H2
>gzputc&nbsp;--&nbsp;write character to a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18519"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18520"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzputc</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>c</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18529"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzputc()</TT
> function shall write the single
character <TT
CLASS="PARAMETER"
><I
>c</I
></TT
>, converted from integer to unsigned
character, to the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a write mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18537"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzputc()</TT
> shall return the value
written, otherwise <TT
CLASS="FUNCTION"
>gzputc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18543"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzputc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.</P
></DIV
><H1
><A
NAME="ZLIB-GZPUTS-1"
></A
>gzputs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18552"
></A
><H2
>Name</H2
>gzputs&nbsp;--&nbsp;string write to a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18557"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18558"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzputs</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, const char * <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18567"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzputs()</TT
> function shall write the null terminated
string <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> to
the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a write mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).
The terminating null character shall not be written.
The <TT
CLASS="FUNCTION"
>gzputs()</TT
> function shall return the number of 
uncompressed bytes actually written.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18576"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzputs()</TT
> shall return the number of uncompressed
bytes actually written to <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
On error <TT
CLASS="FUNCTION"
>gzputs()</TT
> shall return a value
less than or equal to <CODE
CLASS="CONSTANT"
>0</CODE
>.
Applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18584"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzputs()</TT
> shall set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications should use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.
If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, 
<TT
CLASS="FUNCTION"
>gzputs()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_STREAM_ERR</CODE
>.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18596"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18602"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, is not open for writing, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18607"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18613"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to compress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZREAD-1"
></A
>gzread</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18622"
></A
><H2
>Name</H2
>gzread&nbsp;--&nbsp;read from a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18627"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18628"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzread</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, voidp <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, unsigned int <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18639"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzread()</TT
> function shall read data from
the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a read mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).
The <TT
CLASS="FUNCTION"
>gzread()</TT
> function shall read data from
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, and uncompress it into 
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. At most, <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>
bytes of uncompressed data shall be copied to <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
If the file is not compressed, <TT
CLASS="FUNCTION"
>gzread()</TT
> shall simply
copy data from <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> to <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>
without alteration.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18654"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzread()</TT
> shall return the number of bytes
decompressed into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
If <TT
CLASS="FUNCTION"
>gzread()</TT
> returns <CODE
CLASS="CONSTANT"
>0</CODE
>,
either the end-of-file has been reached
or an underlying read error has occurred. Applications
should use <TT
CLASS="FUNCTION"
>gzerror()</TT
> or <TT
CLASS="FUNCTION"
>gzeof()</TT
>
to determine which occurred.
On other errors, 
<TT
CLASS="FUNCTION"
>gzread()</TT
> shall return a value less than 
<CODE
CLASS="CONSTANT"
>0</CODE
> and
and applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18666"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzread()</TT
> shall set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications should use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18674"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18680"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_END</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>End of file has been reached on input.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18685"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A CRC error occurred when reading data; the file is corrupt.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18690"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18695"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_NEED_DICT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A dictionary is needed (see <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18701"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to decompress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZREWIND-1"
></A
>gzrewind</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18710"
></A
><H2
>Name</H2
>gzrewind&nbsp;--&nbsp;reset the file-position indicator on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18715"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18716"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>gzrewind</TT
></CODE
>(gzFile
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18723"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzrewind()</TT
> function shall set the starting position
for the next read
on compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> to the beginning
of file. <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> must be open for reading.</P
><P
><TT
CLASS="FUNCTION"
>gzrewind()</TT
> is equivalent to 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>(int)gzseek(file, 0L, SEEK_SET)</PRE
></TD
></TR
></TABLE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18732"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzrewind()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
On error, <TT
CLASS="FUNCTION"
>gzrewind()</TT
> shall return -1, and
may set the error value for <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18739"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzrewind()</TT
> shall return <CODE
CLASS="CONSTANT"
>-1</CODE
>,
indicating that <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, or does not represent
an open compressed file stream, or represents a compressed file stream
that is open for writing and is not currently at the beginning of file.</P
></DIV
><H1
><A
NAME="ZLIB-GZSEEK-1"
></A
>gzseek</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18750"
></A
><H2
>Name</H2
>gzseek&nbsp;--&nbsp;reposition a file-position indicator in a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18755"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18756"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>z_off_t
<TT
CLASS="FUNCTION"
>gzseek</TT
></CODE
>(gzFile
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, z_off_t
<TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>whence</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18767"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzseek()</TT
> function shall set the file-position
indicator for the compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
The file-position indicator controls where the next
read or write operation on the compressed file stream shall take place.
The <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> indicates a byte offset in the
uncompressed data. The <TT
CLASS="PARAMETER"
><I
>whence</I
></TT
> parameter
may be one of:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18775"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>SEEK_SET</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the offset is relative to the start of the uncompressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18780"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>SEEK_CUR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the offset is relative to the current positition in the uncompressed data.</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The value <CODE
CLASS="CONSTANT"
>SEEK_END</CODE
> need not be supported.</P
></BLOCKQUOTE
></DIV
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is open for writing, the new offset
must be greater than or equal to the current offset. In this case, 
<TT
CLASS="FUNCTION"
>gzseek()</TT
> shall compress a sequence of null bytes
to fill the gap from the previous offset to the new offset.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18791"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzseek()</TT
> shall return the resulting
offset in the file expressed
as a byte position in the <I
CLASS="EMPHASIS"
>uncompressed</I
> data stream.
On error, <TT
CLASS="FUNCTION"
>gzseek()</TT
> shall return -1, and
may set the error value for <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18798"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzseek()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.
The following conditions shall always result in an error:
<P
></P
><UL
><LI
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
></P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> does not represent
an open compressed file stream.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> refers to a compressed file stream that is open
for writing, and the newly computed offset is less than the current offset.</P
></LI
><LI
><P
>The newly computed offset is less than zero.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>whence</I
></TT
> is not one of the supported values.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18819"
></A
><H2
>Application Usage (informative)</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is open for reading, the implementation
may still need to uncompress all of the data up to the new offset.
As a result, <TT
CLASS="FUNCTION"
>gzseek()</TT
> may be extremely slow
in some circumstances.</P
></DIV
><H1
><A
NAME="ZLIB-GZSETPARAMS-1"
></A
>gzsetparams</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18828"
></A
><H2
>Name</H2
>gzsetparams&nbsp;--&nbsp;dynamically set compression parameters</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18833"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18834"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzsetparams</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18845"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzsetparams()</TT
> function shall set the compression level and
compression strategy on the compressed file stream referenced by
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>. The compressed file stream shall have been opened
in a write mode.
The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
> are as defined
in <A
HREF="#ZLIB-DEFLATEINIT2"
>deflateInit2_</A
>.
If there is any data pending writing, it shall be flushed before the parameters are
updated.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18853"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>gzsetparams()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18858"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzsetparams()</TT
> shall return one of the
following error indications:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18863"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter, or <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> not open for writing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18869"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An internal inconsistency was detected while flushing the previous buffer.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZTELL-1"
></A
>gztell</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18878"
></A
><H2
>Name</H2
>gztell&nbsp;--&nbsp;find position on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18883"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18884"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   z_off_t <TT
CLASS="FUNCTION"
>gztell</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18891"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gztell()</TT
> function shall return the starting position
for the next read or write operation
on compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>. This position represents
the number of bytes from the beginning of file in the uncompressed data.</P
><P
><TT
CLASS="FUNCTION"
>gztell()</TT
> is equivalent to 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>gzseek(file, 0L, SEEK_SET)</PRE
></TD
></TR
></TABLE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18899"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>gztell()</TT
> shall return the current offset in the file expressed
as a byte position in the <I
CLASS="EMPHASIS"
>uncompressed</I
> data stream.
On error, <TT
CLASS="FUNCTION"
>gztell()</TT
> shall return -1, and
may set the error value for <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18906"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gztell()</TT
> shall return <CODE
CLASS="CONSTANT"
>-1</CODE
>,
indicating that <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, or does not represent
an open compressed file stream.</P
></DIV
><H1
><A
NAME="ZLIB-GZWRITE-1"
></A
>gzwrite</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18917"
></A
><H2
>Name</H2
>gzwrite&nbsp;--&nbsp;write to a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18922"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18923"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzwrite</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, voidpc <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, unsigned int <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18934"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzwrite()</TT
> function shall write data to
the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a write mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).
On entry, <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall point to a buffer containing
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>bytes of uncompressed data.
The <TT
CLASS="FUNCTION"
>gzwrite()</TT
> function shall compress this data and
write it to
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
The <TT
CLASS="FUNCTION"
>gzwrite()</TT
> function shall return the number of 
uncompressed bytes actually written.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18946"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall return the number of 
uncompressed bytes actually written to <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
On error <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall return a value
less than or equal to <CODE
CLASS="CONSTANT"
>0</CODE
>.
Applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18954"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications should use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18962"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18968"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, is not open for writing, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18973"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18979"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to compress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATE-1"
></A
>inflate</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18988"
></A
><H2
>Name</H2
>inflate&nbsp;--&nbsp;decompress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18993"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18994"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflate</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19003"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflate()</TT
> function shall attempt to decompress
data until either the input buffer is empty or the output buffer is full.
The <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> references a
<TT
CLASS="STRUCTNAME"
>z_stream</TT
> structure. Before the first call to
<TT
CLASS="FUNCTION"
>inflate()</TT
>, this structure
should have been initialized by a call to 
<TT
CLASS="FUNCTION"
>inflateInit2_()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> is only in the binary standard; source
level applications should initialize <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
via a call to <TT
CLASS="FUNCTION"
>inflateInit()</TT
> or 
<TT
CLASS="FUNCTION"
>inflateInit2()</TT
>.</P
></BLOCKQUOTE
></DIV
>
In addition, the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> input and output buffers
should have been initialized as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19019"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to the data to be decompressed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19024"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the number of bytes of data in the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19030"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to a buffer where decompressed data may be placed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19035"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the size in bytes of the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="FUNCTION"
>inflate()</TT
> function
shall perform one or both of the following actions:
<P
></P
><OL
TYPE="1"
><LI
><P
>Decompress input data from <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>
and update <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> to reflect the data that has been 
decompressed.</P
></LI
><LI
><P
>Fill the output buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
and update <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
> to reflect the decompressed data that 
has been placed there. If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is not
<CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).</P
></LI
></OL
></P
><P
>The <TT
CLASS="FUNCTION"
>inflate()</TT
> function shall return when either
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> reaches zero (indicating that all the input
data has been compressed), or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> reaches
zero (indicating that the output buffer is full).</P
><P
>On success, the <TT
CLASS="FUNCTION"
>inflate()</TT
> function shall set the
<CODE
CLASS="STRUCTFIELD"
>adler</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
to the Adler-32 checksum of all the input data compressed
so far (represented by <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
>).</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN19068"
></A
><H3
>Flush Operation</H3
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> determines when uncompressed bytes
are added to the output buffer in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>.
If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>inflate()</TT
>
may return with some data pending output, and not yet added to the 
output buffer.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>inflate()</TT
> shall flush all pending output to
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>, and update 
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>
and <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> accordingly.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_BLOCK</CODE
>,
<TT
CLASS="FUNCTION"
>inflate()</TT
> shall stop adding data to the output
buffer if and when the next compressed block boundary is reached
(see <A
HREF="#STD.RFC1951"
>RFC 1951: DEFLATE Compressed Data Format Specification</A
>).</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>,
all of the compressed input shall be decompressed and added to
the output. If there is insufficient output space (i.e. the compressed
input data uncompresses to more than <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>
bytes), then <TT
CLASS="FUNCTION"
>inflate()</TT
> shall fail and return
<SPAN
CLASS="RETURNVALUE"
>Z_BUF_ERROR</SPAN
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19094"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
> if decompression progress has been made,
or <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
> if all of the input data
has been decompressed and there was sufficient space in the output
buffer to store the uncompressed result.

On error, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall return a value to indicate
the error.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If <TT
CLASS="FUNCTION"
>inflate()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>
and has set <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> to zero, the function should
be called again with the same value for <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>, and with
updated <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> until <TT
CLASS="FUNCTION"
>inflate()</TT
>
returns with either <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
> 
or <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
>
and a non-zero 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>.</P
></BLOCKQUOTE
></DIV
></P
><P
>On success, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall set the 
<CODE
CLASS="STRUCTFIELD"
>adler</CODE
> to the Adler-32 checksum of
the output produced so far (i.e. <CODE
CLASS="STRUCTFIELD"
>total_out</CODE
>
bytes).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19117"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall return a value as described 
below, and may set the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to point to a string describing the error:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19124"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No progress is possible; either <CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
>
or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> was zero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19131"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19136"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19144"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_NEED_DICT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A preset dictionary is required. The <CODE
CLASS="STRUCTFIELD"
>adler</CODE
>
field shall be set to the Adler-32 checksum of the dictionary chosen
by the compressor.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATEEND-1"
></A
>inflateEnd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19154"
></A
><H2
>Name</H2
>inflateEnd&nbsp;--&nbsp;free decompression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19159"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19160"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateEnd</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19167"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateEnd()</TT
> function shall free all allocated
state information referenced by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output is discarded, and unprocessed input is ignored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19172"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateEnd()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19178"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateEnd()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>zfree</CODE
> function pointer is
<CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATEINIT2"
></A
>inflateInit2_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19199"
></A
><H2
>Name</H2
>inflateInit2_&nbsp;--&nbsp;initialize decompression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19204"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19205"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>inflateInit2_</TT
>
  </CODE
>(z_streamp <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
>, char * <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19218"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> function shall initialize the decompression
system.
On entry, <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
> shall refer to a user supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19226"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19233"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19241"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and <CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with the version
implemented, or if the size of the <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size in the library 
implementation, <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
> parameter shall be a base 2 logarithm of the maximum
window 
size to use, and shall be a value between <CODE
CLASS="CONSTANT"
>8</CODE
> and <CODE
CLASS="CONSTANT"
>15</CODE
>.
If the input data was compressed with a larger window size, subsequent attempts to
decompress this data will fail with <CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
>, rather than try to
allocate a larger window.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>inflateInit2()</TT
> macro.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19265"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19271"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19276"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19281"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19286"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-INFLATEINIT"
></A
>inflateInit_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19299"
></A
><H2
>Name</H2
>inflateInit_&nbsp;--&nbsp;initialize decompression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19304"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19305"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateInit_</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19316"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> function shall initialize the
decompression system.
On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall refer to a user supplied
<SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19324"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19331"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19339"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and <CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with the version
implemented, or if the size of the <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size in the library 
implementation, <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>inflateInit()</TT
> macro.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall be equivalent to 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>inflateInit2_(strm, DEF_WBITS, version, stream_size);</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19361"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19367"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19372"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19377"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19382"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-INFLATERESET-1"
></A
>inflateReset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19395"
></A
><H2
>Name</H2
>inflateReset&nbsp;--&nbsp;reset decompression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19400"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19401"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateReset</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19408"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateReset()</TT
> function shall reset all state
associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output shall be discarded, and the counts of processed
bytes (<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
>) shall be reset to zero.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19415"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateReset()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19421"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateReset()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent or inappropriate.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATESETDICTIONARY-1"
></A
>inflateSetDictionary</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19438"
></A
><H2
>Name</H2
>inflateSetDictionary&nbsp;--&nbsp;initialize decompression dictionary</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19443"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19444"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateSetDictionary</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19455"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> function shall initialize the
decompression dictionary associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
using the <TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
> bytes referenced by
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> function should be called
immediately after a call to <TT
CLASS="FUNCTION"
>inflate()</TT
> has failed
with return value <SPAN
CLASS="RETURNVALUE"
>Z_NEED_DICT</SPAN
>. The 
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
> must have the same Adler-32
checksum as the dictionary used for
the compression (see <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
>).</P
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall reference an initialized decompression
stream, with <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> zero (i.e. no data
has been decompressed since the stream was initialized).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19471"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return a value as indicated below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19476"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19481"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19489"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The Adler-32 checksum of the supplied dictionary does not match that used
for the compression.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19494"
></A
><H2
>Application Usage (informative)</H2
><P
>The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.</P
><P
>The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.</P
></DIV
><H1
><A
NAME="ZLIB-INFLATESYNC-1"
></A
>inflateSync</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19502"
></A
><H2
>Name</H2
>inflateSync&nbsp;--&nbsp;advance compression stream to next sync point</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19507"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19508"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateSync</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19515"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateSync()</TT
> function shall advance through the
compressed data in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, skipping any invalid
compressed data, until the next full flush point is reached, or all
input is exhausted. See the
description for <TT
CLASS="FUNCTION"
>deflate()</TT
> with flush level
<CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>.
No output is placed in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19523"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateSync()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, and update the
<CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>,, <CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
>, and, <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
>
fields of <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to reflect the number
of bytes of compressed data that have been skipped.
Otherwise, <TT
CLASS="FUNCTION"
>inflateSync()</TT
>
shall return a value as described below to indicate the
error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19537"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateSync()</TT
> shall return a value
as described below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19542"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19550"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There is no data available to skip over.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19555"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No sync point was found.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATESYNCPOINT-1"
></A
>inflateSyncPoint</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19564"
></A
><H2
>Name</H2
>inflateSyncPoint&nbsp;--&nbsp;test for synchronization point</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19569"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19570"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateSyncPoint</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19577"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> function shall return a non-zero
calue if the compressed data stream referenced by
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is at a synchronization point. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19582"
></A
><H2
>Return Value</H2
><P
>If the compressed data in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is at 
a synchronization point (see <TT
CLASS="FUNCTION"
>deflate()</TT
>
with a flush level of <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
> or
<CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>), <TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> 
shall return  a non-zero value, other than <CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
>. 
Otherwise, if the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is valid,
<TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> shall return 0.
If <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is invalid, or in an invalid state,
<TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19596"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> shall return a value
as described below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19601"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-UNCOMPRESS-1"
></A
>uncompress</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19613"
></A
><H2
>Name</H2
>uncompress&nbsp;--&nbsp;uncompress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19618"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19619"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>uncompress</TT
></CODE
>(Bytef *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, uLongf *
<TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19632"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>uncompress()</TT
> function shall attempt to uncompress
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data in the buffer 
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, placing the result in the buffer
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. </P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
> should point to a value describing
the size of the <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer. 
The application should ensure that this value is large enough to hold
the entire uncompressed data.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not describe any mechanism by which a compressor can
communicate the size required to the uncompressor. </P
></BLOCKQUOTE
></DIV
>
On successful exit, the variable referenced by <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>
shall be updated to hold the length of uncompressed data in
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19646"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>uncompress()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>uncompress()</TT
> shall return a value to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19652"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>uncompress()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19657"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was not large enough to hold the
uncompressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19663"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19668"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The compressed data (referenced by <TT
CLASS="PARAMETER"
><I
>source</I
></TT
>) was corrupted.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-ZERROR-1"
></A
>zError</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19678"
></A
><H2
>Name</H2
>zError&nbsp;--&nbsp;translate error number to string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19683"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19684"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
<TT
CLASS="FUNCTION"
>zError</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>err</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19691"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>zError()</TT
> function shall return the string
identifying the error associated with <TT
CLASS="PARAMETER"
><I
>err</I
></TT
>.
This allows for conversion from error code to string for functions
such as <TT
CLASS="FUNCTION"
>compress()</TT
> and <TT
CLASS="FUNCTION"
>uncompress()</TT
>,
that do not always set the string version of an error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19698"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>zError()</TT
> function shall return a 
the string identifying the error associated with 
<TT
CLASS="PARAMETER"
><I
>err</I
></TT
>, or <SPAN
CLASS="RETURNVALUE"
>NULL</SPAN
> if
<TT
CLASS="PARAMETER"
><I
>err</I
></TT
> is not a valid error code.</P
><P
>It is unspecified if the string returned is determined by the setting
of the <CODE
CLASS="CONSTANT"
>LC_MESSAGES</CODE
> category in the current locale.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19707"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-ZLIBVERSION-1"
></A
>zlibVersion</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19714"
></A
><H2
>Name</H2
>zlibVersion&nbsp;--&nbsp;discover library version at run time</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19719"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19720"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   const char * <TT
CLASS="FUNCTION"
>zlibVersion</TT
>
  </CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19726"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>zlibVersion()</TT
> function shall return the string
identifying the interface version at the time the library was built.</P
><P
>Applications should compare the value returned from 
<TT
CLASS="FUNCTION"
>zlibVersion()</TT
> with the macro constant 
<CODE
CLASS="CONSTANT"
>ZLIB_VERSION</CODE
> for compatibility.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19733"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>zlibVersion()</TT
> function shall return a 
the string identifying the version of the library currently implemented.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19737"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSES"
>14.5. Interfaces for libncurses</A
></H2
><P
><A
HREF="#LIB-LIBNCURSES-DEF"
>Table 14-3</A
> defines the library name and shared object name
for the libncurses library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBNCURSES-DEF"
></A
><P
><B
>Table 14-3. libncurses Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libncurses</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libncurses.so.5</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Parameters or return value of the following interface have had the const qualifier added as 
shown here. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>extern const char *keyname (int);
extern int mvscanw (int, int, const char *, ...);
extern int mvwscanw (WINDOW *, int, int, const char *, ...);
extern SCREEN *newterm (const char *, FILE *, FILE *);
extern int scanw (const char *, ...);
extern int vwscanw (WINDOW *, const char *, va_list);
extern int vw_scanw (WINDOW *, const char *, va_list);
extern int wscanw (WINDOW *, const char *, ...);</PRE
></TD
></TR
></TABLE
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBNCURSES.1"
></A
>[SUS-CURSES] <A
HREF="#STD.SUS.CURSES"
>X/Open Curses</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN19760"
>14.5.1. Curses</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN19763"
>14.5.1.1. Interfaces for Curses</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Curses specified in <A
HREF="#TBL-LIBNCURSES-CUR-INTS"
>Table 14-4</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSES-CUR-INTS"
></A
><P
><B
>Table 14-4. libncurses - Curses Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>addch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>addchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>addchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>addnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>addstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>attr_get <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>attr_off <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>attr_on <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>attr_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>attroff <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>attron <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>attrset <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>baudrate <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>beep <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>bkgd <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>bkgdset <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>border <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>box <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>can_change_color <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>cbreak <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>chgat <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>clear <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>clearok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>clrtobot <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>clrtoeol <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>color_content <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>color_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>copywin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>curs_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>def_prog_mode <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>def_shell_mode <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>del_curterm <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>delay_output <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>delch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>deleteln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>delscreen <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>delwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>derwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>doupdate <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>dupwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>echo <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>echochar <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>endwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>erase <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>erasechar <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>filter <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>flash <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>flushinp <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>getbkgd <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>getch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>getnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>getstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>getwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>halfdelay <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>has_colors <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>has_ic <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>has_il <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>hline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>idcok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>idlok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>immedok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>inch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>inchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>inchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>init_color <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>init_pair <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>initscr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>innstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>insch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>insdelln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>insertln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>insnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>insstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>instr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>intrflush <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>is_linetouched <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>is_wintouched <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>isendwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>keyname <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>keypad <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>killchar <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>leaveok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>longname <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>meta <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>move <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvaddch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvaddchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvaddchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvaddstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvchgat <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvcur <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvdelch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvderwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvgetch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvgetnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvgetstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvhline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvinch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvinchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvinchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvinnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvinsch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvinsnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvinsstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvinstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvprintw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvvline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwaddch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwaddchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwaddchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvwaddnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwaddstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwchgat <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwdelch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvwgetch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwgetnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwgetstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwhline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwinch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwinchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwinchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvwinnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwinsch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwinsnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwinsstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>mvwinstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwprintw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>mvwvline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>napms <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>newpad <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>newterm <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>newwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>nl <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>nocbreak <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>nodelay <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>noecho <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>nonl <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>noqiflush <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>noraw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>notimeout <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>overlay <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>overwrite <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>pair_content <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>pechochar <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>pnoutrefresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>prefresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>printw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>putp <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>putwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>qiflush <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>raw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>redrawwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>refresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>reset_prog_mode <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>reset_shell_mode <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>resetty <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>restartterm <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>ripoffline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>savetty <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>scanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>scr_dump <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>scr_init <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>scr_restore <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>scr_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>scrl <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>scroll <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>scrollok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>set_curterm <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>set_term <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>setscrreg <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>setupterm <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_attr_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>slk_attroff <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_attron <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_attrset <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_clear <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>slk_color <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_init <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_label <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_noutrefresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>slk_refresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_restore <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>slk_touch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>standend <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>standout <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>start_color <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>subpad <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>subwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>syncok <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>termattrs <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>termname <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>tgetent <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tgetflag <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tgetnum <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tgetstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>tgoto <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tigetflag <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tigetnum <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tigetstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>timeout <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>touchline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>touchwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>tparm <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>tputs <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>typeahead <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>unctrl <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>ungetch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>untouchwin <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>use_env <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>vidattr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>vidputs <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>vline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>vw_printw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>vw_scanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>vwprintw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>vwscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>waddch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>waddchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>waddchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>waddnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>waddstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wattr_get <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wattr_off <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wattr_on <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wattr_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wattroff <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wattron <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wattrset <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wbkgd <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wbkgdset <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wborder <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wchgat <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wclear <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wclrtobot <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wclrtoeol <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wcolor_set <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wcursyncup <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wdelch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wdeleteln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wechochar <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>werase <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wgetch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wgetnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wgetstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>whline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>winchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winsch <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winsdelln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>winsertln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winsnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winsstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>winstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wmove <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wnoutrefresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wprintw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wredrawln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wrefresh <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wscrl <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wsetscrreg <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wstandend <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wstandout <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wsyncdown <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wsyncup <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>wtimeout <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wtouchln <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>wvline <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Curses specified in <A
HREF="#TBL-LIBNCURSES-CUR-DATA"
>Table 14-5</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSES-CUR-DATA"
></A
><P
><B
>Table 14-5. libncurses - Curses Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>COLORS <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>COLOR_PAIRS <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>COLS <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>LINES <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
><TR
><TD
>acs_map <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>cur_term <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>curscr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
><TD
>stdscr <A
HREF="#REFSTD.LIBNCURSES.1"
>[SUS-CURSES]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSES-DDEFS"
>14.6. Data Definitions for libncurses</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libncurses.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN20987"
>14.6.1. curses.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ERR	(-1)
#define OK	(0)
#define ACS_RARROW	(acs_map['+'])
#define ACS_LARROW	(acs_map[','])
#define ACS_UARROW	(acs_map['-'])
#define ACS_DARROW	(acs_map['.'])
#define ACS_BLOCK	(acs_map['0'])
#define ACS_CKBOARD	(acs_map['a'])
#define ACS_DEGREE	(acs_map['f'])
#define ACS_PLMINUS	(acs_map['g'])
#define ACS_BOARD	(acs_map['h'])
#define ACS_LANTERN	(acs_map['i'])
#define ACS_LRCORNER	(acs_map['j'])
#define ACS_URCORNER	(acs_map['k'])
#define ACS_ULCORNER	(acs_map['l'])
#define ACS_LLCORNER	(acs_map['m'])
#define ACS_PLUS	(acs_map['n'])
#define ACS_S1	(acs_map['o'])
#define ACS_HLINE	(acs_map['q'])
#define ACS_S9	(acs_map['s'])
#define ACS_LTEE	(acs_map['t'])
#define ACS_RTEE	(acs_map['u'])
#define ACS_BTEE	(acs_map['v'])
#define ACS_TTEE	(acs_map['w'])
#define ACS_VLINE	(acs_map['x'])
#define ACS_DIAMOND	(acs_map['`'])
#define ACS_BULLET	(acs_map['~'])
#define getmaxyx(win,y,x)	\
	(y=(win)?((win)-&#62;_maxy+1):ERR,x=(win)?((win)-&#62;_maxx+1):ERR)
#define getbegyx(win,y,x)	\
	(y=(win)?(win)-&#62;_begy:ERR,x=(win)?(win)-&#62;_begx:ERR)
#define getyx(win,y,x)	\
	(y=(win)?(win)-&#62;_cury:ERR,x=(win)?(win)-&#62;_curx:ERR)
#define getparyx(win,y,x)	\
	(y=(win)?(win)-&#62;_pary:ERR,x=(win)?(win)-&#62;_parx:ERR)

#define WA_ALTCHARSET	A_ALTCHARSET
#define WA_ATTRIBUTES	A_ATTRIBUTES
#define WA_BLINK	A_BLINK
#define WA_BOLD	A_BOLD
#define WA_DIM	A_DIM
#define WA_HORIZONTAL	A_HORIZONTAL
#define WA_INVIS	A_INVIS
#define WA_LEFT	A_LEFT
#define WA_LOW	A_LOW
#define WA_NORMAL	A_NORMAL
#define WA_PROTECT	A_PROTECT
#define WA_REVERSE	A_REVERSE
#define WA_RIGHT	A_RIGHT
#define WA_STANDOUT	A_STANDOUT
#define WA_TOP	A_TOP
#define WA_UNDERLINE	A_UNDERLINE
#define WA_VERTICAL	A_VERTICAL
#define A_REVERSE	NCURSES_BITS(1UL,10)

#define COLOR_BLACK	0
#define COLOR_RED	1
#define COLOR_GREEN	2
#define COLOR_YELLOW	3
#define COLOR_BLUE	4
#define COLOR_MAGENTA	5
#define COLOR_CYAN	6
#define COLOR_WHITE	7

#define _SUBWIN	0x01
#define _ENDLINE	0x02
#define _FULLWIN	0x04
#define _ISPAD	0x10
#define _HASMOVED	0x20

typedef unsigned char bool;

typedef unsigned long int chtype;
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef struct {
    attr_t attr;
    wchar_t chars[5];
} cchar_t;
struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};

struct _win_st {
    short _cury;
    short _curx;
    short _maxy;
    short _maxx;
    short _begy;
    short _begx;
    short _flags;
    attr_t _attrs;
    chtype _bkgd;
    bool _notimeout;
    bool _clear;
    bool _leaveok;
    bool _scroll;
    bool _idlok;
    bool _idcok;
    bool _immed;
    bool _sync;
    bool _use_keypad;
    int _delay;
    struct ldat *_line;
    short _regtop;
    short _regbottom;
    int _parx;
    int _pary;
    WINDOW *_parent;
    struct pdat _pad;
    short _yoffset;
    cchar_t _bkgrnd;
};

#define KEY_CODE_YES	0400
#define KEY_BREAK	0401
#define KEY_MIN	0401
#define KEY_DOWN	0402
#define KEY_UP	0403
#define KEY_LEFT	0404
#define KEY_RIGHT	0405
#define KEY_HOME	0406
#define KEY_BACKSPACE	0407
#define KEY_F0	0410
#define KEY_DL	0510
#define KEY_IL	0511
#define KEY_DC	0512
#define KEY_IC	0513
#define KEY_EIC	0514
#define KEY_CLEAR	0515
#define KEY_EOS	0516
#define KEY_EOL	0517
#define KEY_SF	0520
#define KEY_SR	0521
#define KEY_NPAGE	0522
#define KEY_PPAGE	0523
#define KEY_STAB	0524
#define KEY_CTAB	0525
#define KEY_CATAB	0526
#define KEY_ENTER	0527
#define KEY_SRESET	0530
#define KEY_RESET	0531
#define KEY_PRINT	0532
#define KEY_LL	0533
#define KEY_A1	0534
#define KEY_A3	0535
#define KEY_B2	0536
#define KEY_C1	0537
#define KEY_C3	0540
#define KEY_BTAB	0541
#define KEY_BEG	0542
#define KEY_CANCEL	0543
#define KEY_CLOSE	0544
#define KEY_COMMAND	0545
#define KEY_COPY	0546
#define KEY_CREATE	0547
#define KEY_END	0550
#define KEY_EXIT	0551
#define KEY_FIND	0552
#define KEY_HELP	0553
#define KEY_MARK	0554
#define KEY_MESSAGE	0555
#define KEY_MOVE	0556
#define KEY_NEXT	0557
#define KEY_OPEN	0560
#define KEY_OPTIONS	0561
#define KEY_PREVIOUS	0562
#define KEY_REDO	0563
#define KEY_REFERENCE	0564
#define KEY_REFRESH	0565
#define KEY_REPLACE	0566
#define KEY_RESTART	0567
#define KEY_RESUME	0570
#define KEY_SAVE	0571
#define KEY_SBEG	0572
#define KEY_SCANCEL	0573
#define KEY_SCOMMAND	0574
#define KEY_SCOPY	0575
#define KEY_SCREATE	0576
#define KEY_SDC	0577
#define KEY_SDL	0600
#define KEY_SELECT	0601
#define KEY_SEND	0602
#define KEY_SEOL	0603
#define KEY_SEXIT	0604
#define KEY_SFIND	0605
#define KEY_SHELP	0606
#define KEY_SHOME	0607
#define KEY_SIC	0610
#define KEY_SLEFT	0611
#define KEY_SMESSAGE	0612
#define KEY_SMOVE	0613
#define KEY_SNEXT	0614
#define KEY_SOPTIONS	0615
#define KEY_SPREVIOUS	0616
#define KEY_SPRINT	0617
#define KEY_SREDO	0620
#define KEY_SREPLACE	0621
#define KEY_SRIGHT	0622
#define KEY_SRSUME	0623
#define KEY_SSAVE	0624
#define KEY_SSUSPEND	0625
#define KEY_SUNDO	0626
#define KEY_SUSPEND	0627
#define KEY_UNDO	0630
#define KEY_MOUSE	0631
#define KEY_RESIZE	0632
#define KEY_MAX	0777

#define PAIR_NUMBER(a)	(((a)&#38;A_COLOR)&#62;&#62;8)
#define NCURSES_BITS(mask,shift)	((mask)&#60;&#60;((shift)+8))
#define A_CHARTEXT	(NCURSES_BITS(1UL,0)-1UL)
#define A_NORMAL	0L
#define NCURSES_ATTR_SHIFT	8
#define A_COLOR	NCURSES_BITS(((1UL)&#60;&#60;8)-1UL,0)
#define A_BLINK	NCURSES_BITS(1UL,11)
#define A_DIM	NCURSES_BITS(1UL,12)
#define A_BOLD	NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS	NCURSES_BITS(1UL,15)
#define A_PROTECT	NCURSES_BITS(1UL,16)
#define A_HORIZONTAL	NCURSES_BITS(1UL,17)
#define A_LEFT	NCURSES_BITS(1UL,18)
#define A_LOW	NCURSES_BITS(1UL,19)
#define A_RIGHT	NCURSES_BITS(1UL,20)
#define A_TOP	NCURSES_BITS(1UL,21)
#define A_VERTICAL	NCURSES_BITS(1UL,22)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define COLOR_PAIR(n)	NCURSES_BITS(n,0)
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL-1UL),0)

extern int addch(const chtype);
extern int addchnstr(const chtype *, int);
extern int addchstr(const chtype *);
extern int addnstr(const char *, int);
extern int addstr(const char *);
extern int attroff(int);
extern int attron(int);
extern int attrset(int);
extern int attr_get(attr_t *, short *, void *);
extern int attr_off(attr_t, void *);
extern int attr_on(attr_t, void *);
extern int attr_set(attr_t, short, void *);
extern int baudrate(void);
extern int beep(void);
extern int bkgd(chtype);
extern void bkgdset(chtype);
extern int border(chtype, chtype, chtype, chtype, chtype, chtype, chtype,
		  chtype);
extern int box(WINDOW *, chtype, chtype);
extern bool can_change_color(void);
extern int cbreak(void);
extern int chgat(int, attr_t, short, const void *);
extern int clear(void);
extern int clearok(WINDOW *, bool);
extern int clrtobot(void);
extern int clrtoeol(void);
extern int color_content(short, short *, short *, short *);
extern int color_set(short, void *);
extern int copywin(const WINDOW *, WINDOW *, int, int, int, int, int, int,
		   int);
extern int curs_set(int);
extern int def_prog_mode(void);
extern int def_shell_mode(void);
extern int delay_output(int);
extern int delch(void);
extern void delscreen(SCREEN *);
extern int delwin(WINDOW *);
extern int deleteln(void);
extern WINDOW *derwin(WINDOW *, int, int, int, int);
extern int doupdate(void);
extern WINDOW *dupwin(WINDOW *);
extern int echo(void);
extern int echochar(const chtype);
extern int erase(void);
extern int endwin(void);
extern char erasechar(void);
extern void filter(void);
extern int flash(void);
extern int flushinp(void);
extern chtype getbkgd(WINDOW *);
extern int getch(void);
extern int getnstr(char *, int);
extern int getstr(char *);
extern WINDOW *getwin(FILE *);
extern int halfdelay(int);
extern bool has_colors(void);
extern bool has_ic(void);
extern bool has_il(void);
extern int hline(chtype, int);
extern void idcok(WINDOW *, bool);
extern int idlok(WINDOW *, bool);
extern void immedok(WINDOW *, bool);
extern chtype inch(void);
extern int inchnstr(chtype *, int);
extern int inchstr(chtype *);
extern WINDOW *initscr(void);
extern int init_color(short, short, short, short);
extern int init_pair(short, short, short);
extern int innstr(char *, int);
extern int insch(chtype);
extern int insdelln(int);
extern int insertln(void);
extern int insnstr(const char *, int);
extern int insstr(const char *);
extern int instr(char *);
extern int intrflush(WINDOW *, bool);
extern bool isendwin(void);
extern bool is_linetouched(WINDOW *, int);
extern bool is_wintouched(WINDOW *);
extern const char *keyname(int);
extern int keypad(WINDOW *, bool);
extern char killchar(void);
extern int leaveok(WINDOW *, bool);
extern char *longname(void);
extern int meta(WINDOW *, bool);
extern int move(int, int);
extern int mvaddch(int, int, const chtype);
extern int mvaddchnstr(int, int, const chtype *, int);
extern int mvaddchstr(int, int, const chtype *);
extern int mvaddnstr(int, int, const char *, int);
extern int mvaddstr(int, int, const char *);
extern int mvchgat(int, int, int, attr_t, short, const void *);
extern int mvcur(int, int, int, int);
extern int mvdelch(int, int);
extern int mvderwin(WINDOW *, int, int);
extern int mvgetch(int, int);
extern int mvgetnstr(int, int, char *, int);
extern int mvgetstr(int, int, char *);
extern int mvhline(int, int, chtype, int);
extern chtype mvinch(int, int);
extern int mvinchnstr(int, int, chtype *, int);
extern int mvinchstr(int, int, chtype *);
extern int mvinnstr(int, int, char *, int);
extern int mvinsch(int, int, chtype);
extern int mvinsnstr(int, int, const char *, int);
extern int mvinsstr(int, int, const char *);
extern int mvinstr(int, int, char *);
extern int mvprintw(int, int, char *, ...);
extern int mvscanw(int, int, const char *, ...);
extern int mvvline(int, int, chtype, int);
extern int mvwaddch(WINDOW *, int, int, const chtype);
extern int mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr(WINDOW *, int, int, const chtype *);
extern int mvwaddnstr(WINDOW *, int, int, const char *, int);
extern int mvwaddstr(WINDOW *, int, int, const char *);
extern int mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch(WINDOW *, int, int);
extern int mvwgetch(WINDOW *, int, int);
extern int mvwgetnstr(WINDOW *, int, int, char *, int);
extern int mvwgetstr(WINDOW *, int, int, char *);
extern int mvwhline(WINDOW *, int, int, chtype, int);
extern int mvwin(WINDOW *, int, int);
extern chtype mvwinch(WINDOW *, int, int);
extern int mvwinchnstr(WINDOW *, int, int, chtype *, int);
extern int mvwinchstr(WINDOW *, int, int, chtype *);
extern int mvwinnstr(WINDOW *, int, int, char *, int);
extern int mvwinsch(WINDOW *, int, int, chtype);
extern int mvwinsnstr(WINDOW *, int, int, const char *, int);
extern int mvwinsstr(WINDOW *, int, int, const char *);
extern int mvwinstr(WINDOW *, int, int, char *);
extern int mvwprintw(WINDOW *, int, int, char *, ...);
extern int mvwscanw(WINDOW *, int, int, const char *, ...);
extern int mvwvline(WINDOW *, int, int, chtype, int);
extern int napms(int);
extern WINDOW *newpad(int, int);
extern SCREEN *newterm(const char *, FILE *, FILE *);
extern WINDOW *newwin(int, int, int, int);
extern int nl(void);
extern int nocbreak(void);
extern int nodelay(WINDOW *, bool);
extern int noecho(void);
extern int nonl(void);
extern void noqiflush(void);
extern int noraw(void);
extern int notimeout(WINDOW *, bool);
extern int overlay(const WINDOW *, WINDOW *);
extern int overwrite(const WINDOW *, WINDOW *);
extern int pair_content(short, short *, short *);
extern int pechochar(WINDOW *, chtype);
extern int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
extern int prefresh(WINDOW *, int, int, int, int, int, int);
extern int printw(char *, ...);
extern int putwin(WINDOW *, FILE *);
extern void qiflush(void);
extern int raw(void);
extern int redrawwin(WINDOW *);
extern int refresh(void);
extern int resetty(void);
extern int reset_prog_mode(void);
extern int reset_shell_mode(void);
extern int ripoffline(int, int (*init) (WINDOW *, int)
    );
extern int savetty(void);
extern int scanw(const char *, ...);
extern int scr_dump(const char *);
extern int scr_init(const char *);
extern int scrl(int);
extern int scroll(WINDOW *);
extern int scrollok(WINDOW *, typedef unsigned char bool);
extern int scr_restore(const char *);
extern int scr_set(const char *);
extern int setscrreg(int, int);
extern SCREEN *set_term(SCREEN *);
extern int slk_attroff(const typedef unsigned long int chtype);
extern int slk_attron(const typedef unsigned long int chtype);
extern int slk_attrset(const typedef unsigned long int chtype);
extern int slk_attr_set(const typedef chtype attr_t, short, void *);
extern int slk_clear(void);
extern int slk_color(short);
extern int slk_init(int);
extern char *slk_label(int);
extern int slk_noutrefresh(void);
extern int slk_refresh(void);
extern int slk_restore(void);
extern int slk_set(int, const char *, int);
extern int slk_touch(void);
extern int standout(void);
extern int standend(void);
extern int start_color(void);
extern WINDOW *subpad(WINDOW *, int, int, int, int);
extern WINDOW *subwin(WINDOW *, int, int, int, int);
extern int syncok(WINDOW *, typedef unsigned char bool);
extern typedef unsigned long int chtype termattrs(void);
extern char *termname(void);
extern void timeout(int);
extern int typeahead(int);
extern int ungetch(int);
extern int untouchwin(WINDOW *);
extern void use_env(typedef unsigned char bool);
extern int vidattr(typedef unsigned long int chtype);
extern int vidputs(typedef unsigned long int chtype,
		   int (*vidputs_int) (int)
    );
extern int vline(typedef unsigned long int chtype, int);
extern int vwprintw(WINDOW *, char *, typedef void *va_list);
extern int vw_printw(WINDOW *, const char *, typedef void *va_list);
extern int vwscanw(WINDOW *, const char *, typedef void *va_list);
extern int vw_scanw(WINDOW *, const char *, typedef void *va_list);
extern int waddch(WINDOW *, const typedef unsigned long int chtype);
extern int waddchnstr(WINDOW *, const typedef unsigned long int chtype *,
		      int);
extern int waddchstr(WINDOW *, const typedef unsigned long int chtype *);
extern int waddnstr(WINDOW *, const char *, int);
extern int waddstr(WINDOW *, const char *);
extern int wattron(WINDOW *, int);
extern int wattroff(WINDOW *, int);
extern int wattrset(WINDOW *, int);
extern int wattr_get(WINDOW *, attr_t *, short *, void *);
extern int wattr_on(WINDOW *, typedef chtype attr_t, void *);
extern int wattr_off(WINDOW *, typedef chtype attr_t, void *);
extern int wattr_set(WINDOW *, typedef chtype attr_t, short, void *);
extern int wbkgd(WINDOW *, typedef unsigned long int chtype);
extern void wbkgdset(WINDOW *, typedef unsigned long int chtype);
extern int wborder(WINDOW *, typedef unsigned long int chtype,
		   typedef unsigned long int chtype,
		   typedef unsigned long int chtype,
		   typedef unsigned long int chtype,
		   typedef unsigned long int chtype,
		   typedef unsigned long int chtype,
		   typedef unsigned long int chtype,
		   typedef unsigned long int chtype);
extern int wchgat(WINDOW *, int, typedef chtype attr_t, short,
		  const void *);
extern int wclear(WINDOW *);
extern int wclrtobot(WINDOW *);
extern int wclrtoeol(WINDOW *);
extern int wcolor_set(WINDOW *, short, void *);
extern void wcursyncup(WINDOW *);
extern int wdelch(WINDOW *);
extern int wdeleteln(WINDOW *);
extern int wechochar(WINDOW *, const typedef unsigned long int chtype);
extern int werase(WINDOW *);
extern int wgetch(WINDOW *);
extern int wgetnstr(WINDOW *, char *, int);
extern int wgetstr(WINDOW *, char *);
extern int whline(WINDOW *, typedef unsigned long int chtype, int);
extern typedef unsigned long int chtype winch(WINDOW *);
extern int winchnstr(WINDOW *, chtype *, int);
extern int winchstr(WINDOW *, chtype *);
extern int winnstr(WINDOW *, char *, int);
extern int winsch(WINDOW *, typedef unsigned long int chtype);
extern int winsdelln(WINDOW *, int);
extern int winsertln(WINDOW *);
extern int winsnstr(WINDOW *, const char *, int);
extern int winsstr(WINDOW *, const char *);
extern int winstr(WINDOW *, char *);
extern int wmove(WINDOW *, int, int);
extern int wnoutrefresh(WINDOW *);
extern int wprintw(WINDOW *, char *, ...);
extern int wredrawln(WINDOW *, int, int);
extern int wrefresh(WINDOW *);
extern int wscanw(WINDOW *, const char *, ...);
extern int wscrl(WINDOW *, int);
extern int wsetscrreg(WINDOW *, int, int);
extern int wstandout(WINDOW *);
extern int wstandend(WINDOW *);
extern void wsyncdown(WINDOW *);
extern void wsyncup(WINDOW *);
extern void wtimeout(WINDOW *, int);
extern int wtouchln(WINDOW *, int, int, int);
extern int wvline(WINDOW *, typedef unsigned long int chtype, int);
extern char *unctrl(typedef unsigned long int chtype);
extern int COLORS(void);
extern int COLOR_PAIRS(void);
extern chtype acs_map(void);
extern WINDOW *curscr(void);
extern WINDOW *stdscr(void);
extern int COLS(void);
extern int LINES(void);
extern int touchline(WINDOW *, int, int);
extern int touchwin(WINDOW *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN20991"
>14.6.2. term.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int putp(const char *);
extern int tigetflag(const char *);
extern int tigetnum(const char *);
extern char *tigetstr(const char *);
extern char *tparm(const char *, ...);
extern TERMINAL *set_curterm(TERMINAL *);
extern int del_curterm(TERMINAL *);
extern int restartterm(char *, int, int *);
extern int setupterm(char *, int, int *);
extern char *tgetstr(char *, char **);
extern char *tgoto(const char *, int, int);
extern int tgetent(char *, const char *);
extern int tgetflag(char *);
extern int tgetnum(char *);
extern int tputs(const char *, int, int (*putcproc) (int)
    );
extern TERMINAL *cur_term(void);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBUTIL"
>14.7. Interfaces for libutil</A
></H2
><P
><A
HREF="#LIB-LIBUTIL-DEF"
>Table 14-6</A
> defines the library name and shared object name
for the libutil library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBUTIL-DEF"
></A
><P
><B
>Table 14-6. libutil Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libutil</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libutil.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBUTIL.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN21013"
>14.7.1. Utility Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN21016"
>14.7.1.1. Interfaces for Utility Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Utility Functions specified in <A
HREF="#TBL-LIBUTIL-UTI-INTS"
>Table 14-7</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBUTIL-UTI-INTS"
></A
><P
><B
>Table 14-7. libutil - Utility Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>forkpty <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>login <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>login_tty <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>logout <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>logwtmp <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>openpty <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBUTILMAN"
>14.8. Interface Definitions for libutil</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#LIBUTIL-FORKPTY-3"
>forkpty</A
>&nbsp;--&nbsp;Create a new process attached to an available pseudo-terminal</DT
><DT
><A
HREF="#LIBUTIL-LOGIN-3"
>login</A
>&nbsp;--&nbsp;login utility function</DT
><DT
><A
HREF="#LIBUTIL-LOGIN-TTY-3"
>login_tty</A
>&nbsp;--&nbsp;Prepare a terminal for login</DT
><DT
><A
HREF="#LIBUTIL-LOGOUT-3"
>logout</A
>&nbsp;--&nbsp;logout utility function</DT
><DT
><A
HREF="#BASELIB-LOGWTMP-3"
>logwtmp</A
>&nbsp;--&nbsp;append an entry to the wtmp file</DT
><DT
><A
HREF="#LIBUTIL-OPENPTY-3"
>openpty</A
>&nbsp;--&nbsp;find and open an available pseudo-terminal</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libutil and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBUTIL"
>Section 14.7</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="LIBUTIL-FORKPTY-3"
></A
>forkpty</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21061"
></A
><H2
>Name</H2
>forkpty&nbsp;--&nbsp;Create a new process attached to an available pseudo-terminal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21066"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21069"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pty.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>forkpty</TT
></CODE
>(int *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>amaster</I
></TT
></I
></TT
>, char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, struct termios *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>termp</I
></TT
></I
></TT
>, struct winsize *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>winp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21086"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>forkpty()</TT
>
function shall find and open a pseudo-terminal device pair in the
same manner as the <TT
CLASS="FUNCTION"
>openpty()</TT
> function. 
If a pseudo-terminal is available,
<TT
CLASS="FUNCTION"
>forkpty()</TT
>
shall create a new process in the same manner as the <TT
CLASS="FUNCTION"
>fork()</TT
>
function, and prepares the new process for login in the same manner as 
<TT
CLASS="FUNCTION"
>login_tty()</TT
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>termp</I
></TT
> is not null, 
it shall refer to a <CODE
CLASS="VARNAME"
>termios</CODE
> structure that shall be used
to initialize the characteristics of the slave device. 
If <TT
CLASS="PARAMETER"
><I
>winp</I
></TT
> is not null, it
shall refer to a <CODE
CLASS="VARNAME"
>winsize</CODE
> structure used to 
initialize the window size of the
slave device.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21101"
></A
><H2
>Return Value</H2
><P
>On success, the parent process shall return the process id of the child, and the
child shall return 0. On error, no new process shall be created, -1 shall be
returned, and <CODE
CLASS="VARNAME"
>errno</CODE
> shall be set appropriately.
On success, the parent process shall receive the file descriptor of the master
side of the pseudo-terminal in the location referenced by 
<TT
CLASS="PARAMETER"
><I
>amaster</I
></TT
>, and, if <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is
not NULL, the filename of the slave device in 
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21108"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21111"
></A
><SPAN
STYLE="white-space: nowrap"
>EAGAIN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unable to create a new process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21115"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There are no available pseudo-terminals.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21119"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory was available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LIBUTIL-LOGIN-3"
></A
>login</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21127"
></A
><H2
>Name</H2
>login&nbsp;--&nbsp;login utility function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21132"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21135"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
      <TT
CLASS="FUNCTION"
>login</TT
>
    </CODE
>(struct utmp *
      <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ut</I
></TT
></I
></TT
>
    );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21143"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>login()</TT
> function shall update the user 
accounting databases.
The <TT
CLASS="PARAMETER"
><I
>ut</I
></TT
> parameter shall reference a 
<TT
CLASS="STRUCTNAME"
>utmp</TT
> structure 
for all fields except the following:
<P
></P
><OL
TYPE="1"
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>ut_type</CODE
> field shall be set to <CODE
CLASS="CONSTANT"
>USER_PROCESS</CODE
>.</P
></LI
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>ut_pid</CODE
> field shall be set to the process identifier
for the current process.</P
></LI
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field shall be set to the name of the 
controlling terminal device.
The name shall be found by examining the device associated with the
standard input, output and error streams in sequence, until one associated with
a terminal device is found.
If none of these streams refers to a terminal device, the 
<CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field shall be set to <CODE
CLASS="CONSTANT"
>"???"</CODE
>.
If the terminal device is in the <TT
CLASS="FILENAME"
>/dev</TT
> directory
hierarchy, the <CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field shall not contain the leading
<CODE
CLASS="CONSTANT"
>"/dev/"</CODE
>, otherwise it shall be set to the final component
of the pathname of the device. 
If the user
accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field, it shall
truncate the name, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_LINESIZE</CODE
>
(including a terminating null character).</P
></LI
></OL
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21169"
></A
><H2
>Return Value</H2
><P
>None</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21172"
></A
><H2
>Errors</H2
><P
>None</P
></DIV
><H1
><A
NAME="LIBUTIL-LOGIN-TTY-3"
></A
>login_tty</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21179"
></A
><H2
>Name</H2
>login_tty&nbsp;--&nbsp;Prepare a terminal for login</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21184"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21187"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
    <TT
CLASS="FUNCTION"
>login_tty</TT
>
  </CODE
>(int <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fdr</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21195"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>login_tty()</TT
> function
shall prepare the terminal device referenced by the file
descriptor <TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
>. 
This function shall create a new session, make the terminal 
the controlling terminal for the current process, and set the standard 
input, output, and error streams of the current process to the terminal.
If <TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
> is not the standard input, output or error stream,
then <TT
CLASS="FUNCTION"
>login_tty()</TT
> shall close <TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21205"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>login_tty()</TT
> shall return zero;
otherwise -1 is returned, and errno shall be set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21209"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21214"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTTY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
> does not refer to a terminal device.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LIBUTIL-LOGOUT-3"
></A
>logout</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21223"
></A
><H2
>Name</H2
>logout&nbsp;--&nbsp;logout utility function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21228"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21231"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
      <TT
CLASS="FUNCTION"
>logout</TT
>
    </CODE
>(const char *
      <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>line</I
></TT
></I
></TT
>
    );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21239"
></A
><H2
>Description</H2
><P
>Given the device <TT
CLASS="PARAMETER"
><I
>line</I
></TT
>,
the <TT
CLASS="FUNCTION"
>logout()</TT
> function shall search
the user accounting database which is read by <TT
CLASS="FUNCTION"
>getutent()</TT
>
for an entry with the corresponding line,
and with the type of <CODE
CLASS="CONSTANT"
>USER_PROCESS</CODE
>.
If a corresponding entry is located, it shall be updated as follows:
<P
></P
><OL
TYPE="1"
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_name</CODE
> field shall be set to zeroes
(<CODE
CLASS="CONSTANT"
>UT_NAMESIZE</CODE
> NUL bytes).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_host</CODE
> field shall be set to zeroes
(<CODE
CLASS="CONSTANT"
>UT_HOSTSIZE</CODE
> NUL bytes).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_tv</CODE
> shall be set to the current 
time of day.</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_type</CODE
> field shall be set to
<CODE
CLASS="CONSTANT"
>DEAD_PROCESS</CODE
>.</P
></LI
></OL
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21264"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>logout()</TT
> function shall return non-zero.
Zero is returned if there was no entry to remove, or if the utmp file
could not be opened or updated.</P
></DIV
><H1
><A
NAME="BASELIB-LOGWTMP-3"
></A
>logwtmp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21272"
></A
><H2
>Name</H2
>logwtmp&nbsp;--&nbsp;append an entry to the wtmp file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21275"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21278"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
    <TT
CLASS="FUNCTION"
>logwtmp</TT
>
  </CODE
>(const char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>line</I
></TT
></I
></TT
>
  , const char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>
  , const char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
></I
></TT
>
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21292"
></A
><H2
>Description</H2
><P
>If the process has permission to update the user accounting databases,
the <TT
CLASS="FUNCTION"
>logwtmp()</TT
> function
shall append a record to the user accounting database 
that records all logins and logouts. The record to be appended
shall be constructed as follows:
<P
></P
><OL
TYPE="1"
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_line</CODE
> field shall be initialized
from <TT
CLASS="PARAMETER"
><I
>line</I
></TT
>.
If the user accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_LINESIZE</CODE
>
(including a terminating null character).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_name</CODE
> field shall be initialized
from <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
If the user accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_name</CODE
> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_NAMESIZE</CODE
>
(including a terminating null character).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_host</CODE
> field shall be initialized
from <TT
CLASS="PARAMETER"
><I
>host</I
></TT
>.
If the user accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_host</CODE
> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_HOSTSIZE</CODE
>
(including a terminating null character).</P
></LI
><LI
><P
>If the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> parameter does not refer
to an empty string (i.e. <CODE
CLASS="CONSTANT"
>""</CODE
>), 
the <CODE
CLASS="VARNAME"
>ut_type</CODE
> field shall be set to 
<CODE
CLASS="CONSTANT"
>USER_PROCESS</CODE
>; otherwise the
<CODE
CLASS="VARNAME"
>ut_type</CODE
> field shall be set to 
<CODE
CLASS="CONSTANT"
>DEAD_PROCESS</CODE
>.</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_id</CODE
> field shall be set to the 
process identifier for the current process.</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_tv</CODE
> field shall be set to the
current time of day.</P
></LI
></OL
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If a process does not have write access to the 
the user accounting database, the
<TT
CLASS="FUNCTION"
>logwtmp()</TT
> function will not update it. 
Since the function does not return
any value, an application has no way of knowing whether it succeeded or failed.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21334"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><H1
><A
NAME="LIBUTIL-OPENPTY-3"
></A
>openpty</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21341"
></A
><H2
>Name</H2
>openpty&nbsp;--&nbsp;find and open an available pseudo-terminal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21346"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21349"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pty.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
    <TT
CLASS="FUNCTION"
>openpty</TT
></CODE
>(int *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>amaster</I
></TT
></I
></TT
>, int *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>aslave</I
></TT
></I
></TT
>, char *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, struct termios *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>termp</I
></TT
></I
></TT
>, struct winsize *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>winp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21369"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>openpty()</TT
>
function shall find an available pseudo-terminal
and return file descriptors for the master and slave devices in
the locations referenced by 
<TT
CLASS="PARAMETER"
><I
>amaster</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>aslave</I
></TT
>
respectively. 
If <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is not NULL,
the filename of the slave shall be placed in the user supplied buffer 
referenced by <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>termp</I
></TT
> is not NULL, it shall
point to a <CODE
CLASS="VARNAME"
>termios</CODE
> structure used to initialize
the terminal parameters of the slave pseudo-terminal device.
If <TT
CLASS="PARAMETER"
><I
>winp</I
></TT
> is not NULL, it shall
point to a <CODE
CLASS="VARNAME"
>winsize</CODE
> structure used to initialize
the window size parameters of the slave pseudo-terminal device.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21383"
></A
><H2
>Return Value</H2
><P
>On success, zero is returned. On error, -1 is returned, and errno is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21386"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21389"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There are no available pseudo-terminals.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCCOMMAND"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>V. Commands and Utilities</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>15. <A
HREF="#COMMAND"
>Commands and Utilities</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#CMDUTIL"
>Commands and Utilities</A
></DT
><DT
>15.2. <A
HREF="#CMDBEHAV"
>Command Behavior</A
></DT
><DD
><DL
><DT
><A
HREF="#AR"
>ar</A
>&nbsp;--&nbsp;create and maintain library archives (DEPRECATED)</DT
><DT
><A
HREF="#AT"
>at</A
>&nbsp;--&nbsp;examine or delete jobs for later execution</DT
><DT
><A
HREF="#AWK"
>awk</A
>&nbsp;--&nbsp;pattern scanning and processing language</DT
><DT
><A
HREF="#BATCH"
>batch</A
>&nbsp;--&nbsp;schedule commands to be executed in a batch queue</DT
><DT
><A
HREF="#BC"
>bc</A
>&nbsp;--&nbsp;an arbitrary precision calculator language</DT
><DT
><A
HREF="#CHFN"
>chfn</A
>&nbsp;--&nbsp;change user name and information</DT
><DT
><A
HREF="#CHSH"
>chsh</A
>&nbsp;--&nbsp;change login shell</DT
><DT
><A
HREF="#COL"
>col</A
>&nbsp;--&nbsp;filter reverse line feeds from input</DT
><DT
><A
HREF="#CPIO"
>cpio</A
>&nbsp;--&nbsp;copy file archives in and out</DT
><DT
><A
HREF="#CRONTAB"
>crontab</A
>&nbsp;--&nbsp;maintain crontab files for individual users</DT
><DT
><A
HREF="#CUT"
>cut</A
>&nbsp;--&nbsp;split a file into sections determined by context lines</DT
><DT
><A
HREF="#DF"
>df</A
>&nbsp;--&nbsp;report file system disk space usage</DT
><DT
><A
HREF="#DMESG"
>dmesg</A
>&nbsp;--&nbsp;print or control the system message buffer</DT
><DT
><A
HREF="#DU"
>du</A
>&nbsp;--&nbsp;estimate file space usage</DT
><DT
><A
HREF="#ECHO"
>echo</A
>&nbsp;--&nbsp;write arguments to standard output</DT
><DT
><A
HREF="#EGREP"
>egrep</A
>&nbsp;--&nbsp;search a file with an Extended Regular Expression pattern</DT
><DT
><A
HREF="#FGREP"
>fgrep</A
>&nbsp;--&nbsp;search a file with a fixed pattern</DT
><DT
><A
HREF="#FILE"
>file</A
>&nbsp;--&nbsp;determine file type</DT
><DT
><A
HREF="#FIND"
>find</A
>&nbsp;--&nbsp;search for files in a directory hierarchy</DT
><DT
><A
HREF="#FUSER"
>fuser</A
>&nbsp;--&nbsp;identify processes using files or sockets</DT
><DT
><A
HREF="#GETTEXT"
>gettext</A
>&nbsp;--&nbsp;retrieve text string from message catalog</DT
><DT
><A
HREF="#GREP"
>grep</A
>&nbsp;--&nbsp;print lines matching a pattern</DT
><DT
><A
HREF="#GROUPADD"
>groupadd</A
>&nbsp;--&nbsp;create a new group</DT
><DT
><A
HREF="#GROUPDEL"
>groupdel</A
>&nbsp;--&nbsp;delete a group</DT
><DT
><A
HREF="#GROUPMOD"
>groupmod</A
>&nbsp;--&nbsp;modify a group</DT
><DT
><A
HREF="#GROUPS"
>groups</A
>&nbsp;--&nbsp;display a group</DT
><DT
><A
HREF="#GUNZIP"
>gunzip</A
>&nbsp;--&nbsp;uncompress files</DT
><DT
><A
HREF="#GZIP"
>gzip</A
>&nbsp;--&nbsp;compress or expand files</DT
><DT
><A
HREF="#HOSTNAME"
>hostname</A
>&nbsp;--&nbsp;show or set the system's host name</DT
><DT
><A
HREF="#INSTALL"
>install</A
>&nbsp;--&nbsp;copy files and set attributes</DT
><DT
><A
HREF="#INSTALLINITD"
>install_initd</A
>&nbsp;--&nbsp;activate an init script</DT
><DT
><A
HREF="#IPCRM"
>ipcrm</A
>&nbsp;--&nbsp;remove IPC Resources</DT
><DT
><A
HREF="#IPCS"
>ipcs</A
>&nbsp;--&nbsp;provide information on ipc facilities</DT
><DT
><A
HREF="#KILLALL"
>killall</A
>&nbsp;--&nbsp;kill processes by name</DT
><DT
><A
HREF="#LPR"
>lpr</A
>&nbsp;--&nbsp;off line print</DT
><DT
><A
HREF="#LS"
>ls</A
>&nbsp;--&nbsp;list directory contents</DT
><DT
><A
HREF="#LSBRELEASE"
>lsb_release</A
>&nbsp;--&nbsp;print distribution specific information</DT
><DT
><A
HREF="#M4"
>m4</A
>&nbsp;--&nbsp;macro processor</DT
><DT
><A
HREF="#MD5SUM"
>md5sum</A
>&nbsp;--&nbsp;generate or check MD5 message digests</DT
><DT
><A
HREF="#MKNOD"
>mknod</A
>&nbsp;--&nbsp;make special files</DT
><DT
><A
HREF="#MKTEMP"
>mktemp</A
>&nbsp;--&nbsp;make temporary file name (unique)</DT
><DT
><A
HREF="#MORE"
>more</A
>&nbsp;--&nbsp;display files on a page-by-page basis</DT
><DT
><A
HREF="#MOUNT"
>mount</A
>&nbsp;--&nbsp;mount a file system </DT
><DT
><A
HREF="#MSGFMT"
>msgfmt</A
>&nbsp;--&nbsp;create a message object from a message file </DT
><DT
><A
HREF="#NEWGRP"
>newgrp</A
>&nbsp;--&nbsp;change group ID</DT
><DT
><A
HREF="#OD"
>od</A
>&nbsp;--&nbsp;dump files in octal and other formats </DT
><DT
><A
HREF="#PASSWD"
>passwd</A
>&nbsp;--&nbsp;change user password</DT
><DT
><A
HREF="#PATCH"
>patch</A
>&nbsp;--&nbsp;apply a diff file to an original</DT
><DT
><A
HREF="#PIDOF"
>pidof</A
>&nbsp;--&nbsp;find the process ID of a running program</DT
><DT
><A
HREF="#REMOVEINITD"
>remove_initd</A
>&nbsp;--&nbsp;clean up init script system modifications introduced by install_initd</DT
><DT
><A
HREF="#RENICE"
>renice</A
>&nbsp;--&nbsp;alter priority of running processes</DT
><DT
><A
HREF="#SED"
>sed</A
>&nbsp;--&nbsp;stream editor</DT
><DT
><A
HREF="#BASELIB-SENDMAIL-1"
>sendmail</A
>&nbsp;--&nbsp;an electronic mail transport agent</DT
><DT
><A
HREF="#SH"
>sh</A
>&nbsp;--&nbsp;shell, the standard command language interpreter</DT
><DT
><A
HREF="#SHUTDOWN"
>shutdown</A
>&nbsp;--&nbsp;shut the system down</DT
><DT
><A
HREF="#SU"
>su</A
>&nbsp;--&nbsp;change user ID</DT
><DT
><A
HREF="#SYNC"
>sync</A
>&nbsp;--&nbsp;flush file system buffers</DT
><DT
><A
HREF="#TAR"
>tar</A
>&nbsp;--&nbsp;file archiver</DT
><DT
><A
HREF="#UMOUNT"
>umount</A
>&nbsp;--&nbsp;unmount file systems</DT
><DT
><A
HREF="#USERADD"
>useradd</A
>&nbsp;--&nbsp;create a new user or update default new user information</DT
><DT
><A
HREF="#USERDEL"
>userdel</A
>&nbsp;--&nbsp;delete a user account and related files</DT
><DT
><A
HREF="#USERMOD"
>usermod</A
>&nbsp;--&nbsp;modify a user account</DT
><DT
><A
HREF="#XARGS"
>xargs</A
>&nbsp;--&nbsp;build and execute command lines from standard input</DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="COMMAND"
></A
>Chapter 15. Commands and Utilities</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="CMDUTIL"
>15.1. Commands and Utilities</A
></H2
><P
>An LSB conforming implementation shall provide the
commands and utilities as described in <A
HREF="#TBL-CMDS"
>Table 15-1</A
>, with at least the behavior
described as mandatory in the referenced underlying
specification, with the following exceptions:
<P
></P
><OL
TYPE="1"
><LI
><P
>If any operand (except one which follows <CODE
CLASS="OPTION"
>--</CODE
>) starts with a
hyphen, the behavior is unspecified.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale (Informative): </B
>Applications should place options before operands, or use
<CODE
CLASS="OPTION"
>--</CODE
>, as needed.  This text is needed because,
by default, GNU option parsing
differs from POSIX, unless the environment variable 
<CODE
CLASS="ENVAR"
>POSIXLY_CORRECT</CODE
>
is set.  For example, <B
CLASS="COMMAND"
>ls . -a</B
> in GNU
<B
CLASS="COMMAND"
>ls</B
> means to list the current directory, showing all
files (that is, <CODE
CLASS="OPTION"
>"."</CODE
> is an operand and <CODE
CLASS="OPTION"
>-a</CODE
> is an
option).  In POSIX, <CODE
CLASS="OPTION"
>"."</CODE
> and <CODE
CLASS="OPTION"
>-a</CODE
> are both operands,
and the command means to list the current directory, and also the file
named <TT
CLASS="FILENAME"
>-a</TT
>.  Suggesting that applications rely on the
setting of the <CODE
CLASS="ENVAR"
>POSIXLY_CORRECT</CODE
> environment variable,
or try to set it, seems worse than just asking the applictions to invoke
commands in ways which work with either the POSIX or GNU behaviors.</P
></BLOCKQUOTE
></DIV
></P
></LI
></OL
></P
><DIV
CLASS="TABLE"
><A
NAME="TBL-CMDS"
></A
><P
><B
>Table 15-1. Commands And Utilities</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>[
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>dmesg
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>id
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>mount
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>sort
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>ar
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>du
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>install
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>msgfmt
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>split
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>at
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>echo
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>install_initd
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>mv
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>strip
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>awk
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>ed
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>ipcrm
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>newgrp
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>stty
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>basename
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>egrep
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>ipcs
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>nice
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>su
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>batch
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>env
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>join
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>nl
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>sync
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>bc
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>expand
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>kill
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>nohup
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>tail
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>cat
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>expr
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>killall
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>od
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>tar
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>chfn
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>false
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>ln
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>passwd
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>tee
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>chgrp
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>fgrep
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>locale
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>paste
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>test
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>chmod
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>file
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>localedef
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>patch
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>time
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>chown
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>find
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>logger
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>pathchk
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>touch
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>chsh
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>fold
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>logname
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>pax
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>tr
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>cksum
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>fuser
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>lp
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>pidof
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>true
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>cmp
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>gencat
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>lpr
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>pr
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>tsort
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>col
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>getconf
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>ls
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>printf
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>tty
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>comm
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>gettext
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>lsb_release
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>ps
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>umount
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>cp
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>grep
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>m4
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>pwd
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>uname
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>cpio
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>groupadd
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>mailx
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>remove_initd
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>unexpand
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>crontab
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>groupdel
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>make
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>renice
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>uniq
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>csplit
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>groupmod
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>man
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>rm
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>useradd
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>cut
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>groups
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>md5sum
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>rmdir
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>userdel
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>date
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>gunzip
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>mkdir
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>sed
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>usermod
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>dd
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>gzip
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>mkfifo
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>sendmail
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>wc
<A
HREF="#AEN21719"
> [1]</A
></TD
></TR
><TR
><TD
>df
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>head
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>mknod
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>sh
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>xargs
<A
HREF="#AEN21723"
> [2]</A
></TD
></TR
><TR
><TD
>diff
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>hostname
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>mktemp
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>shutdown
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>dirname
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>iconv
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>more
<A
HREF="#AEN21723"
> [2]</A
></TD
><TD
>sleep
<A
HREF="#AEN21719"
> [1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
><I
CLASS="EMPHASIS"
>Referenced Specification(s)</I
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[1]. </B
></B
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></P
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[2]. </B
></B
><A
HREF="#STD.LSB"
>This Specification</A
></P
></DIV
><P
>An LSB conforming implementation shall provide the
shell built in utilities as described in <A
HREF="#TBL-BUILTINS"
>Table 15-2</A
>, with at least the behavior
described as mandatory in the referenced underlying
specification, with the following exceptions:
<P
></P
><OL
TYPE="1"
><LI
><P
>The built in commands and utilities shall be provided by the
<B
CLASS="COMMAND"
>sh</B
> utility itself, and need not 
be implemented in a manner so that they can be accessed via the 
exec family of functions as defined in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
and should not be invoked directly by those standard utilities 
that execute other utilities (
<B
CLASS="COMMAND"
>env</B
>, <B
CLASS="COMMAND"
>find</B
>, <B
CLASS="COMMAND"
>nice</B
>, <B
CLASS="COMMAND"
>nohup</B
>, <B
CLASS="COMMAND"
>time</B
>, <B
CLASS="COMMAND"
>xargs</B
>).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale (Informative): </B
>Since the built in utilities must affect the environment of the calling
process, they have no effect when executed as a file.</P
></BLOCKQUOTE
></DIV
></P
></LI
></OL
></P
><DIV
CLASS="TABLE"
><A
NAME="TBL-BUILTINS"
></A
><P
><B
>Table 15-2. Built In Utilities</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>cd
<A
HREF="#AEN21767"
> [1]</A
></TD
><TD
>getopts
<A
HREF="#AEN21767"
> [1]</A
></TD
><TD
>read
<A
HREF="#AEN21767"
> [1]</A
></TD
><TD
>umask
<A
HREF="#AEN21767"
> [1]</A
></TD
><TD
>wait
<A
HREF="#AEN21767"
> [1]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
><I
CLASS="EMPHASIS"
>Referenced Specification(s)</I
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[1]. </B
></B
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CMDBEHAV"
>15.2. Command Behavior</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AR"
>ar</A
>&nbsp;--&nbsp;create and maintain library archives (DEPRECATED)</DT
><DT
><A
HREF="#AT"
>at</A
>&nbsp;--&nbsp;examine or delete jobs for later execution</DT
><DT
><A
HREF="#AWK"
>awk</A
>&nbsp;--&nbsp;pattern scanning and processing language</DT
><DT
><A
HREF="#BATCH"
>batch</A
>&nbsp;--&nbsp;schedule commands to be executed in a batch queue</DT
><DT
><A
HREF="#BC"
>bc</A
>&nbsp;--&nbsp;an arbitrary precision calculator language</DT
><DT
><A
HREF="#CHFN"
>chfn</A
>&nbsp;--&nbsp;change user name and information</DT
><DT
><A
HREF="#CHSH"
>chsh</A
>&nbsp;--&nbsp;change login shell</DT
><DT
><A
HREF="#COL"
>col</A
>&nbsp;--&nbsp;filter reverse line feeds from input</DT
><DT
><A
HREF="#CPIO"
>cpio</A
>&nbsp;--&nbsp;copy file archives in and out</DT
><DT
><A
HREF="#CRONTAB"
>crontab</A
>&nbsp;--&nbsp;maintain crontab files for individual users</DT
><DT
><A
HREF="#CUT"
>cut</A
>&nbsp;--&nbsp;split a file into sections determined by context lines</DT
><DT
><A
HREF="#DF"
>df</A
>&nbsp;--&nbsp;report file system disk space usage</DT
><DT
><A
HREF="#DMESG"
>dmesg</A
>&nbsp;--&nbsp;print or control the system message buffer</DT
><DT
><A
HREF="#DU"
>du</A
>&nbsp;--&nbsp;estimate file space usage</DT
><DT
><A
HREF="#ECHO"
>echo</A
>&nbsp;--&nbsp;write arguments to standard output</DT
><DT
><A
HREF="#EGREP"
>egrep</A
>&nbsp;--&nbsp;search a file with an Extended Regular Expression pattern</DT
><DT
><A
HREF="#FGREP"
>fgrep</A
>&nbsp;--&nbsp;search a file with a fixed pattern</DT
><DT
><A
HREF="#FILE"
>file</A
>&nbsp;--&nbsp;determine file type</DT
><DT
><A
HREF="#FIND"
>find</A
>&nbsp;--&nbsp;search for files in a directory hierarchy</DT
><DT
><A
HREF="#FUSER"
>fuser</A
>&nbsp;--&nbsp;identify processes using files or sockets</DT
><DT
><A
HREF="#GETTEXT"
>gettext</A
>&nbsp;--&nbsp;retrieve text string from message catalog</DT
><DT
><A
HREF="#GREP"
>grep</A
>&nbsp;--&nbsp;print lines matching a pattern</DT
><DT
><A
HREF="#GROUPADD"
>groupadd</A
>&nbsp;--&nbsp;create a new group</DT
><DT
><A
HREF="#GROUPDEL"
>groupdel</A
>&nbsp;--&nbsp;delete a group</DT
><DT
><A
HREF="#GROUPMOD"
>groupmod</A
>&nbsp;--&nbsp;modify a group</DT
><DT
><A
HREF="#GROUPS"
>groups</A
>&nbsp;--&nbsp;display a group</DT
><DT
><A
HREF="#GUNZIP"
>gunzip</A
>&nbsp;--&nbsp;uncompress files</DT
><DT
><A
HREF="#GZIP"
>gzip</A
>&nbsp;--&nbsp;compress or expand files</DT
><DT
><A
HREF="#HOSTNAME"
>hostname</A
>&nbsp;--&nbsp;show or set the system's host name</DT
><DT
><A
HREF="#INSTALL"
>install</A
>&nbsp;--&nbsp;copy files and set attributes</DT
><DT
><A
HREF="#INSTALLINITD"
>install_initd</A
>&nbsp;--&nbsp;activate an init script</DT
><DT
><A
HREF="#IPCRM"
>ipcrm</A
>&nbsp;--&nbsp;remove IPC Resources</DT
><DT
><A
HREF="#IPCS"
>ipcs</A
>&nbsp;--&nbsp;provide information on ipc facilities</DT
><DT
><A
HREF="#KILLALL"
>killall</A
>&nbsp;--&nbsp;kill processes by name</DT
><DT
><A
HREF="#LPR"
>lpr</A
>&nbsp;--&nbsp;off line print</DT
><DT
><A
HREF="#LS"
>ls</A
>&nbsp;--&nbsp;list directory contents</DT
><DT
><A
HREF="#LSBRELEASE"
>lsb_release</A
>&nbsp;--&nbsp;print distribution specific information</DT
><DT
><A
HREF="#M4"
>m4</A
>&nbsp;--&nbsp;macro processor</DT
><DT
><A
HREF="#MD5SUM"
>md5sum</A
>&nbsp;--&nbsp;generate or check MD5 message digests</DT
><DT
><A
HREF="#MKNOD"
>mknod</A
>&nbsp;--&nbsp;make special files</DT
><DT
><A
HREF="#MKTEMP"
>mktemp</A
>&nbsp;--&nbsp;make temporary file name (unique)</DT
><DT
><A
HREF="#MORE"
>more</A
>&nbsp;--&nbsp;display files on a page-by-page basis</DT
><DT
><A
HREF="#MOUNT"
>mount</A
>&nbsp;--&nbsp;mount a file system </DT
><DT
><A
HREF="#MSGFMT"
>msgfmt</A
>&nbsp;--&nbsp;create a message object from a message file </DT
><DT
><A
HREF="#NEWGRP"
>newgrp</A
>&nbsp;--&nbsp;change group ID</DT
><DT
><A
HREF="#OD"
>od</A
>&nbsp;--&nbsp;dump files in octal and other formats </DT
><DT
><A
HREF="#PASSWD"
>passwd</A
>&nbsp;--&nbsp;change user password</DT
><DT
><A
HREF="#PATCH"
>patch</A
>&nbsp;--&nbsp;apply a diff file to an original</DT
><DT
><A
HREF="#PIDOF"
>pidof</A
>&nbsp;--&nbsp;find the process ID of a running program</DT
><DT
><A
HREF="#REMOVEINITD"
>remove_initd</A
>&nbsp;--&nbsp;clean up init script system modifications introduced by install_initd</DT
><DT
><A
HREF="#RENICE"
>renice</A
>&nbsp;--&nbsp;alter priority of running processes</DT
><DT
><A
HREF="#SED"
>sed</A
>&nbsp;--&nbsp;stream editor</DT
><DT
><A
HREF="#BASELIB-SENDMAIL-1"
>sendmail</A
>&nbsp;--&nbsp;an electronic mail transport agent</DT
><DT
><A
HREF="#SH"
>sh</A
>&nbsp;--&nbsp;shell, the standard command language interpreter</DT
><DT
><A
HREF="#SHUTDOWN"
>shutdown</A
>&nbsp;--&nbsp;shut the system down</DT
><DT
><A
HREF="#SU"
>su</A
>&nbsp;--&nbsp;change user ID</DT
><DT
><A
HREF="#SYNC"
>sync</A
>&nbsp;--&nbsp;flush file system buffers</DT
><DT
><A
HREF="#TAR"
>tar</A
>&nbsp;--&nbsp;file archiver</DT
><DT
><A
HREF="#UMOUNT"
>umount</A
>&nbsp;--&nbsp;unmount file systems</DT
><DT
><A
HREF="#USERADD"
>useradd</A
>&nbsp;--&nbsp;create a new user or update default new user information</DT
><DT
><A
HREF="#USERDEL"
>userdel</A
>&nbsp;--&nbsp;delete a user account and related files</DT
><DT
><A
HREF="#USERMOD"
>usermod</A
>&nbsp;--&nbsp;modify a user account</DT
><DT
><A
HREF="#XARGS"
>xargs</A
>&nbsp;--&nbsp;build and execute command lines from standard input</DT
></DL
></DIV
><P
>This section contains descriptions for commands and utilities whose
specified behavior in the LSB contradicts or extends the standards
referenced. It also contains commands and utilities only required by
the LSB and not specified by other standards.</P
><H1
><A
NAME="AR"
></A
>ar</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21777"
></A
><H2
>Name</H2
>ar&nbsp;--&nbsp;create and maintain library archives (DEPRECATED)</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21780"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>ar</B
> is deprecated from the LSB and is expected to
disappear from a future version of the LSB.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The LSB generally does not include software development utilities nor
does it specify .o and .a file formats.</P
></BLOCKQUOTE
></DIV
></P
><P
><B
CLASS="COMMAND"
>ar</B
> is as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21790"
></A
><H2
>Differences</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21793"
></A
><SPAN
STYLE="white-space: nowrap"
>-T</SPAN
>, <SPAN
STYLE="white-space: nowrap"
>-C</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be accepted.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21798"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21802"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior; using -r is suggested.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="AT"
></A
>at</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21809"
></A
><H2
>Name</H2
>at&nbsp;--&nbsp;examine or delete jobs for later execution</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21812"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>at</B
> is as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21817"
></A
><H2
>Differences</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN21819"
></A
><H3
>Options</H3
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21822"
></A
><SPAN
STYLE="white-space: nowrap"
>-d</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is functionally equivalent to the -r option specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21827"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be supported, but the '-d' option is equivalent.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21831"
></A
><SPAN
STYLE="white-space: nowrap"
>-t time</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be supported.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN21835"
></A
><H3
>Optional Control Files</H3
><P
>The implementation shall support the XSI optional behavior 
for access control; however the files 
<TT
CLASS="FILENAME"
>at.allow</TT
> and 
<TT
CLASS="FILENAME"
>at.deny</TT
> may reside in 
<TT
CLASS="FILENAME"
>/etc</TT
> rather than 
<TT
CLASS="FILENAME"
>/usr/lib/cron</TT
>.</P
></DIV
></DIV
><H1
><A
NAME="AWK"
></A
>awk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21845"
></A
><H2
>Name</H2
>awk&nbsp;--&nbsp;pattern scanning and processing language</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21848"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>awk</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21853"
></A
><H2
>Differences</H2
><P
>Certain aspects of internationalized regular expressions are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Internationalization and Regular Expressions</A
>.</P
></DIV
><H1
><A
NAME="BATCH"
></A
>batch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21860"
></A
><H2
>Name</H2
>batch&nbsp;--&nbsp;schedule commands to be executed in a batch queue</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21863"
></A
><H2
>Description</H2
><P
>The specification for <B
CLASS="COMMAND"
>batch</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN21868"
></A
><H3
>Optional Control Files</H3
><P
>The implementation shall support the XSI optional behavior 
for access control; however the files 
<TT
CLASS="FILENAME"
>at.allow</TT
> and 
<TT
CLASS="FILENAME"
>at.deny</TT
> may reside in 
<TT
CLASS="FILENAME"
>/etc</TT
> rather than 
<TT
CLASS="FILENAME"
>/usr/lib/cron</TT
>.</P
></DIV
></DIV
><H1
><A
NAME="BC"
></A
>bc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21878"
></A
><H2
>Name</H2
>bc&nbsp;--&nbsp;an arbitrary precision calculator language</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21881"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>bc</B
> is as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> but with
extensions as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21886"
></A
><H2
>Extensions</H2
><P
>The bc language may be extended in an implementation defined manner. If an
implementation supports extensions, it shall also support the additional
options:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21890"
></A
><SPAN
STYLE="white-space: nowrap"
>-s|--standard</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>processes exactly the POSIX <B
CLASS="COMMAND"
>bc</B
> language.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21895"
></A
><SPAN
STYLE="white-space: nowrap"
>-w|--warn</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>gives warnings for extensions to POSIX bc.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="CHFN"
></A
>chfn</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21902"
></A
><H2
>Name</H2
>chfn&nbsp;--&nbsp;change user name and information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21905"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>chfn</B
> [-f <TT
CLASS="REPLACEABLE"
><I
>full_name</I
></TT
>] [-h <TT
CLASS="REPLACEABLE"
><I
>home_phone</I
></TT
>] [user]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21913"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>chfn</B
> shall update the user database.
An unprivileged user may only change the fields for their own account, 
a user with appropriate privileges may change the fields for any account.</P
><P
>The fields <TT
CLASS="PARAMETER"
><I
>full_name</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>home_phone</I
></TT
> may contain any
character except:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>any control character</TD
></TR
><TR
><TD
>comma</TD
></TR
><TR
><TD
>colon</TD
></TR
><TR
><TD
>equal sign</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>If none of the options are selected, <B
CLASS="COMMAND"
>chfn</B
> operates 
in an interactive fashion. The prompts and expected input in interactive 
mode are unspecified and should not be relied upon.</P
><P
>As it is possible for the system to be configured to restrict which
fields a non-privileged user is permitted to change, applications
should be written to gracefully handle these situations.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21928"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21931"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-f <TT
CLASS="REPLACEABLE"
><I
>full_name</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's full name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21937"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-h <TT
CLASS="REPLACEABLE"
><I
>home_phone</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's home phone number.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21943"
></A
><H2
>Future Directions</H2
><P
>The following two options are expected to be added in a future
version of the LSB:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21947"
></A
><SPAN
STYLE="white-space: nowrap"
>-o office</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's office room number.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21951"
></A
><SPAN
STYLE="white-space: nowrap"
>-p office_phone</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's office phone number.</P
></TD
></TR
></TBODY
></TABLE
><P
>Note that some implementations contain a "-o other" option which
specifies an additional field called "other".  Traditionally, this
field is not subject to the constraints about legitimate characters in
fields.  Also, one traditionally shall have appropriate privileges to
change the other field.  At this point there is no consensus about
whether it is desirable to specify the other field; applications may
wish to avoid using it.</P
><P
>The "-w work_phone" field found in some implementations should be
replaced by the "-p office_phone" field.  The "-r room_number" field
found in some implementations is the equivalent of the "-o office"
option mentioned above; which one of these two options to specify will
depend on implementation experience and the decision regarding the
other field.</P
></DIV
><H1
><A
NAME="CHSH"
></A
>chsh</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21960"
></A
><H2
>Name</H2
>chsh&nbsp;--&nbsp;change login shell</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21963"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>chsh</B
> [-s <TT
CLASS="REPLACEABLE"
><I
>login_shell</I
></TT
>] [<TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
>]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21970"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>chsh</B
> changes the user login shell.  This determines 
the name of the
user's initial login command.  An unprivileged user may only change the login
shell for their own account, a user with appropriate privilege may change the login shell
for any account specified by <TT
CLASS="PARAMETER"
><I
>user</I
></TT
>.</P
><P
>Unless the user has appropriate privilege, the initial login command name 
shall be one of those listed in 
<TT
CLASS="FILENAME"
>/etc/shells</TT
>.
The <TT
CLASS="PARAMETER"
><I
>login_shell</I
></TT
> shall be the absolute path
(i.e. it must start with '<TT
CLASS="FILENAME"
>/</TT
>') to an executable file.
Accounts which are restricted (in an implementation-defined manner)
may not change their login shell.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
>
option is not selected, <B
CLASS="COMMAND"
>chsh</B
> operates in 
an interactive mode. The prompts and expected input in this mode are
unspecified.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21982"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21985"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-s <TT
CLASS="REPLACEABLE"
><I
>login_shell</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the login shell. </P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="COL"
></A
>col</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21994"
></A
><H2
>Name</H2
>col&nbsp;--&nbsp;filter reverse line feeds from input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21997"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>col</B
> is as specified in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
> but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22002"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="PARAMETER"
><I
>-p</I
></TT
> option has unspecified behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Although <B
CLASS="COMMAND"
>col</B
> is shown as legacy in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, it is
not (yet) deprecated in the LSB.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="CPIO"
></A
>cpio</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22013"
></A
><H2
>Name</H2
>cpio&nbsp;--&nbsp;copy file archives in and out</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22016"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>cpio</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22021"
></A
><H2
>Differences</H2
><P
>Some elements of the Pattern Matching Notation are optional;
see <A
HREF="#LOCALIZATION-GLOB"
>Internationalization and Pattern Matching Notation</A
>.</P
></DIV
><H1
><A
NAME="CRONTAB"
></A
>crontab</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22028"
></A
><H2
>Name</H2
>crontab&nbsp;--&nbsp;maintain crontab files for individual users</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22031"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>crontab</B
> [-u user]  file <BR><B
CLASS="COMMAND"
>crontab</B
> [-u user] {-l | -r | -e}</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22043"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>crontab</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22048"
></A
><H2
>Optional Control Files</H2
><P
>The implementation shall support the XSI optional behavior 
for access control; however the files 
<TT
CLASS="FILENAME"
>cron.allow</TT
> and 
<TT
CLASS="FILENAME"
>cron.deny</TT
> may reside in 
<TT
CLASS="FILENAME"
>/etc</TT
> rather than 
<TT
CLASS="FILENAME"
>/usr/lib/cron</TT
>.</P
></DIV
><H1
><A
NAME="CUT"
></A
>cut</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22058"
></A
><H2
>Name</H2
>cut&nbsp;--&nbsp;split a file into sections determined by context lines</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22061"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>cut</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22066"
></A
><H2
>Differences</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22069"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="DF"
></A
>df</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22076"
></A
><H2
>Name</H2
>df&nbsp;--&nbsp;report file system disk space usage</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22079"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>df</B
> command shall behave as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22084"
></A
><H2
>Differences</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN22086"
></A
><H3
>Options</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
> option is not specified, 
disk space is shown in unspecified
units.  If the <TT
CLASS="PARAMETER"
><I
>-P</I
></TT
> option is specified,
the size of the unit shall be printed on the header line in the format 
<TT
CLASS="LITERAL"
>"%4s-blocks"</TT
>.
Applications should specify <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
>.</P
><P
>The XSI option <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
> has unspecified behavior.
Applications should not specify <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The most common implementation of <B
CLASS="COMMAND"
>df</B
> uses
the <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
> option for a different purpose
(restricting output to a particular file system type), and
use of <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
> is therefore non-portable.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN22102"
></A
><H3
>Operand May Identify Special File</H3
><P
>If  an argument is the absolute file name of a special file
containing a mounted file system, <B
CLASS="COMMAND"
>df</B
>
shall show  the  space
available on that file system rather than on the file system
containing the special file (which  is  typically  the  root
file system).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> the XSI optional behavior permits
an operand to name a special file, but appears to require the
operation be performed on the file system containing the special file.
A defect report has been submitted for this case.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="DMESG"
></A
>dmesg</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22112"
></A
><H2
>Name</H2
>dmesg&nbsp;--&nbsp;print or control the system message buffer</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22115"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>dmesg</B
> [-c | -n <TT
CLASS="REPLACEABLE"
><I
>level</I
></TT
> | -s <TT
CLASS="REPLACEABLE"
><I
>bufsize</I
></TT
>]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22124"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>dmesg</B
> examines or controls the system message buffer.
Only a user with appropriate privileges may modify the system message
buffer parameters or contents.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22128"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22131"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-c</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the user has appropriate privilege,
clears the system message buffer contents after printing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22136"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-n level</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the user has appropriate privilege,
sets the level at which logging of messages is done to the console.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22141"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-s bufsize</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>uses a buffer of <TT
CLASS="PARAMETER"
><I
>bufsize</I
></TT
> to query the system message buffer.  This is 
<CODE
CLASS="CONSTANT"
>16392</CODE
> by default.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="DU"
></A
>du</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22151"
></A
><H2
>Name</H2
>du&nbsp;--&nbsp;estimate file space usage</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22154"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>du</B
> is as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22159"
></A
><H2
>Differences</H2
><P
>If the <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
> option is not specified, disk space is shown in unspecified
units.  Applications should specify <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
>.</P
></DIV
><H1
><A
NAME="ECHO"
></A
>echo</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22167"
></A
><H2
>Name</H2
>echo&nbsp;--&nbsp;write arguments to standard output</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22170"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>echo</B
> [string...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22174"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>echo</B
> command is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but
with the following differences.</P
><P
>Implementations may support implementation-defined options
to <B
CLASS="COMMAND"
>echo</B
>.
The behavior of
<B
CLASS="COMMAND"
>echo</B
> if any arguments contain backslashes is
also implementation defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22182"
></A
><H2
>Application Usage</H2
><P
>Conforming applications should not
run <B
CLASS="COMMAND"
>echo</B
> with a first argument starting with a hyphen,
or with any arguments containing backslashes; they should use
<B
CLASS="COMMAND"
>printf</B
> in those cases.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The behavior specified here is similar to that specified by 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> without the XSI option.  However, the LSB
strongly recommends conforming applications not use any options 
(even if the implementation provides them) while
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> specifies behavior if the first
operand is the string <TT
CLASS="PARAMETER"
><I
>-n</I
></TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="EGREP"
></A
>egrep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22195"
></A
><H2
>Name</H2
>egrep&nbsp;--&nbsp;search a file with an Extended Regular Expression pattern</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22198"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>egrep</B
> is equivalent to <B
CLASS="COMMAND"
>grep -E</B
>. For further details,
see the specification for <B
CLASS="COMMAND"
>grep</B
>.</P
></DIV
><H1
><A
NAME="FGREP"
></A
>fgrep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22207"
></A
><H2
>Name</H2
>fgrep&nbsp;--&nbsp;search a file with a fixed pattern</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22210"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>fgrep</B
> is equivalent to grep -F. For further details,
see the specification for <B
CLASS="COMMAND"
>grep</B
>.</P
></DIV
><H1
><A
NAME="FILE"
></A
>file</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22218"
></A
><H2
>Name</H2
>file&nbsp;--&nbsp;determine file type</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22221"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>file</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22226"
></A
><H2
>Differences</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>-M</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>-h</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>-d</I
></TT
>, and 
<TT
CLASS="PARAMETER"
><I
>-i</I
></TT
> options need not be supported.</P
></DIV
><H1
><A
NAME="FIND"
></A
>find</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22236"
></A
><H2
>Name</H2
>find&nbsp;--&nbsp;search for files in a directory hierarchy</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22239"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>find</B
> shall behave as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as
described below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22244"
></A
><H2
>Differences</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN22246"
></A
><H3
>Pattern Matching</H3
><P
>Some elements of the Pattern Matching Notation are optional;
see <A
HREF="#LOCALIZATION-GLOB"
>Internationalization and Pattern Matching Notation</A
>.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN22250"
></A
><H3
>Option and Operand Handling</H3
><P
>Options and operands to <B
CLASS="COMMAND"
>find</B
> shall behave
as described in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22256"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-H</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be supported</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22261"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-L</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be supported</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22266"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-exec ... +</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>argument aggregation need not be supported</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The <TT
CLASS="PARAMETER"
><I
>-H</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-L</I
></TT
> options are
not yet widely available in implementations of
the <B
CLASS="COMMAND"
>find</B
> command, nor is argument aggregation.
A future version of this specification will
require these features be supported.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="FUSER"
></A
>fuser</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22280"
></A
><H2
>Name</H2
>fuser&nbsp;--&nbsp;identify processes using files or sockets</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22283"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>fuser</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22288"
></A
><H2
>Differences</H2
><P
>The <B
CLASS="COMMAND"
>fuser</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN22293"
></A
><H3
>Option Differences</H3
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22296"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22300"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><H1
><A
NAME="GETTEXT"
></A
>gettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22307"
></A
><H2
>Name</H2
>gettext&nbsp;--&nbsp;retrieve text string from message catalog</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22310"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>gettext</B
> [options] [textdomain]  msgid <BR><B
CLASS="COMMAND"
>gettext</B
>  -s   [options]  msgid... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22321"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>gettext</B
> utility retrieves a translated 
text string corresponding to
string <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> from a message 
object generated with <B
CLASS="COMMAND"
>msgfmt</B
> utility.</P
><P
>The message object name is derived from the optional argument 
<TT
CLASS="PARAMETER"
><I
>textdomain</I
></TT
> if
present, otherwise from the <CODE
CLASS="CONSTANT"
>TEXTDOMAIN</CODE
> 
environment variable. If no domain is
specified, or if a corresponding string cannot be found, 
<B
CLASS="COMMAND"
>gettext</B
> prints
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>.</P
><P
>Ordinarily <B
CLASS="COMMAND"
>gettext</B
>
looks for its message object in 
<TT
CLASS="FILENAME"
><TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>lang</I
></TT
>/LC_MESSAGES</TT
>
where <TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
>
is the implementation-defined default directory and 
<TT
CLASS="REPLACEABLE"
><I
>lang</I
></TT
> is
the locale name. If present, the <CODE
CLASS="CONSTANT"
>TEXTDOMAINDIR</CODE
>
environment variable replaces
the <TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
>.</P
><P
>This utility interprets C escape sequences such as <TT
CLASS="LITERAL"
>\t</TT
>
for tab. Use <TT
CLASS="LITERAL"
>\\</TT
> to
print a backslash. To produce a message on a line of its own, either put a
<TT
CLASS="LITERAL"
>\n</TT
> at the end of 
<TT
CLASS="PARAMETER"
><I
>msgid,</I
></TT
> or use this command in
conjunction with the <B
CLASS="COMMAND"
>printf</B
>
utility.</P
><P
>When used with the <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
>
option the <B
CLASS="COMMAND"
>gettext</B
>
utility behaves like the <B
CLASS="COMMAND"
>echo</B
> utility, 
except that the message corresponding to 
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> in the selected catalog
provides the arguments.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22352"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22355"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-d domainname</I
></TT
></SPAN
>, <SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>--domain=domainname</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>PARAMETER translated messages from domainname.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22362"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-e</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Enable expansion of some escape sequences.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22367"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-n</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Suppress trailing newline.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22372"
></A
><H2
>Operands</H2
><P
>The following operands are supported:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22376"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>textdomain</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A domain name used to retrieve the messages.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22381"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A key to retrieve the localized message.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22386"
></A
><H2
>Environment Variables</H2
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22390"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LANGUAGE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies one or more locale names. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22395"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>LANG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies locale name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22400"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>LC_MESSAGES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies messaging locale, and if present overrides <CODE
CLASS="CONSTANT"
>LANG</CODE
> for messages.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22406"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>TEXTDOMAIN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies the text domain name, which is identical to the message object
filename without <TT
CLASS="FILENAME"
>.mo</TT
> suffix.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22412"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>TEXTDOMAINDIR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies the pathname to the message catalog, and if present replaces the
implementation-defined default directory.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22417"
></A
><H2
>Exit Status</H2
><P
>The following exit values are returned:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22421"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Successful completion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22426"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>&#62;0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="GREP"
></A
>grep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22434"
></A
><H2
>Name</H2
>grep&nbsp;--&nbsp;print lines matching a pattern</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22437"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>grep</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22442"
></A
><H2
>LSB Differences</H2
><P
>Certain aspects of regular expression matching are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Internationalization and Regular Expressions</A
>.</P
></DIV
><H1
><A
NAME="GROUPADD"
></A
>groupadd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22449"
></A
><H2
>Name</H2
>groupadd&nbsp;--&nbsp;create a new group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22452"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groupadd</B
> [-g gid  [-o]]  group </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22458"
></A
><H2
>Description</H2
><P
>If the caller has appropriate privilege, the 
<B
CLASS="COMMAND"
>groupadd</B
> command shall create a new
group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
>.  
The group name shall be unique in the group database. If no
<TT
CLASS="PARAMETER"
><I
>gid</I
></TT
> is specified, 
<B
CLASS="COMMAND"
>groupadd</B
> shall create the new group with a unique group ID.</P
><P
>The <B
CLASS="COMMAND"
>groupadd</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22468"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22471"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-g <TT
CLASS="REPLACEABLE"
><I
>gid</I
></TT
> [-o]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The new group shall have group ID <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
>.
If the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is not used, no other
group shall have this group ID.
The value of <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
> shall be non-negative.  </P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="GROUPDEL"
></A
>groupdel</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22483"
></A
><H2
>Name</H2
>groupdel&nbsp;--&nbsp;delete a group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22486"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groupdel</B
>  group </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22490"
></A
><H2
>Description</H2
><P
>If the caller has sufficient privilege,
the <B
CLASS="COMMAND"
>groupdel</B
> command shall modify the system group database,
deleting the 
group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
>.  
If the group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> does not exist,
<B
CLASS="COMMAND"
>groupdel</B
> shall issue a diagnostic message and exit
with a non-zero exit status.</P
><P
>The <B
CLASS="COMMAND"
>groupdel</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><H1
><A
NAME="GROUPMOD"
></A
>groupmod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22503"
></A
><H2
>Name</H2
>groupmod&nbsp;--&nbsp;modify a group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22506"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groupmod</B
> [-g <TT
CLASS="REPLACEABLE"
><I
>gid</I
></TT
> [-o]] [-n <TT
CLASS="REPLACEABLE"
><I
>group_name</I
></TT
>]  group </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22515"
></A
><H2
>Description</H2
><P
>If the caller has appropriate privilege, the 
<B
CLASS="COMMAND"
>groupmod</B
> command shall modify the entry in the system
group database corresponding to a group named 
<TT
CLASS="PARAMETER"
><I
>group</I
></TT
>.</P
><P
>The <B
CLASS="COMMAND"
>groupmod</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22523"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22526"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-g <TT
CLASS="REPLACEABLE"
><I
>gid</I
></TT
> [-o]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Modify the group's group ID, setting it to <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
>.
If the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is not used, no other
group shall have this group ID.
The value of <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
>shall be non-negative.  
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Only the group ID in the database is altered; any files with group
ownership set to the original group ID are unchanged by this modification.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22537"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-n <TT
CLASS="REPLACEABLE"
><I
>group_name</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>changes the name of the group from <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> to 
<TT
CLASS="PARAMETER"
><I
>group_name</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="GROUPS"
></A
>groups</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22548"
></A
><H2
>Name</H2
>groups&nbsp;--&nbsp;display a group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22551"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groups</B
> [user]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22555"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>groups</B
> command shall behave as <B
CLASS="COMMAND"
>id -Gn
<TT
CLASS="REPLACEABLE"
><I
>[user]</I
></TT
></B
>, as specified in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
The optional <TT
CLASS="PARAMETER"
><I
>user</I
></TT
> parameter
will display the groups for the named user.</P
></DIV
><H1
><A
NAME="GUNZIP"
></A
>gunzip</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22568"
></A
><H2
>Name</H2
>gunzip&nbsp;--&nbsp;uncompress files</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22571"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>gunzip</B
> is equivalent to 
<B
CLASS="COMMAND"
>gzip -d</B
>. See the specification for
<B
CLASS="COMMAND"
>gzip</B
> for further details.</P
></DIV
><H1
><A
NAME="GZIP"
></A
>gzip</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22580"
></A
><H2
>Name</H2
>gzip&nbsp;--&nbsp;compress or expand files</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22583"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>gzip</B
> [-cdfhlLnNrtvV19] [-S suffix] [name...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22589"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>gzip</B
> command shall attempt to reduce the size of 
the named files.
Whenever possible, each file is replaced by one with the
extension <TT
CLASS="FILENAME"
>.gz</TT
>,
while keeping the same ownership, modes, access and
modification times. If no files are specified, or if a file name is
<TT
CLASS="FILENAME"
>-</TT
>, 
the standard input is compressed to the standard output. 
<B
CLASS="COMMAND"
>gzip</B
>
shall only attempt to compress regular files.  In particular, it will
ignore symbolic links.</P
><P
>When compressing, gzip uses the deflate algorithm specified in 
<A
HREF="#STD.RFC1951"
>RFC 1951: DEFLATE Compressed Data Format Specification</A
>
and stores the result in a file using the gzip file format specified
in <A
HREF="#STD.RFC1952"
>RFC 1952: GZIP File Format Specification</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22599"
></A
><H2
>Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-c, --stdout, --to-stdout</DT
><DD
><P
>writes output on standard output, leaving the original files unchanged.  If
there are several input files, the output consists of a sequence of
independently compressed members. To obtain better compression,
concatenate all input files before compressing them.</P
></DD
><DT
>-d, --decompress, --uncompress</DT
><DD
><P
>the name operands are compressed files, and <B
CLASS="COMMAND"
>gzip</B
>
shall decompress them.</P
></DD
><DT
>-f, --force</DT
><DD
><P
>forces compression or decompression even if the file has multiple links
or the corresponding file already exists, or if the compressed data is
read from or written to a terminal. If the input data is not in a
format recognized by <B
CLASS="COMMAND"
>gzip</B
>, and if the option 
<TT
CLASS="PARAMETER"
><I
>--stdout</I
></TT
>
is also given, copy the input data without change to the standard ouput: 
let <B
CLASS="COMMAND"
>gzip</B
> behave as <B
CLASS="COMMAND"
>cat</B
>. If <TT
CLASS="PARAMETER"
><I
>-f</I
></TT
> is 
not given, and when not running in the background, <B
CLASS="COMMAND"
>gzip</B
> 
prompts to verify whether an existing file should be overwritten.</P
></DD
><DT
>-l, --list</DT
><DD
><P
>lists the compressed size, uncompressed size, ratio and uncompressed 
name for each compressed file. For files that are not in <B
CLASS="COMMAND"
>gzip</B
>
format, the uncompressed size shall be given as 
<CODE
CLASS="CONSTANT"
>-1</CODE
>.
If the <TT
CLASS="PARAMETER"
><I
>--verbose</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-v</I
></TT
> option
is also specified, the
crc and timestamp for the uncompressed file shall also be displayed.</P
><P
>For decompression, <B
CLASS="COMMAND"
>gzip</B
> shall support at least
the following compression methods:
<P
></P
><UL
><LI
><P
>deflate (<A
HREF="#STD.RFC1951"
>RFC 1951: DEFLATE Compressed Data Format Specification</A
>)</P
></LI
><LI
><P
>compress (<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>)</P
></LI
></UL
>
The crc shall be given as 
<CODE
CLASS="CONSTANT"
>ffffffff</CODE
> for a file
not in <B
CLASS="COMMAND"
>gzip</B
> format.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>--name</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-N</I
></TT
> option
is also specified, the uncompressed name, date and time are those stored
within the compressed file, if present.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>--quiet</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-q</I
></TT
> option
is also specified, the 
title and totals lines are not displayed.</P
></DD
><DT
>-L, --license</DT
><DD
><P
>displays the <B
CLASS="COMMAND"
>gzip</B
> license and quit.</P
></DD
><DT
>-n, --no-name</DT
><DD
><P
>does not save the original file name and time stamp by default when 
compressing. (The original name is always saved if the name had to be
truncated.)  When decompressing, do not restore the original file name
if present (remove only the gzip suffix from the compressed file name)
and do not restore the original time stamp if present (copy it from
the compressed file). This option is the default when decompressing.</P
></DD
><DT
>-N, --name</DT
><DD
><P
>always saves the original file name and time stamp when compressing;
this is the default.  When decompressing, restore the original file
name and time stamp if present. This option is useful on systems which
have a limit on file name length or when the time stamp has been lost
after a file transfer.</P
></DD
><DT
>-q, --quiet</DT
><DD
><P
>suppresses all warnings.</P
></DD
><DT
>-r, --recursive</DT
><DD
><P
>travels the directory structure recursively. If any of the file names
specified on the command line are directories, <B
CLASS="COMMAND"
>gzip</B
> 
will descend into the directory and compress all the files it finds there 
(or decompress them in the case of <B
CLASS="COMMAND"
>gunzip</B
>).</P
></DD
><DT
>-S .suf, --sufix .suf</DT
><DD
><P
>uses suffix <TT
CLASS="FILENAME"
>.suf</TT
> instead of <TT
CLASS="FILENAME"
>.gz</TT
>.</P
></DD
><DT
>-t, --test</DT
><DD
><P
>checks the compressed file integrity.</P
></DD
><DT
>-v, --verbose</DT
><DD
><P
>displays the name and percentage reduction for each file
compressed or decompressed.</P
></DD
><DT
>-#, --fast, --best</DT
><DD
><P
>regulates the speed of compression using the specified digit #, where
<TT
CLASS="PARAMETER"
><I
>-1</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--fast</I
></TT
> indicates the fastest compression method (less
compression) and <TT
CLASS="PARAMETER"
><I
>-9</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--best</I
></TT
> indicates the slowest compression method
(best compression).  The default compression level is <TT
CLASS="PARAMETER"
><I
>-6</I
></TT
>
(that is,
biased towards high compression at expense of speed).</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22692"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22696"
></A
><SPAN
STYLE="white-space: nowrap"
>-V, --version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays the version number and compilation options, then quits.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="HOSTNAME"
></A
>hostname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22703"
></A
><H2
>Name</H2
>hostname&nbsp;--&nbsp;show or set the system's host name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22706"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>hostname</B
> [name]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22710"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>hostname</B
> is used to either display or, with appropriate
privileges, set the current host
name of the system.  The host name is used by many applications
to identify the machine. </P
><P
>When called without any arguments, the program displays the name of
the system as returned by the <TT
CLASS="FUNCTION"
>gethostname()</TT
> function.</P
><P
>When called with a <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> argument, and the user has appropriate
privilege, the command
sets the host name.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is not specified if the hostname displayed will be a fully qualified
domain name. Applications requiring a particular format of hostname
should check the output and take appropriate action.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="INSTALL"
></A
>install</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22723"
></A
><H2
>Name</H2
>install&nbsp;--&nbsp;copy files and set attributes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22726"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>install</B
> [option...]  SOURCE   DEST <BR><B
CLASS="COMMAND"
>install</B
> [option...]  SOURCE...   DEST <BR><B
CLASS="COMMAND"
>install</B
> [-d | --directory] [option...]  DIRECTORY... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22744"
></A
><H2
>Description</H2
><P
>In the first two formats, copy <TT
CLASS="PARAMETER"
><I
>SOURCE</I
></TT
>
to <TT
CLASS="PARAMETER"
><I
>DEST</I
></TT
> or multiple <TT
CLASS="PARAMETER"
><I
>SOURCE(s)</I
></TT
> to
the existing <TT
CLASS="PARAMETER"
><I
>DEST</I
></TT
> directory, optionally setting permission modes and
file ownership.  In the third format, each
<TT
CLASS="PARAMETER"
><I
>DIRECTORY</I
></TT
> and any missing parent
directories shall be created.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22752"
></A
><H2
>Standard Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>--backup[=METHOD]</DT
><DD
><P
>makes a backup of each existing destination file.
<TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> may be one of the following:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22761"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>none</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>off</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>never make backups.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22767"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>numbered</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>t</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>make numbered backups. A numbered backup has the form
<TT
CLASS="LITERAL"
>"%s.~%d~", target_name, version_number</TT
>. Each backup
shall increment the version number by 1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22774"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>existing</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>nil</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>behave as numbered if numbered backups exist, or simple otherwise.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22780"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>simple</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>never</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>append a suffix to the name. The default suffix is '<TT
CLASS="LITERAL"
>~</TT
>',
but can be overriden by setting <CODE
CLASS="ENVAR"
>SIMPLE_BACKUP_SUFFIX</CODE
> in
the environment, or via the <TT
CLASS="PARAMETER"
><I
>-S</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--suffix</I
></TT
>
option.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If no <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> is specified, the environment variable
<CODE
CLASS="ENVAR"
>VERSION_CONTROL</CODE
> shall be examined for one of the above.
Unambiguous abbreviations of <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> shall be accepted.
If no <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> is specified, or if <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
>
is empty, the backup method shall default to <CODE
CLASS="CONSTANT"
>existing</CODE
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> is invalid or ambiguous, <B
CLASS="COMMAND"
>install</B
>
shall fail and issue a diagnostic message.</P
></DD
><DT
>-b</DT
><DD
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>--backup=existing</I
></TT
>.</P
></DD
><DT
>-d, --directory</DT
><DD
><P
>treats all arguments as directory names; creates all components of the
specified directories.</P
></DD
><DT
>-D</DT
><DD
><P
>creates all leading components of DEST except the last, then copies
SOURCE to DEST; useful in the 1st format.</P
></DD
><DT
>-g GROUP, --group=GROUP</DT
><DD
><P
>if the user has appropriate privilege, sets group ownership, instead of process' current group.
<TT
CLASS="PARAMETER"
><I
>GROUP</I
></TT
> is either a name in the
user group database, or a positive integer, which shall be used as a group-id.</P
></DD
><DT
>-m MODE, --mode=MODE</DT
><DD
><P
>sets permission mode (specified as in <B
CLASS="COMMAND"
>chmod</B
>), instead of the default 
<TT
CLASS="LITERAL"
>rwxr-xr-x</TT
>.</P
></DD
><DT
>-o OWNER, --owner=OWNER</DT
><DD
><P
>if the user has appropriate privilege, sets ownership.
<TT
CLASS="PARAMETER"
><I
>OWNER</I
></TT
> is either a name in the
user login database, or a positive integer, which shall be used as a user-id.</P
></DD
><DT
>-p, --preserve-timestamps</DT
><DD
><P
>copies the access and modification times of 
<TT
CLASS="PARAMETER"
><I
>SOURCE</I
></TT
> files to corresponding
destination files.</P
></DD
><DT
>-s, --strip</DT
><DD
><P
>strips symbol tables, only for 1st and 2nd formats.</P
></DD
><DT
>-S SUFFIX, --suffix=SUFFIX</DT
><DD
><P
>equivalent to <TT
CLASS="PARAMETER"
><I
>--backup=existing</I
></TT
>, except if
a simple suffix is required, use <TT
CLASS="PARAMETER"
><I
>SUFFIX</I
></TT
>.</P
></DD
><DT
>--verbose</DT
><DD
><P
>prints the name of each directory as it is created.</P
></DD
><DT
>-v, --verbose</DT
><DD
><P
>print the name of each file before copying it to <CODE
CLASS="VARNAME"
>stdout</CODE
>.</P
></DD
></DL
></DIV
></DIV
><H1
><A
NAME="INSTALLINITD"
></A
>install_initd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22856"
></A
><H2
>Name</H2
>install_initd&nbsp;--&nbsp;activate an init script</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22859"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/lib/lsb/install_initd</B
>  initd_file </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22863"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>install_initd</B
> shall activate a system initialization file that has
been copied to an implementation defined location such that
this file shall be run at the appropriate point during system initialization.
The <B
CLASS="COMMAND"
>install_initd</B
> command is typically called in the postinstall
script of a package, after the script has been copied to
<TT
CLASS="FILENAME"
>/etc/init.d</TT
>.
See also <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
>.</P
></DIV
><H1
><A
NAME="IPCRM"
></A
>ipcrm</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22873"
></A
><H2
>Name</H2
>ipcrm&nbsp;--&nbsp;remove IPC Resources</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22876"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>ipcrm</B
> [-q <TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
> | -Q <TT
CLASS="REPLACEABLE"
><I
>msgkey</I
></TT
> | -s <TT
CLASS="REPLACEABLE"
><I
>semid</I
></TT
> | -S <TT
CLASS="REPLACEABLE"
><I
>semkey</I
></TT
> | -m <TT
CLASS="REPLACEABLE"
><I
>shmid</I
></TT
> | -M <TT
CLASS="REPLACEABLE"
><I
>shmkey</I
></TT
>]...<BR><B
CLASS="COMMAND"
>ipcrm</B
> [shm | msg | msg]  id... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22899"
></A
><H2
>Description</H2
><P
>If any of the 
<TT
CLASS="PARAMETER"
><I
>-q</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-Q</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-S</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>or -M</I
></TT
>
arguments are given, the <B
CLASS="COMMAND"
>ipcrm</B
> shall
behave as described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
><P
>Otherwise,
<B
CLASS="COMMAND"
>ipcrm</B
> shall remove the resource of
the specified type identified by <TT
CLASS="PARAMETER"
><I
>id</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22920"
></A
><H2
>Future Directions</H2
><P
>A future revision of this specification may deprecate the second synopsis form.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>In  its  first  Linux  implementation, <B
CLASS="COMMAND"
>ipcrm</B
> used the second syntax
shown in the SYNOPSIS.  Functionality present in other implementations
of  <B
CLASS="COMMAND"
>ipcrm</B
>  has  since  been  added, namely the ability to delete
resources by key (not just identifier), and to respect  the  same  command
line  syntax.  The previous syntax is
still supported for backwards compatibility only.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="IPCS"
></A
>ipcs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22931"
></A
><H2
>Name</H2
>ipcs&nbsp;--&nbsp;provide information on ipc facilities</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22934"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>ipcs</B
> [-smq] [-tcp]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22939"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>ipcs</B
> provides information on the ipc facilities 
for which the calling process has read access. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Although this command
has many similarities with the optional <B
CLASS="COMMAND"
>ipcs</B
> 
utility described in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, it has substantial differences and is
therefore described separately. The options specified here have similar
meaning to those in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>; other options specified
there have unspecified behavior on an LSB conforming implementation. See
<A
HREF="#IPCS.APP.USAGE"
>Application Usage</A
> below. The output format is not specified.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22949"
></A
><H2
>Resource display options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22952"
></A
><SPAN
STYLE="white-space: nowrap"
>-m</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>shared memory segments.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22956"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>message queues.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22960"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>semaphore arrays.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22964"
></A
><H2
>Output format options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22967"
></A
><SPAN
STYLE="white-space: nowrap"
>-t</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22971"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN22975"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creator.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="IPCS.APP.USAGE"
></A
><H2
>Application Usage</H2
><P
>In some implementations of ipcs the <TT
CLASS="PARAMETER"
><I
>-a</I
></TT
>
option will print all
information available.  In other implementations the 
<TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option will
print all resource types.  Therefore, applications shall not use the 
<TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option.</P
><P
>Some implementations of <B
CLASS="COMMAND"
>ipcs</B
>
provide more output formats than are
specified here.  These options are not consistent between differing
implementations of <B
CLASS="COMMAND"
>ipcs</B
>.
Therefore, only the 
<TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-p</I
></TT
> option
formatting flags may be used.  At least one of the 
<TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-p</I
></TT
> options
and at least one of 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-q</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> options
shall be specified. If no options are specified, the output is unspecified.</P
></DIV
><H1
><A
NAME="KILLALL"
></A
>killall</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23000"
></A
><H2
>Name</H2
>killall&nbsp;--&nbsp;kill processes by name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23003"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>killall</B
> [-egiqvw] [-signal]  name... <BR><B
CLASS="COMMAND"
>killall</B
>  -l <BR><B
CLASS="COMMAND"
>killall</B
>  -V </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23015"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>killall</B
> sends a signal to all processes running any of 
the specified commands.  If no signal name is specified, <CODE
CLASS="CONSTANT"
>SIGTERM</CODE
> is sent.</P
><P
>Signals can be specified either by name (e.g. <CODE
CLASS="CONSTANT"
>-HUP</CODE
>) or by number
(e.g. <CODE
CLASS="CONSTANT"
>-1</CODE
>). Signal <CODE
CLASS="CONSTANT"
>0</CODE
>
(check if a process exists) can only be specified
by number.</P
><P
>If the command name contains a slash (/), processes executing that
particular file will be selected for killing, independent of their
name.</P
><P
><B
CLASS="COMMAND"
>killall</B
> returns a non-zero return code if no process 
has been killed for any of the listed commands.  If at least one process 
has been killed for each command, <B
CLASS="COMMAND"
>killall</B
> returns zero.</P
><P
>A <B
CLASS="COMMAND"
>killall</B
> process never kills itself (but may kill 
other <B
CLASS="COMMAND"
>killall</B
> processes).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23031"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23034"
></A
><SPAN
STYLE="white-space: nowrap"
>-e</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>requires an exact match for very long names. If a command name is
longer than 15 characters, the full name may be unavailable (i.e. it
is swapped out).  In this case, <B
CLASS="COMMAND"
>killall</B
> will kill 
everything that matches within the first 15 characters. With -e, such 
entries are skipped.  <B
CLASS="COMMAND"
>killall</B
> prints a message for 
each skipped entry if -v is specified in addition to -e.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23040"
></A
><SPAN
STYLE="white-space: nowrap"
>-g</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>kills the process group to which the process belongs.  The kill signal
is only sent once per group, even if multiple processes belonging to
the same process group were found.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23044"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>asks interactively for confirmation before killing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23048"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>lists all known signal names.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23052"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>does not complain if no processes were killed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23056"
></A
><SPAN
STYLE="white-space: nowrap"
>-v</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reports if the signal was successfully sent.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23060"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23064"
></A
><SPAN
STYLE="white-space: nowrap"
>-V</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays version information.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LPR"
></A
>lpr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23071"
></A
><H2
>Name</H2
>lpr&nbsp;--&nbsp;off line print</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23074"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>lpr</B
> [-l] [-p] [-Pprinter] [-h] [-s] [-#copies] [-J name] [-T title] [name ......]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23086"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>lpr</B
> uses a spooling daemon to print the named files when 
facilities become available.  If no names appear, the standard input is
assumed.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23090"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23093"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>identifies binary data that is not to be filtered but sent as raw input 
to printer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23097"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>formats with "pr" before sending to printer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23101"
></A
><SPAN
STYLE="white-space: nowrap"
>-Pprinter</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sends output to the printer named printer instead of the default
printer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23105"
></A
><SPAN
STYLE="white-space: nowrap"
>-h</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>suppresses header page.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23109"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>uses symbolic links.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23113"
></A
><SPAN
STYLE="white-space: nowrap"
>-#copies</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies copies as the number of copies to print.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23117"
></A
><SPAN
STYLE="white-space: nowrap"
>-J name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies name as the job name for the header page.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23121"
></A
><SPAN
STYLE="white-space: nowrap"
>-T title</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies title as the title used for "pr".</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LS"
></A
>ls</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23128"
></A
><H2
>Name</H2
>ls&nbsp;--&nbsp;list directory contents</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23131"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>ls</B
> shall behave as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
extensions listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23136"
></A
><H2
>Extensions</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23139"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file is a character special or block special file, 
the size of the file shall be replaced with 
two unsigned numbers in the format <TT
CLASS="LITERAL"
>"%u,  %u"</TT
>,
representing the major and minor device numbers associated with the
special file. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not specify the meaning of the major and minor
devices numbers.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23146"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>in addition to <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> XSI optional behavior of printing a
slash for a directory,
<B
CLASS="COMMAND"
>ls -p</B
> may display other characters for other file types.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LSBRELEASE"
></A
>lsb_release</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23155"
></A
><H2
>Name</H2
>lsb_release&nbsp;--&nbsp;print distribution specific information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23158"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>lsb_release</B
> [OPTION...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23162"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>lsb_release</B
> command prints certain LSB (Linux Standard
Base) and Distribution information.</P
><P
>If no options are given, the <TT
CLASS="PARAMETER"
><I
>-v</I
></TT
> option is assumed.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23168"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23171"
></A
><SPAN
STYLE="white-space: nowrap"
>-v, --version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays version of LSB against which distribution is compliant. The version
is expressed as a colon separated list of LSB module descriptions. LSB module
descriptions are dash separated tuples containing the module name, version,
and architecture name.
The output is a single line of text of the following format:</P
><P
><TT
CLASS="LITERAL"
>LSB Version:\t<TT
CLASS="REPLACEABLE"
><I
>ListAsDescribedAbove</I
></TT
></TT
></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>An implementation may support multiple releases of the same module.
Version specific library interfaces, if any, will be selected by the program interpreter,
which changes from release to release. Version specific commands and utilities, if any,
will be described in the relevant specification.</P
></BLOCKQUOTE
></DIV
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23180"
></A
><SPAN
STYLE="white-space: nowrap"
>-i, --id</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays string id of distributor.
The output is a single line of text of the following format:</P
><P
><TT
CLASS="LITERAL"
>Distributor ID:\t<TT
CLASS="REPLACEABLE"
><I
>DistributorID</I
></TT
></TT
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23187"
></A
><SPAN
STYLE="white-space: nowrap"
>-d, --description</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays single line text description of distribution.
The output is of the following format:</P
><P
><TT
CLASS="LITERAL"
>Description:\t<TT
CLASS="REPLACEABLE"
><I
>Description</I
></TT
></TT
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23194"
></A
><SPAN
STYLE="white-space: nowrap"
>-r, --release</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays release number of distribution.
The output is a single line of text of the following format:</P
><P
><TT
CLASS="LITERAL"
>Release:\t<TT
CLASS="REPLACEABLE"
><I
>Release</I
></TT
></TT
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23201"
></A
><SPAN
STYLE="white-space: nowrap"
>-c, --codename</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays codename according to distribution release.
The output is a single line of text of the following format.</P
><P
><TT
CLASS="LITERAL"
>Codename:\t<TT
CLASS="REPLACEABLE"
><I
>Codename</I
></TT
></TT
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23208"
></A
><SPAN
STYLE="white-space: nowrap"
>-a, --all</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays all of the above information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23212"
></A
><SPAN
STYLE="white-space: nowrap"
>-s, --short</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays all of the above information in short output format.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23216"
></A
><SPAN
STYLE="white-space: nowrap"
>-h, --help</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays a human-readable help message.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23220"
></A
><H2
>Examples</H2
><P
>The following command will list the LSB Profiles which are currently supported
on this platform.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% lsb_release -v
LSB Version: core-3.1-ia32:core-3.1-noarch:graphics-3.1-ia32:graphics-3.1-noarch</PRE
></TD
></TR
></TABLE
></DIV
><H1
><A
NAME="M4"
></A
>m4</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23227"
></A
><H2
>Name</H2
>m4&nbsp;--&nbsp;macro processor</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23230"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>m4</B
> is as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
extensions as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23235"
></A
><H2
>Extensions</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23238"
></A
><SPAN
STYLE="white-space: nowrap"
>-P</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>forces all builtins to be prefixed with <TT
CLASS="LITERAL"
>m4_</TT
>. For example,
<TT
CLASS="LITERAL"
>define</TT
> becomes <TT
CLASS="LITERAL"
>m4_define</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23245"
></A
><SPAN
STYLE="white-space: nowrap"
>-I <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Add <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
> to the end of the search path
for includes.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="MD5SUM"
></A
>md5sum</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23254"
></A
><H2
>Name</H2
>md5sum&nbsp;--&nbsp;generate or check MD5 message digests</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23257"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>md5sum</B
> [-c  [file] | file...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23264"
></A
><H2
>Description</H2
><P
>For each file, write to standard output a line containing the MD5
message digest of that file, followed by one or more blank characters,
followed by the name of the file.  The MD5 message digest shall be
calculated according to <A
HREF="#STD.RFC1321"
>RFC 1321: The MD5 Message-Digest Algorithm</A
> and output as 32 hexadecimal digits.</P
><P
>If no file names are specified as operands, read from standard input
and use <TT
CLASS="LITERAL"
>"-"</TT
> as the file name in the output.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23270"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23273"
></A
><SPAN
STYLE="white-space: nowrap"
>-c [file]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>checks the MD5 message digest of all files named in <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
against the message digest listed
in the same file. The actual format of <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
is the same as the output
of <B
CLASS="COMMAND"
>md5sum</B
>.  That is, each line in the file describes a file. 
If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
is not specified, read 
message digests from <CODE
CLASS="VARNAME"
>stdin</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23282"
></A
><H2
>Exit Status</H2
><P
><B
CLASS="COMMAND"
>md5sum</B
> shall exit with status <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>
if the sum was generated successfully, or, in check mode, if the check
matched. Otherwise, <B
CLASS="COMMAND"
>md5sum</B
> shall exit with a non-zero
status.</P
></DIV
><H1
><A
NAME="MKNOD"
></A
>mknod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23291"
></A
><H2
>Name</H2
>mknod&nbsp;--&nbsp;make special files</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23294"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>mknod</B
> [-m <TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
> | --mode=<TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>]  name   type  [major minor]<BR><B
CLASS="COMMAND"
>mknod</B
> [--version]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23308"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>mknod</B
> command shall create a special file named
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
> of the given <TT
CLASS="PARAMETER"
><I
>type</I
></TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> shall be one of the following:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23317"
></A
><SPAN
STYLE="white-space: nowrap"
>b</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a block (buffered) special file with the specified
<TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
> device numbers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23323"
></A
><SPAN
STYLE="white-space: nowrap"
>c, u</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a character (unbuffered) special file with the specified
<TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
> device numbers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23329"
></A
><SPAN
STYLE="white-space: nowrap"
>p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a FIFO.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23333"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23336"
></A
><SPAN
STYLE="white-space: nowrap"
>-m <TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>, --mode=<TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>create the special file with file access permissions set as described in
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>. The permissions may be any absolute value (i.e.
one not containing <TT
CLASS="LITERAL"
>'+'</TT
> or <TT
CLASS="LITERAL"
>'-'</TT
>) acceptable to the
<B
CLASS="COMMAND"
>chmod</B
> command.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23346"
></A
><SPAN
STYLE="white-space: nowrap"
>--version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>output version information and exit.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This option may be deprecated in a future release of this specification.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
></TBODY
></TABLE
><P
>If <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> is <TT
CLASS="LITERAL"
>p</TT
>,
<TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
>
shall not be specified. Otherwise, these parameters are mandatory.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23357"
></A
><H2
>Future Directions</H2
><P
>This command may be deprecated in a future version of this specification.
The <TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
> operands
are insufficently portable to be specified usefully here.
Only a FIFO can be portably created by this command, and the <B
CLASS="COMMAND"
>mkfifo</B
>
command is a simpler interface for that purpose.</P
></DIV
><H1
><A
NAME="MKTEMP"
></A
>mktemp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23366"
></A
><H2
>Name</H2
>mktemp&nbsp;--&nbsp;make temporary file name (unique)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23369"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>mktemp</B
> [-q] [-u]  template </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23375"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>mktemp</B
> command takes the given file name 
<TT
CLASS="PARAMETER"
><I
>template</I
></TT
> and 
overwrites a
portion of it to create a file name.  This file name shall be unique and
suitable for use by the application.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>template</I
></TT
> should have at least six trailing
<TT
CLASS="LITERAL"
>'X'</TT
>
characters. These characters are replaced with characters from the portable
filename character set in order to
generate a unique name.</P
><P
>If <B
CLASS="COMMAND"
>mktemp</B
> can successfully generate a unique file name, 
and the <TT
CLASS="PARAMETER"
><I
>-u</I
></TT
> option is not present,
the file shall be created with read and write permission only for the current user.
The <B
CLASS="COMMAND"
>mktemp</B
> command shall write
the filename generated to the standard output.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23387"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23390"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>fail silently if an error occurs.  Diagnostic messages to <CODE
CLASS="VARNAME"
>stderr</CODE
>
are suppressed, but the command shall still exit with a non-zero exit status
if an error occurs.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23395"
></A
><SPAN
STYLE="white-space: nowrap"
>-u</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>operates in `unsafe' mode.  A unique name is generated,
but the temporary file shall be unlinked before
<B
CLASS="COMMAND"
>mktemp</B
> exits.  
Use of this option is not encouraged.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="MORE"
></A
>more</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23403"
></A
><H2
>Name</H2
>more&nbsp;--&nbsp;display files on a page-by-page basis</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23406"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>more</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23411"
></A
><H2
>Differences</H2
><P
>The <B
CLASS="COMMAND"
>more</B
> command need not respect the 
<TT
CLASS="LITERAL"
>LINES</TT
> and <TT
CLASS="LITERAL"
>COLUMNS</TT
> environment variables.</P
><P
>The following additional options may be supported:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23419"
></A
><SPAN
STYLE="white-space: nowrap"
>-<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies an integer which is the screen size (in lines).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23424"
></A
><SPAN
STYLE="white-space: nowrap"
>+<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>starts at line number <TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23430"
></A
><SPAN
STYLE="white-space: nowrap"
>+/<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Start at the first line matching the pattern, 
equivalent to executing the search forward (<TT
CLASS="LITERAL"
>/</TT
>)
command with the given pattern immediately after opening each file.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The following options from <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> may behave
differently:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23439"
></A
><SPAN
STYLE="white-space: nowrap"
>-e</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23443"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23447"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23451"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Either clear the whole screen before displaying any text (instead
of the usual scrolling behavior), or provide the behavior
specified by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.  In the latter case, the
syntax is "<TT
CLASS="PARAMETER"
><I
>-p <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
></I
></TT
>".</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23458"
></A
><SPAN
STYLE="white-space: nowrap"
>-t</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <B
CLASS="COMMAND"
>more</B
> command need not support the following
interactive commands:

<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>g</TD
></TR
><TR
><TD
>G</TD
></TR
><TR
><TD
>u</TD
></TR
><TR
><TD
>control u</TD
></TR
><TR
><TD
>control f</TD
></TR
><TR
><TD
>newline</TD
></TR
><TR
><TD
>j</TD
></TR
><TR
><TD
>k</TD
></TR
><TR
><TD
>r</TD
></TR
><TR
><TD
>R</TD
></TR
><TR
><TD
>m</TD
></TR
><TR
><TD
>' (return to mark)</TD
></TR
><TR
><TD
>/!</TD
></TR
><TR
><TD
>?</TD
></TR
><TR
><TD
>N</TD
></TR
><TR
><TD
>:e</TD
></TR
><TR
><TD
>:t</TD
></TR
><TR
><TD
>control g</TD
></TR
><TR
><TD
>ZZ</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23484"
></A
><H2
>Rationale</H2
><P
>The +<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> and
+/<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> options are deprecated in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, and have been removed in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>; 
however this specification continues to
specify them because the publicly available 
<TT
CLASS="LITERAL"
>util-linux</TT
> package does not support the replacement
(-p <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>).  The
+<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> option as found in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
> is more general than is specified here,
but the <TT
CLASS="LITERAL"
>util-linux</TT
> package appears to only support the more
specific +<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> and
+/<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> forms.</P
></DIV
><H1
><A
NAME="MOUNT"
></A
>mount</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23501"
></A
><H2
>Name</H2
>mount&nbsp;--&nbsp;mount a file system </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23504"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>mount</B
> [-hV]<BR><B
CLASS="COMMAND"
>mount</B
> [-a] [-fFnrsvw] [-t <TT
CLASS="REPLACEABLE"
><I
>vfstype</I
></TT
>]<BR><B
CLASS="COMMAND"
>mount</B
> [-fnrsvw] [-o <TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
> [,...]] [device | dir]<BR><B
CLASS="COMMAND"
>mount</B
> [-fnrsvw] [-t <TT
CLASS="REPLACEABLE"
><I
>vfstype</I
></TT
>] [-o options]  device   dir </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23531"
></A
><H2
>Description</H2
><P
>As described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, all files in the system
are organized in a directed graph, known as the file hierarchy,
rooted at <TT
CLASS="FILENAME"
>/</TT
>.
These files can be spread out over
several underlying devices.
The <B
CLASS="COMMAND"
>mount</B
> command shall attach the file system
found on some underlying device to the file hierarchy. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23537"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23540"
></A
><SPAN
STYLE="white-space: nowrap"
>-v</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>invoke verbose mode. The <B
CLASS="COMMAND"
>mount</B
> command shall provide diagnostic
messages on <CODE
CLASS="VARNAME"
>stdout</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23546"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount all file systems (of the given types) mentioned in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23551"
></A
><SPAN
STYLE="white-space: nowrap"
>-F</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the <TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option is also present,
fork a new incarnation of <B
CLASS="COMMAND"
>mount</B
>
for each device to be mounted.  This will do the mounts on different devices or
different NFS servers in parallel.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23557"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>cause everything to be done except for the actual system call; if
it's not obvious, this `fakes' mounting the file system.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23561"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount without writing in <TT
CLASS="FILENAME"
>/etc/mtab</TT
>.  This is necessary for example
when <TT
CLASS="FILENAME"
>/etc</TT
> is on a read-only file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23567"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>ignore <B
CLASS="COMMAND"
>mount</B
> options not supported by a 
file system type.  Not all file systems support this option. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23572"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read-only. A synonym is <TT
CLASS="PARAMETER"
><I
>-o ro</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23577"
></A
><SPAN
STYLE="white-space: nowrap"
>-w</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read/write. (default) A synonym is
<TT
CLASS="PARAMETER"
><I
>-o rw</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23582"
></A
><SPAN
STYLE="white-space: nowrap"
>-L label</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file <TT
CLASS="FILENAME"
>/proc/partitions</TT
> is supported,
mount the partition that has the specified label.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23587"
></A
><SPAN
STYLE="white-space: nowrap"
>-U uuid</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file <TT
CLASS="FILENAME"
>/proc/partitions</TT
> is supported,
mount the partition that has the specified uuid.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23592"
></A
><SPAN
STYLE="white-space: nowrap"
>-t vfstype</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>indicate a file system type of <TT
CLASS="PARAMETER"
><I
>vfstype</I
></TT
>. </P
><P
>More than one type may be specified in a comma separated list.  The
list of file system types can be prefixed with <TT
CLASS="LITERAL"
>no</TT
> to specify the file
system types on which no action should be taken.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23599"
></A
><SPAN
STYLE="white-space: nowrap"
>-o</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>options are specified with a <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> flag followed by a comma-separated
string of options.  Some of these options are only useful when they
appear in the <TT
CLASS="FILENAME"
>/etc/fstab</TT
> file.  The following options apply to any
file system that is being mounted:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23606"
></A
><SPAN
STYLE="white-space: nowrap"
>async</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>perform all I/O to the file system asynchronously.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23610"
></A
><SPAN
STYLE="white-space: nowrap"
>atime</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>update inode access time for each access. (default)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23614"
></A
><SPAN
STYLE="white-space: nowrap"
>auto</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>,
indicate the device is mountable with <TT
CLASS="PARAMETER"
><I
>-a</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23620"
></A
><SPAN
STYLE="white-space: nowrap"
>defaults</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use default options:
<TT
CLASS="LITERAL"
>rw</TT
>, <TT
CLASS="LITERAL"
>suid</TT
>, <TT
CLASS="LITERAL"
>dev</TT
>, <TT
CLASS="LITERAL"
>exec</TT
>, <TT
CLASS="LITERAL"
>auto</TT
>, <TT
CLASS="LITERAL"
>nouser</TT
>, <TT
CLASS="LITERAL"
>async</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23639"
></A
><SPAN
STYLE="white-space: nowrap"
>dev</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>interpret character or block special devices on the file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23643"
></A
><SPAN
STYLE="white-space: nowrap"
>exec</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>permit execution of binaries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23647"
></A
><SPAN
STYLE="white-space: nowrap"
>noatime</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not update file access times on this file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23651"
></A
><SPAN
STYLE="white-space: nowrap"
>noauto</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>,
indicates the device is only explicitly mountable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23656"
></A
><SPAN
STYLE="white-space: nowrap"
>nodev</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not interpret character or block special devices on the file
system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23660"
></A
><SPAN
STYLE="white-space: nowrap"
>noexec</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not allow execution of any binaries on the mounted file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23664"
></A
><SPAN
STYLE="white-space: nowrap"
>nosuid</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not allow set-user-identifier or set-group-identifier bits to take
effect.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23668"
></A
><SPAN
STYLE="white-space: nowrap"
>nouser</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>forbid an unprivileged user to mount the file system.
(default)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23672"
></A
><SPAN
STYLE="white-space: nowrap"
>remount</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>remount an already-mounted file system.  This is commonly
used to change the mount options for a file system, especially to make a
read-only file system writable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23676"
></A
><SPAN
STYLE="white-space: nowrap"
>ro</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read-only.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23680"
></A
><SPAN
STYLE="white-space: nowrap"
>rw</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read-write.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23684"
></A
><SPAN
STYLE="white-space: nowrap"
>suid</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>allow set-user-identifier or set-group-identifier bits to take effect.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23688"
></A
><SPAN
STYLE="white-space: nowrap"
>sync</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do all I/O to the file system synchronously.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23692"
></A
><SPAN
STYLE="white-space: nowrap"
>user</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>allow an unprivilieged user to mount the file system.  This option implies
the options 
<TT
CLASS="LITERAL"
>noexec</TT
>, <TT
CLASS="LITERAL"
>nosuid</TT
>, <TT
CLASS="LITERAL"
>nodev</TT
>
unless overridden by subsequent options.</P
></TD
></TR
></TBODY
></TABLE
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23703"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23707"
></A
><SPAN
STYLE="white-space: nowrap"
>-V</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>output version and exit.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="MSGFMT"
></A
>msgfmt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23714"
></A
><H2
>Name</H2
>msgfmt&nbsp;--&nbsp;create a message object from a message file </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23717"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>msgfmt</B
> [options...]  <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23723"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>msgfmt</B
> command
generates a binary message catalog from a textual translation description.
Message catalogs, or 
message object files, are stored in files with a <TT
CLASS="FILENAME"
>.mo</TT
> extension.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The format of message object files is not guaranteed to be portable.
Message catalogs should always be generated on the target architecture using the
<B
CLASS="COMMAND"
>msgfmt</B
> command.</P
></BLOCKQUOTE
></DIV
></P
><P
>The source message files, otherwise known as portable object files, have a
<TT
CLASS="FILENAME"
>.po</TT
> extension.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> operands shall be portable object files.
The <TT
CLASS="FILENAME"
>.po</TT
> file contains messages to be
displayed to users by system utilities or by
application programs. The portable object files are text files, 
and the messages in them can
be rewritten in any language supported by the system.</P
><P
>If any <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is <TT
CLASS="FILENAME"
>-</TT
>, 
a portable object file shall be read from the standard input.</P
><P
>The <B
CLASS="COMMAND"
>msgfmt</B
> command interprets data as characters 
according to the current setting of the
<CODE
CLASS="CONSTANT"
>LC_CTYPE</CODE
> locale category.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23742"
></A
><H2
>Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-c, --check</DT
><DD
><P
>Detect and diagnose input file anomalies which might represent translation
errors. The <TT
CLASS="LITERAL"
>msgid</TT
> and <TT
CLASS="LITERAL"
>msgstr</TT
> strings are studied and compared. It is
considered abnormal that one string starts or ends with a newline while the
other does not.</P
><P
>If the message is flagged as <TT
CLASS="LITERAL"
>c-format</TT
> (see <A
HREF="#MSGFMT-COMMENTS"
>Comment Handling</A
>),
check that the <TT
CLASS="LITERAL"
>msgid</TT
> string and the <TT
CLASS="LITERAL"
>msgstr</TT
> translation
have the same number of <TT
CLASS="LITERAL"
>%</TT
> format specifiers, with matching types.</P
></DD
><DT
>-D <TT
CLASS="PARAMETER"
><I
>directory</I
></TT
>, --directory=<TT
CLASS="PARAMETER"
><I
>directory</I
></TT
></DT
><DD
><P
>Add directory to list for input files search. 
If <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is not an absolute pathname
and <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> cannot be opened, search for it
in <TT
CLASS="PARAMETER"
><I
>directory</I
></TT
>. This option may be
repeated. Directories shall be searched in order, with the leftmost
<TT
CLASS="PARAMETER"
><I
>directory</I
></TT
> searched first.</P
></DD
><DT
>-f, --use-fuzzy</DT
><DD
><P
>Use entries marked as <TT
CLASS="LITERAL"
>fuzzy</TT
>
in output. If this option is not specified, such entries
are not included into the output. See <A
HREF="#MSGFMT-COMMENTS"
>Comment Handling</A
> below.</P
></DD
><DT
>-o <TT
CLASS="PARAMETER"
><I
>output-file</I
></TT
>, --output-file=<TT
CLASS="PARAMETER"
><I
>output-file</I
></TT
></DT
><DD
><P
>Specify the output file name as <TT
CLASS="FILENAME"
>output-file</TT
>. If multiple domains or
duplicate
msgids in the <TT
CLASS="FILENAME"
>.po</TT
> file are present, the behavior is unspecified.
If output-file is <TT
CLASS="FILENAME"
>-</TT
>, output is written
to standard output.</P
></DD
><DT
>--strict</DT
><DD
><P
>Ensure that all output files have a <TT
CLASS="FILENAME"
>.mo</TT
> extension.
Output files are named either by the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> (or
<TT
CLASS="PARAMETER"
><I
>--output-file</I
></TT
>) option, or by domains found in the input
files.</P
></DD
><DT
>-v, --verbose</DT
><DD
><P
>Print additional information to the standard error, including the number
of translated strings processed.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23798"
></A
><H2
>Operands</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> operands are treated as portable object files. 
The format of
portable object files is defined in EXTENDED DESCRIPTION.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23802"
></A
><H2
>Standard Input</H2
><P
>The standard input is not used unless a <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>
operand is specified as
"-".</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23806"
></A
><H2
>Environment Variables</H2
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23810"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LANGUAGE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies one or more locale names. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23815"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LANG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies locale name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23820"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LC_ALL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies locale name for all categories. If defined, overrides <CODE
CLASS="ENVAR"
>LANG</CODE
>,
<CODE
CLASS="ENVAR"
>LC_CTYPE</CODE
> and <CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23828"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LC_CTYPE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Determine the locale for the interpretation of sequences of bytes
of text data as characters (for example, single-byte as opposed to multi-byte
characters in arguments and input files).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23833"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies messaging locale, and if present overrides <CODE
CLASS="ENVAR"
>LANG</CODE
> for messages.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23839"
></A
><H2
>Standard Output</H2
><P
>The standard output is not used unless the option-argument of the 
<TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option
is specified as <TT
CLASS="FILENAME"
>-</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23844"
></A
><H2
>Extended Description</H2
><P
>The format of portable object files (<TT
CLASS="FILENAME"
>.po</TT
> files) is defined as follows. Each
<TT
CLASS="FILENAME"
>.po</TT
> file contains one or more lines, with each line containing either a
comment or a statement. Comments start the line with a hash mark (<TT
CLASS="LITERAL"
>#</TT
>) and end
with the newline character. Empty lines, or lines containing only white-space,
shall be ignored. 
Comments can in certain circumstances alter the behavior of 
<B
CLASS="COMMAND"
>msgfmt</B
>.  See 
<A
HREF="#MSGFMT-COMMENTS"
>Comment Handling</A
> below for details on comment processing.
The format of a statement is:</P
><P
><TT
CLASS="LITERAL"
>directive value</TT
></P
><P
>Each <TT
CLASS="LITERAL"
>directive</TT
> starts at the beginning of the line and is separated from
<TT
CLASS="LITERAL"
>value</TT
> by white space (such as one or more space or tab characters). The
<TT
CLASS="LITERAL"
>value</TT
>
consists of one or more quoted strings separated by white space. If two or
more strings are specified as <TT
CLASS="LITERAL"
>value</TT
>, they are normalized into single string
using the string normalization syntax specified in <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
>.
The following directives are supported:</P
><P
><TT
CLASS="LITERAL"
>domain domainname</TT
></P
><P
><TT
CLASS="LITERAL"
>msgid message_identifier</TT
></P
><P
><TT
CLASS="LITERAL"
>msgid_plural untranslated_string_plural</TT
></P
><P
><TT
CLASS="LITERAL"
>msgstr message_string</TT
></P
><P
><TT
CLASS="LITERAL"
>msgstr[<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>] message_string</TT
></P
><P
>The behavior of the <TT
CLASS="LITERAL"
>domain</TT
> directive is affected by the options used. See
OPTIONS for the behavior when the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is specified. 
If the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option
is not specified, the behavior of the <TT
CLASS="LITERAL"
>domain</TT
> directive is as follows:
<P
></P
><OL
TYPE="1"
><LI
><P
>All msgids from the beginning of each <TT
CLASS="FILENAME"
>.po</TT
> file to the first 
<TT
CLASS="LITERAL"
>domain</TT
>
directive are put into a default message object file, messages (or
<TT
CLASS="FILENAME"
>messages.mo</TT
> if the <TT
CLASS="PARAMETER"
><I
>--strict</I
></TT
> option is specified).</P
></LI
><LI
><P
>When <B
CLASS="COMMAND"
>msgfmt</B
> encounters a 
<TT
CLASS="LITERAL"
>domain domainname</TT
> directive in the <TT
CLASS="FILENAME"
>.po</TT
> file,
all following <TT
CLASS="PARAMETER"
><I
>msgids</I
></TT
> until the next <TT
CLASS="LITERAL"
>domain</TT
> directive are put into the
message object file <TT
CLASS="FILENAME"
>domainname</TT
> (or 
<TT
CLASS="FILENAME"
>domainname.mo</TT
> if <TT
CLASS="PARAMETER"
><I
>--strict</I
></TT
> option is
specified).</P
></LI
><LI
><P
>Duplicate <TT
CLASS="PARAMETER"
><I
>msgids</I
></TT
> are defined in the scope of each domain. That is, a
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> is considered a duplicate only if the identical <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>
exists in the same domain.</P
></LI
><LI
><P
>All duplicate <TT
CLASS="PARAMETER"
><I
>msgids</I
></TT
> are ignored.</P
></LI
></OL
>&#13;</P
><P
>The <TT
CLASS="LITERAL"
>msgid</TT
> directive specifies the value of a message identifier associated
with the directive that follows it. The <TT
CLASS="LITERAL"
>msgid_plural</TT
> directive specifies the
plural form message specified to the plural message handling functions
<TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
> or <TT
CLASS="FUNCTION"
>dcngettext()</TT
>. 
The message_identifier string
identifies a target string to be used at retrieval time. Each statement
containing a <TT
CLASS="LITERAL"
>msgid</TT
> directive shall be followed by a statement containing a
<TT
CLASS="LITERAL"
>msgstr</TT
> directive or <TT
CLASS="LITERAL"
>msgstr[n]</TT
> directives.</P
><P
>The <TT
CLASS="LITERAL"
>msgstr</TT
> directive specifies the target string associated with the
<TT
CLASS="PARAMETER"
><I
>message_identifier</I
></TT
> string declared in the immediately preceding 
<TT
CLASS="LITERAL"
>msgid</TT
> directive.</P
><P
>The <TT
CLASS="LITERAL"
>msgstr[<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>]</TT
> (where 
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
> = 0, 1, 2, ...) directive specifies the target string
to be used with plural form handling functions 
<TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
> and
<TT
CLASS="FUNCTION"
>dcngettext()</TT
>.</P
><P
>Message strings can contain the following escape sequences:
<DIV
CLASS="TABLE"
><A
NAME="AEN23922"
></A
><P
><B
>Table 15-1. Escape Sequences</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>\n</TT
></TD
><TD
>newline</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\t</TT
></TD
><TD
>tab</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\v</TT
></TD
><TD
>vertical tab</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\b</TT
></TD
><TD
>backspace</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\r</TT
></TD
><TD
>carriage return</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\f</TT
></TD
><TD
>formfeed</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\\</TT
></TD
><TD
>backslash</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\"</TT
></TD
><TD
>double quote</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\ddd</TT
></TD
><TD
>octal bit pattern</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\xHH</TT
></TD
><TD
>hexadecimal bit pattern</TD
></TR
></TBODY
></TABLE
></DIV
></P
><DIV
CLASS="REFSECT2"
><A
NAME="MSGFMT-COMMENTS"
></A
><H3
>Comment Handling</H3
><P
>Comments are introduced by a <TT
CLASS="LITERAL"
>#</TT
>, and continue to the
end of the line. The second character (i.e. the character following the
<TT
CLASS="LITERAL"
>#</TT
>) has special meaning. Regular comments should
follow a space character. Other comment types include:</P
><P
><TT
CLASS="LITERAL"
># normal-comments</TT
></P
><P
><TT
CLASS="LITERAL"
>#. automatic-comments</TT
></P
><P
><TT
CLASS="LITERAL"
>#: reference...</TT
></P
><P
><TT
CLASS="LITERAL"
>#, flag</TT
></P
><P
>Automatic and reference comments are typically generated by external utilities,
and are not specified by the LSB. The <B
CLASS="COMMAND"
>msgfmt</B
> command
shall ignore such comments.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Portable object files may be produced by unspecified tools. Some of the comment
types described here may arise from the use of such tools. It is beyond the
scope of this specification to describe these tools.</P
></BLOCKQUOTE
></DIV
></P
><P
>The <TT
CLASS="LITERAL"
>#,</TT
> comments require one or more flags separated by 
the comma (<TT
CLASS="LITERAL"
>,</TT
>) character.
The following flags can be specified:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23987"
></A
><SPAN
STYLE="white-space: nowrap"
>fuzzy</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This flag shows that the following <TT
CLASS="LITERAL"
>msgstr</TT
> string might not be a correct
translation. Only the translator (i.e. the individual undertaking
the translation) can judge if the translation
requires further modification, or is acceptable as is. Once satisfied with
the translation, the translator then removes this fuzzy flag. </P
><P
>If this flag is specified, the <B
CLASS="COMMAND"
>msgfmt</B
> utility will not generate the entry
for the immediately following <TT
CLASS="LITERAL"
>msgid</TT
> in the output message catalog,
unless the <TT
CLASS="PARAMETER"
><I
>--use-fuzzy</I
></TT
> is specified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN23996"
></A
><SPAN
STYLE="white-space: nowrap"
>c-format</SPAN
>, <SPAN
STYLE="white-space: nowrap"
>no-c-format</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="LITERAL"
>c-format</TT
> flag indicates that the <TT
CLASS="LITERAL"
>msgid</TT
> string is
used as format string by <TT
CLASS="FUNCTION"
>printf()</TT
>-like functions. 
If the <TT
CLASS="LITERAL"
>c-format</TT
> flag is
given for a string the <B
CLASS="COMMAND"
>msgfmt</B
> utility may perform additional 
tests to check the
validity of the translation.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN24006"
></A
><H3
>Plurals</H3
><P
>The msgid entry with empty string ("") is called the header entry and
is treated specially. If the message string for the header entry contains
<TT
CLASS="LITERAL"
>nplurals=value</TT
>, the value indicates the number of plural forms. For example,
if <TT
CLASS="LITERAL"
>nplurals=4</TT
>, there are 4 plural forms. If <TT
CLASS="LITERAL"
>nplurals</TT
>
is defined, there
should be a <TT
CLASS="LITERAL"
>plural=expression</TT
> on the same line, separated by a semicolon (;)
character. The expression is a C language expression to determine which
version of <TT
CLASS="LITERAL"
>msgstr[n]</TT
> to be used based on the value of <TT
CLASS="LITERAL"
>n</TT
>,
the last argument
of <TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
> or <TT
CLASS="FUNCTION"
>dcngettext()</TT
>.
For example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>nplurals=2; plural=n == 1 ? 0 : 1</PRE
></TD
></TR
></TABLE
><P
>indicates that there are 2 plural forms in the language; <TT
CLASS="LITERAL"
>msgstr[0]</TT
> is used
if <TT
CLASS="LITERAL"
>n == 1</TT
>, otherwise <TT
CLASS="LITERAL"
>msgstr[1]</TT
> is used. Another example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2</PRE
></TD
></TR
></TABLE
><P
>indicates that there are 3 plural forms in the language; <TT
CLASS="LITERAL"
>msgstr[0]</TT
> is used
if <TT
CLASS="LITERAL"
>n == 1</TT
>, <TT
CLASS="LITERAL"
>msgstr[1]</TT
> is used if 
<TT
CLASS="LITERAL"
>n == 2</TT
>, otherwise <TT
CLASS="LITERAL"
>msgstr[2]</TT
> is used.</P
><P
>If the header entry contains <TT
CLASS="LITERAL"
>charset=<TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
></TT
> string, the 
<TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
> is used to
indicate the codeset to be used to encode the message strings. If the output
string's codeset is different from the message string's codeset, codeset
conversion from the message strings's codeset to the output string's codeset
will be performed upon the call of <TT
CLASS="FUNCTION"
>gettext()</TT
>, <TT
CLASS="FUNCTION"
>dgettext()</TT
>,
<TT
CLASS="FUNCTION"
>dcgettext()</TT
>, <TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
>, and 
<TT
CLASS="FUNCTION"
>dcngettext()</TT
>. The output string's codeset is
determined by the current locale's codeset (the return value of
nl_langinfo(CODESET)) by default, and can be changed by the call of
<TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24041"
></A
><H2
>Exit Status</H2
><P
>The following exit values are returned:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24045"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Successful completion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24050"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>&#62;0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24055"
></A
><H2
>Application Usage</H2
><P
>Neither <B
CLASS="COMMAND"
>msgfmt</B
> nor any <TT
CLASS="FUNCTION"
>gettext()</TT
> function
imposes a limit on the total length
of a message. Installing message catalogs under the C locale is pointless,
since they are ignored for the sake of efficiency.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24060"
></A
><H2
>Examples</H2
><P
>Example 1: Examples of creating message objects from message files.</P
><P
>In this example <TT
CLASS="FILENAME"
>module1.po</TT
>, <TT
CLASS="FILENAME"
>module2.po</TT
> and 
<TT
CLASS="FILENAME"
>module3.po</TT
> are portable message object
files.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% cat module1.po

# default domain "messages"

msgid "message one"

msgstr "mensaje número uno"

#

domain "help_domain"

msgid "help two"

msgstr "ayuda número dos"

#

domain "error_domain"

msgid "error three"

msgstr "error número tres"&#13;</PRE
></TD
></TR
></TABLE
><P
> </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% cat module2.po

# default domain "messages"

msgid "message four"

msgstr "mensaje número cuatro"

#

domain "error_domain"

msgid "error five"

msgstr "error número cinco"

#

domain "window_domain"

msgid "window six"

msgstr "ventana número seises"</PRE
></TD
></TR
></TABLE
><P
> </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% cat module3.po

# default domain "messages"

msgid "message seven"

msgstr "mensaje número siete"&#13;</PRE
></TD
></TR
></TABLE
><P
>The following command will produce the output files <TT
CLASS="FILENAME"
>messages</TT
>, 
<TT
CLASS="FILENAME"
>help_domain</TT
>, and <TT
CLASS="FILENAME"
>error_domain</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% msgfmt module1.po</PRE
></TD
></TR
></TABLE
><P
>The following command will produce the output files <TT
CLASS="FILENAME"
>messages.mo</TT
>,
<TT
CLASS="FILENAME"
>help_domain.mo</TT
>, <TT
CLASS="FILENAME"
>error_domain.mo</TT
>, and <TT
CLASS="FILENAME"
>window_domain.mo</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% msgfmt module1.po module2.po</PRE
></TD
></TR
></TABLE
><P
>The following example will produce the output file <TT
CLASS="FILENAME"
>hello.mo</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% msgfmt -o hello.mo module3.po</PRE
></TD
></TR
></TABLE
></DIV
><H1
><A
NAME="NEWGRP"
></A
>newgrp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24089"
></A
><H2
>Name</H2
>newgrp&nbsp;--&nbsp;change group ID</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24092"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>newgrp</B
> [group]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24096"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>newgrp</B
> command is as specified
in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN24101"
></A
><H3
>Differences</H3
><P
>The <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> option specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
need not be supported.</P
></DIV
></DIV
><H1
><A
NAME="OD"
></A
>od</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24109"
></A
><H2
>Name</H2
>od&nbsp;--&nbsp;dump files in octal and other formats </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24112"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>od</B
> [-abcdfilox] [-w <TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
> | --width-<TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>] [-v] [-A <TT
CLASS="REPLACEABLE"
><I
>address_base</I
></TT
>] [-j <TT
CLASS="REPLACEABLE"
><I
>skip</I
></TT
>] [-n <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>] [-t <TT
CLASS="REPLACEABLE"
><I
>type_string</I
></TT
>] [file...]<BR><B
CLASS="COMMAND"
>od</B
>  --traditional  [options] [file] [[+]offset [.] [b]] [[+]label [.] [b]]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24144"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>od</B
> command shall
provide all of the madatory functionality specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with extensions and 
differences to the XSI optional behavior as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24149"
></A
><H2
>Extensions and Differences</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-s</DT
><DD
><P
>unspecified behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Applications wishing to achieve the <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>
behavior for <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> should instead use 
<TT
CLASS="PARAMETER"
><I
>-t d2</I
></TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
>-w<TT
CLASS="PARAMETER"
><I
>width</I
></TT
>, --width[=<TT
CLASS="PARAMETER"
><I
>width</I
></TT
>]</DT
><DD
><P
>each output line is limited to <TT
CLASS="PARAMETER"
><I
>width</I
></TT
> bytes from the input.</P
></DD
><DT
>--traditional</DT
><DD
><P
>accepts arguments in traditional form, see <A
HREF="#OD.TRAD.USAGE"
>Traditional Usage</A
>
below.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The XSI optional behavior 
for offset handling described in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> is not supported
unless the <TT
CLASS="PARAMETER"
><I
>--traditional</I
></TT
> option is also specified.</P
></BLOCKQUOTE
></DIV
></P
></DD
></DL
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN24177"
></A
><H3
>Pre-POSIX and XSI Specifications</H3
><P
>The LSB supports mixing options between the mandatory
and XSI optional synopsis forms in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
The LSB shall support the following options:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24182"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t a</I
></TT
>, selects named characters.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24187"
></A
><SPAN
STYLE="white-space: nowrap"
>-b</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t o1</I
></TT
>, selects octal bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24192"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t c</I
></TT
>, selects characters.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24197"
></A
><SPAN
STYLE="white-space: nowrap"
>-d</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t u2</I
></TT
>, selects unsigned decimal two byte units.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24202"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t fF</I
></TT
>, selects floats.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24207"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t d2</I
></TT
>, selects decimal two byte units.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This usage may change in future releases; portable applications should use
<TT
CLASS="PARAMETER"
><I
>-t d2</I
></TT
>.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24215"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t d4</I
></TT
>, selects decimal longs.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24220"
></A
><SPAN
STYLE="white-space: nowrap"
>-o</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t o2</I
></TT
>, selects octal two byte units.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24225"
></A
><SPAN
STYLE="white-space: nowrap"
>-x</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t x2</I
></TT
>, selects hexadecimal two byte units.</P
></TD
></TR
></TBODY
></TABLE
><P
>Note that the XSI option <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> need not be supported.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="OD.TRAD.USAGE"
></A
><H3
>Traditional Usage</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>--traditional</I
></TT
> option is specified,
there may be between zero and three operands specified.</P
><P
>If no operands are specified, then <B
CLASS="COMMAND"
>od</B
> shall read the standard input.</P
><P
>If there is exactly one operand, and it is an offset of the form 
<TT
CLASS="LITERAL"
>[+]offset[.][b]</TT
>,
then it shall be interpreted as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>. The file to
be dumped shall be the standard input.</P
><P
>If there are exactly two operands, and they are both of the form
<TT
CLASS="LITERAL"
>[+]offset[.][b]</TT
>, then the first shall be treated
as an offset (as above), and
the second shall be a label, in the same format as the offset. If a label is
specified, then the first output line produced for each input block shall be
preceded by the input offset, cumulative across input files, of the next byte to
be written, followed by the label, in parentheses. The label shall increment in
the same manner as the offset.</P
><P
>If there are three operands, then the first shall be the file to dump, the
second the offset, and the third the label.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Recent versions of <B
CLASS="COMMAND"
>coreutils</B
> contain an
<B
CLASS="COMMAND"
>od</B
> utility that conforms to
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>. However, in April 2005, this version
was not in widespread use. A future version of this specification
may remove the differences.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="PASSWD"
></A
>passwd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24252"
></A
><H2
>Name</H2
>passwd&nbsp;--&nbsp;change user password</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24255"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>passwd</B
> [-x max] [-n min] [-w warn] [-i inact]  name <BR><B
CLASS="COMMAND"
>passwd</B
> {-l | -u}  name </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24269"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>passwd</B
> changes authentication
information for user and group accounts, including
passwords and password expiry details, and may
be used to enable and disable accounts.
Only a user with appropriate privilege may change
the password for other users or modify the
expiry information.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24273"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24276"
></A
><SPAN
STYLE="white-space: nowrap"
>-x max</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the maximum number of days a password remains valid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24280"
></A
><SPAN
STYLE="white-space: nowrap"
>-n min</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the minimum number of days before a password may be changed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24284"
></A
><SPAN
STYLE="white-space: nowrap"
>-w warn</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the number of days warning the user will receive before
their password will expire.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24288"
></A
><SPAN
STYLE="white-space: nowrap"
>-i inactive</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>disables an account after the password has been expired for the given
number of days.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24292"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>disables an account by changing the password to a value which
matches no possible encrypted value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24296"
></A
><SPAN
STYLE="white-space: nowrap"
>-u</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>re-enables an account by changing the password back to its previous value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="PATCH"
></A
>patch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24303"
></A
><H2
>Name</H2
>patch&nbsp;--&nbsp;apply a diff file to an original</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24306"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>patch</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
extensions as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24311"
></A
><H2
>Extensions</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24314"
></A
><SPAN
STYLE="white-space: nowrap"
>--binary</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reads and write all files in binary mode, except for standard output and
/dev/tty.  This option has no effect on POSIX-compliant systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24318"
></A
><SPAN
STYLE="white-space: nowrap"
>-u, --unified</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>interprets the patch file as a unified context diff.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="PIDOF"
></A
>pidof</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24325"
></A
><H2
>Name</H2
>pidof&nbsp;--&nbsp;find the process ID of a running program</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24328"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>pidof</B
> [-s] [-x] [-o omitpid...]  program... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24335"
></A
><H2
>Description</H2
><P
>Return the process ID of a process which is running the program named
on the command line.</P
><P
>The <B
CLASS="COMMAND"
>pidof</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24341"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24344"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>instructs the program to only return one pid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24348"
></A
><SPAN
STYLE="white-space: nowrap"
>-x</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>causes the program to also return process id's of
shells running the named scripts.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24352"
></A
><SPAN
STYLE="white-space: nowrap"
>-o</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>omits processes with specified process id.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="REMOVEINITD"
></A
>remove_initd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24359"
></A
><H2
>Name</H2
>remove_initd&nbsp;--&nbsp;clean up init script system modifications introduced by install_initd</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24362"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/lib/lsb/remove_initd</B
>  initd_file </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24366"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>remove_initd</B
> processes the removal of the
modifications made to a distribution's init script system by the 
<B
CLASS="COMMAND"
>install_initd</B
> program. This cleanup is performed
in the preuninstall script of a package; however, the package manager
is still responsible for removing the script from the repository.
See also <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
>.</P
></DIV
><H1
><A
NAME="RENICE"
></A
>renice</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24375"
></A
><H2
>Name</H2
>renice&nbsp;--&nbsp;alter priority of running processes</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24378"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>renice</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24383"
></A
><H2
>Differences</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24386"
></A
><SPAN
STYLE="white-space: nowrap"
>-n increment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="SED"
></A
>sed</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24393"
></A
><H2
>Name</H2
>sed&nbsp;--&nbsp;stream editor</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24396"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>sed</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24401"
></A
><H2
>LSB Differences</H2
><P
>Certain aspects of internationalized regular expressions are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Internationalization and Regular Expressions</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-SENDMAIL-1"
></A
>sendmail</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24409"
></A
><H2
>Name</H2
>sendmail&nbsp;--&nbsp;an electronic mail transport agent</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24412"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/sbin/sendmail</B
> [options] [address...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24417"
></A
><H2
>Description</H2
><P
>To deliver electronic mail (email), applications shall support
the interface provided by <B
CLASS="COMMAND"
>sendmail</B
> (described here).
This interface shall be the default delivery method for applications.</P
><P
>This program sends an email message to one or more recipients,
routing the message as necessary.  This program is not intended
as a user interface routine.</P
><P
>With no options, <B
CLASS="COMMAND"
>sendmail</B
> reads its standard input up to an
end-of-file or a line consisting only of a single dot and sends a
copy of the message found there to all of the addresses listed.
It determines the network(s) to use based on the syntax and
contents of the addresses.</P
><P
>If an address is preceded by a backslash, <TT
CLASS="LITERAL"
>'\'</TT
>,
it is unspecified if the
address is subject to local alias expansion.</P
><P
>The format of messages shall be as defined in 
<A
HREF="#STD.RFC2822"
>RFC 2822:Internet Message Format</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The name <B
CLASS="COMMAND"
>sendmail</B
> was chosen for historical
reasons, but 
the <B
CLASS="COMMAND"
>sendmail</B
> command specified here
is intended to reflect functionality provided by 
<B
CLASS="COMMAND"
>smail</B
>, 
<B
CLASS="COMMAND"
>exim</B
>
and other implementations, not just the <B
CLASS="COMMAND"
>sendmail</B
> 
implementation.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24437"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24440"
></A
><SPAN
STYLE="white-space: nowrap"
>-bm</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>read mail from standard input and deliver it to the recipient addresses.
This is the default mode of operation.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24444"
></A
><SPAN
STYLE="white-space: nowrap"
>-bp</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the user has sufficient privilege,
list information about messages currently in the mail queue.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24448"
></A
><SPAN
STYLE="white-space: nowrap"
>-bs</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use the SMTP protocol as described in 
<A
HREF="#STD.RFC2821"
>RFC 2821:Simple Mail Transfer Protocol</A
>; read SMTP commands on
standard input and write SMTP responses on standard output.</P
><P
>In this mode, <B
CLASS="COMMAND"
>sendmail</B
> shall accept
<TT
CLASS="LITERAL"
>\r\n</TT
> (CR-LF), as required by
<A
HREF="#STD.RFC2821"
>RFC 2821:Simple Mail Transfer Protocol</A
>, and <TT
CLASS="LITERAL"
>\n</TT
>
(LF) line terminators.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24458"
></A
><SPAN
STYLE="white-space: nowrap"
>-F fullname</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>explicitly set the full name of the sender for incoming
mail unless the message already contains a 
<TT
CLASS="LITERAL"
>From:</TT
> message
header.</P
><P
>If the user running <B
CLASS="COMMAND"
>sendmail</B
> is not sufficiently trusted,
then the actual sender may be indicated in the message,
depending on the configuration of the agent.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24465"
></A
><SPAN
STYLE="white-space: nowrap"
>-f name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>explicitly set the envelope sender address for incoming
mail.   If there is no 
<TT
CLASS="LITERAL"
>From:</TT
> header, the address specified
in the 
<TT
CLASS="LITERAL"
>From:</TT
> header will also be set.</P
><P
>If the user running <B
CLASS="COMMAND"
>sendmail</B
> is not sufficiently trusted,
then the actual sender shall be indicated in the message.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24473"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>ignore dots alone on lines by themselves in incoming
messages.  If this options is not specified,
a line consisting of a single dot shall terminate the input.
If -bs is also used, the behavior is unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24477"
></A
><SPAN
STYLE="white-space: nowrap"
>-odb</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>deliver any mail in background, if supported; otherwise ignored.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24481"
></A
><SPAN
STYLE="white-space: nowrap"
>-odf</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>deliver any mail in foreground, if supported; otherwise ignored.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24485"
></A
><SPAN
STYLE="white-space: nowrap"
>-oem or -em</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mail errors back to the sender. (default)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24489"
></A
><SPAN
STYLE="white-space: nowrap"
>-oep or -ep</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>write errors to the standard error output.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24493"
></A
><SPAN
STYLE="white-space: nowrap"
>-oeq or -eq</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not send notification of errors to the sender.  This
only works for mail delivered locally.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24497"
></A
><SPAN
STYLE="white-space: nowrap"
>-oi</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to -i.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24501"
></A
><SPAN
STYLE="white-space: nowrap"
>-om</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>indicate that the sender of
a message should receive a copy of the message if the
sender appears in an alias expansion.  Ignored if aliases
are not supported.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24505"
></A
><SPAN
STYLE="white-space: nowrap"
>-t</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>read the message to obtain recipients from the <TT
CLASS="LITERAL"
>To:</TT
>, 
<TT
CLASS="LITERAL"
>Cc:</TT
>,
and <TT
CLASS="LITERAL"
>Bcc:</TT
> headers in the message instead of from the
command arguments.  If a 
<TT
CLASS="LITERAL"
>Bcc:</TT
> header is present, it is
removed from the message unless there is no <TT
CLASS="LITERAL"
>To:</TT
>
or <TT
CLASS="LITERAL"
>Cc:</TT
>
header, in which case a <TT
CLASS="LITERAL"
>Bcc:</TT
> header with no data is
created, in accordance with <A
HREF="#STD.RFC2822"
>RFC 2822:Internet Message Format</A
>.</P
><P
>If there are any operands, the recipients list is unspecified.</P
><P
>This option may be ignored when not in <TT
CLASS="PARAMETER"
><I
>-bm</I
></TT
> mode
(the default).</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is recommended that applications use as few options as
necessary, none if possible.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24522"
></A
><H2
>Exit status</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24525"
></A
><SPAN
STYLE="white-space: nowrap"
>0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>successful completion on all addresses.  This does not
indicate successful delivery.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24529"
></A
><SPAN
STYLE="white-space: nowrap"
>&#62;0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>there was an error.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="SH"
></A
>sh</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24536"
></A
><H2
>Name</H2
>sh&nbsp;--&nbsp;shell, the standard command language interpreter</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24539"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>sh</B
> utility shall behave as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
extensions listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="CMD-SH-INVOKE"
></A
><H2
>Shell Invocation</H2
><P
>The shell shall support an additional option, <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> 
(the letter <I
CLASS="EMPHASIS"
>ell</I
>).
If the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> option is specified, or if the first character
of argument zero (the command name) is a <TT
CLASS="LITERAL"
>'-'</TT
>, this invokation
of the shell is a <I
CLASS="EMPHASIS"
>login shell</I
>.</P
><P
>An interactive shell, as specified in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>,
that is also a login shell, or any shell if invoked with the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
>
option, shall, prior to reading from the input file,
first read and execute commands from the file
<TT
CLASS="FILENAME"
>/etc/profile</TT
>,
if that file exists, and then from a file called <TT
CLASS="FILENAME"
>~/.profile</TT
>,
if such a file exists.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification requires that the <B
CLASS="COMMAND"
>sh</B
> utility shall also read 
and execute commands in its current execution environment from all the shell scripts 
in the directory <TT
CLASS="FILENAME"
>/etc/profile.d</TT
>. Such scripts are read and executed
as a part of reading and executing <TT
CLASS="FILENAME"
>/etc/profile</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="SHUTDOWN"
></A
>shutdown</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24565"
></A
><H2
>Name</H2
>shutdown&nbsp;--&nbsp;shut the system down</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24568"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/sbin/shutdown</B
> [-t sec] [-h | -r] [-akfF]  time  [warning-message]<BR><B
CLASS="COMMAND"
>/sbin/shutdown</B
>  -c  [warning-message]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24582"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>shutdown</B
> command
shall shut the system down in a secure way (first synopsis), or cancel
a pending shutdown (second synopsis).  
When the shutdown is initiated, all logged-in users
shall be notified immediately that the system is going down, and users shall be
prevented from logging in to the system.
The <TT
CLASS="PARAMETER"
><I
>time</I
></TT
> specifies when the actual
shutdown shall commence. See below for details. At the specified time
all processes are first notified that the system is
going down by the signal <CODE
CLASS="CONSTANT"
>SIGTERM</CODE
>. After an interval
(see <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>) all processes shall be sent the signal
<CODE
CLASS="CONSTANT"
>SIGKILL</CODE
>.
If neither the <TT
CLASS="PARAMETER"
><I
>-h</I
></TT
> or the 
<TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> argument is specified, then the default behavior
shall be to take the system to a runlevel where administrative tasks can
be run. See also <A
HREF="#RUNLEVELS"
>Run Levels</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This is sometimes referred to as "single user mode".</P
></BLOCKQUOTE
></DIV
></P
><P
>The <TT
CLASS="PARAMETER"
><I
>-h</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> options
are mutually exclusive.
If either the <TT
CLASS="PARAMETER"
><I
>-h</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> options
are specified, the system shall be halted or rebooted respectively.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24600"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24603"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use access control. See below.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24607"
></A
><SPAN
STYLE="white-space: nowrap"
>-t sec</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>tell the system to wait <TT
CLASS="PARAMETER"
><I
>sec</I
></TT
> seconds between 
sending processes the warning
and the kill signal, before changing to another runlevel. The default
period is unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24612"
></A
><SPAN
STYLE="white-space: nowrap"
>-k</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not really shutdown; only send the warning messages to everybody.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24616"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reboot after shutdown.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24620"
></A
><SPAN
STYLE="white-space: nowrap"
>-h</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>halt after shutdown.  Actions after halting are unspecified (e.g. power off).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24624"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>advise the system to skip file system consistency checks on reboot.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24628"
></A
><SPAN
STYLE="white-space: nowrap"
>-F</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>advise the system to force file system consistency checks on reboot.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24632"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>cancel an already running <B
CLASS="COMMAND"
>shutdown</B
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24637"
></A
><SPAN
STYLE="white-space: nowrap"
>time</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specify when to shut down.</P
><P
>The time argument shall have the following format:
<TT
CLASS="CMDSYNOPSIS"
>[now | [+]mins | hh:mm]</TT
>
If the format is <TT
CLASS="LITERAL"
>hh:mm</TT
>, <TT
CLASS="LITERAL"
>hh</TT
>
shall specify the hour (1 or 2
digits) and <TT
CLASS="LITERAL"
>mm</TT
> is the minute of the hour 
(exactly two digits), and the shutdown shall commence at the next
occurence of the specified time.  
If the format is <TT
CLASS="LITERAL"
>mins</TT
> (or <TT
CLASS="LITERAL"
>+mins</TT
>),
where <TT
CLASS="LITERAL"
>mins</TT
> is a decimal number,
shutdown shall commence in the specified number of minutes.
The word <TT
CLASS="LITERAL"
>now</TT
> is an alias for <TT
CLASS="LITERAL"
>+0</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24656"
></A
><SPAN
STYLE="white-space: nowrap"
>warning-message</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specify a message to send to all users.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="REFSECT2"
><A
NAME="AEN24660"
></A
><H3
>Access Control</H3
><P
>If the <B
CLASS="COMMAND"
>shutdown</B
> utility is invoked with the
<TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option, it shall check that an
authorized user is currently logged in on the system console. Authorized users
are listed, one per line, in the file 
<TT
CLASS="FILENAME"
>/etc/shutdown.allow</TT
>. Lines in this file
that begin with a <TT
CLASS="LITERAL"
>'#'</TT
> or are blank shall be ignored.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The intent of this scheme is to allow a keyboard sequence entered on
the system console (e.g. <TT
CLASS="LITERAL"
>CTRL-ALT-DEL</TT
>, or 
<TT
CLASS="LITERAL"
>STOP-A</TT
>) to automatically invoke
<B
CLASS="COMMAND"
>shutdown -a</B
>, and can be used to prevent unauthorized users from shutting the
system down in this fashion.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="SU"
></A
>su</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24675"
></A
><H2
>Name</H2
>su&nbsp;--&nbsp;change user ID</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24678"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>su</B
> [options] [-] [username  [ARGS]]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24685"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>su</B
> command shall start a shell
running with the real and effective user and group IDs of
the user <TT
CLASS="PARAMETER"
><I
>username</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>username</I
></TT
> is not specified, 
<B
CLASS="COMMAND"
>su</B
> shall default to an unspecified user with
all appropriate privileges. If the <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> or 
<TT
CLASS="PARAMETER"
><I
>--shell</I
></TT
> is not specified, the shell to be invoked shall be that
specified for <TT
CLASS="PARAMETER"
><I
>username</I
></TT
> in the user database
(see <TT
CLASS="FUNCTION"
>getpwnam()</TT
>),
or <TT
CLASS="FILENAME"
>/bin/sh</TT
> if there is no shell specified
in the user database.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-</I
></TT
> option
is specified, or if the first operand is <TT
CLASS="LITERAL"
>-</TT
>, the 
environment for the shell shall be initialized as if the new shell was a login shell
(see <A
HREF="#CMD-SH-INVOKE"
>Shell Invocation</A
>).</P
><P
>If the invoking user does not have appropriate privileges, the <B
CLASS="COMMAND"
>su</B
>
command shall prompt for a password and validate this before continuing.
Invalid
passwords shall produce an error message.  
The <B
CLASS="COMMAND"
>su</B
> command shall log in an unspecified manner all invokations,
whether successful or unsuccessful.</P
><P
>Any operands specified after the <TT
CLASS="PARAMETER"
><I
>username</I
></TT
>
shall be passed to the invoked shell.</P
><P
>If the option <TT
CLASS="PARAMETER"
><I
>-</I
></TT
> is not specified, 
and if the first operand is not <TT
CLASS="LITERAL"
>-</TT
>,
the environemnt for the new shell shall be intialized from the current
environment. If none of the 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-p</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--preserve-environment</I
></TT
> 
options are specified, the environment 
may be modified in unspecified ways before invoking the shell.
If any of the 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-p</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--preserve-environment</I
></TT
> 
options are specified, the environment shall not be altered.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Although the <B
CLASS="COMMAND"
>su</B
> command shall not alter the
environment, the invoked shell may still alter it before it is ready
to intepret any commands.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24726"
></A
><H2
>Standard Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-</DT
><DD
><P
>the invoked shell shall be a login shell.</P
></DD
><DT
>-c <TT
CLASS="PARAMETER"
><I
>command</I
></TT
>, --command=<TT
CLASS="PARAMETER"
><I
>command</I
></TT
></DT
><DD
><P
>Invoke the shell with the option <TT
CLASS="LITERAL"
>-c <TT
CLASS="PARAMETER"
><I
>command</I
></TT
></TT
>.</P
></DD
><DT
>-m, -p, --preserve-environment</DT
><DD
><P
>The current environment shall be passed to the invoked shell. If the environment
variable <CODE
CLASS="ENVAR"
>SHELL</CODE
> is set, it shall specify the shell to invoke, if it matches
an entry in <TT
CLASS="FILENAME"
>/etc/shells</TT
>. If there is no matching entry in
<TT
CLASS="FILENAME"
>/etc/shells</TT
>, 
this option shall be ignored if the <TT
CLASS="PARAMETER"
><I
>-</I
></TT
> option is also specified, or if the
first operand is <TT
CLASS="LITERAL"
>-</TT
>.</P
></DD
><DT
>-s <TT
CLASS="PARAMETER"
><I
>shell</I
></TT
>, --shell=<TT
CLASS="PARAMETER"
><I
>shell</I
></TT
></DT
><DD
><P
>Invoke <TT
CLASS="PARAMETER"
><I
>shell</I
></TT
> as the comamnd interpreter.
The shell specified
shall be present in <TT
CLASS="FILENAME"
>/etc/shells</TT
>.</P
></DD
></DL
></DIV
></DIV
><H1
><A
NAME="SYNC"
></A
>sync</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24761"
></A
><H2
>Name</H2
>sync&nbsp;--&nbsp;flush file system buffers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24764"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>sync</B
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24767"
></A
><H2
>Description</H2
><P
>Force changed blocks to disk, update the super block.</P
></DIV
><H1
><A
NAME="TAR"
></A
>tar</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24773"
></A
><H2
>Name</H2
>tar&nbsp;--&nbsp;file archiver</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24776"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>tar</B
> is as specified in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24781"
></A
><H2
>Differences</H2
><P
>Some elements of the Pattern Matching Notation are optional;
see <A
HREF="#LOCALIZATION-GLOB"
>Internationalization and Pattern Matching Notation</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24786"
></A
><SPAN
STYLE="white-space: nowrap"
>-h</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>doesn't dump symlinks; dumps the files they point to.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24790"
></A
><SPAN
STYLE="white-space: nowrap"
>-z</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>filters the archive through <B
CLASS="COMMAND"
>gzip</B
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="UMOUNT"
></A
>umount</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24798"
></A
><H2
>Name</H2
>umount&nbsp;--&nbsp;unmount file systems</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24801"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>umount</B
> [-hV]<BR><B
CLASS="COMMAND"
>umount</B
>  -a  [-nrv] [-t vfstype]<BR><B
CLASS="COMMAND"
>umount</B
> [-nrv]  device | dir... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24816"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>umount</B
> detaches the file system(s) mentioned from the file
hierarchy.  A file system is specified by giving the directory where
it has been mounted.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24820"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24823"
></A
><SPAN
STYLE="white-space: nowrap"
>-v</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>invokes verbose mode.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24827"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>unmounts without writing in /etc/mtab.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24831"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>tries to remount read-only if unmounting fails.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24835"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>unmounts all of the file systems described in /etc/mtab except
for the proc file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24839"
></A
><SPAN
STYLE="white-space: nowrap"
>-t vfstype</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>indicates that the actions should only be taken on file systems of the
specified type.  More than one type may be specified in a comma
separated list.  The list of file system types can be prefixed with no
to specify the file system types on which no action should be taken.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24843"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>forces unmount (in case of an unreachable NFS system).</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24847"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24851"
></A
><SPAN
STYLE="white-space: nowrap"
>-V</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>print version and exits.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="USERADD"
></A
>useradd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24858"
></A
><H2
>Name</H2
>useradd&nbsp;--&nbsp;create a new user or update default new user information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24861"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>useradd</B
> [-c comment] [-d home_dir] [-g initial_group] [-G group...] [-m  [-k skeleton_dir]] [-p passwd] [-r] [-s shell] [-u uid  [-o]]  login <BR><B
CLASS="COMMAND"
>useradd</B
>  -D  [-g default_group] [-b default_home] [-s default_shell]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24882"
></A
><H2
>Description</H2
><P
>When invoked without the <TT
CLASS="PARAMETER"
><I
>-D</I
></TT
>
option, and with appropriate privilege, 
<B
CLASS="COMMAND"
>useradd</B
> creates a new
user account using the values specified on the command line and the
default values from the system.  The new user account will be entered
into the system files as needed, the home directory will be created,
and initial files copied, depending on the command line options.</P
><P
>When invoked with the <TT
CLASS="PARAMETER"
><I
>-D</I
></TT
>
option, <B
CLASS="COMMAND"
>useradd</B
> will either 
display the current default values, or,
with appropriate privilege, update the default values from 
the command line.  If no options are specified, <B
CLASS="COMMAND"
>useradd</B
> 
displays the current default values.</P
><P
>The <B
CLASS="COMMAND"
>useradd</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24894"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24897"
></A
><SPAN
STYLE="white-space: nowrap"
>-c comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the new user's password file comment field value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24901"
></A
><SPAN
STYLE="white-space: nowrap"
>-d home_dir</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates the new user using home_dir as the value for the
user's login directory.  The default is to append the login name to
default_home and use that as the login directory name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24905"
></A
><SPAN
STYLE="white-space: nowrap"
>-g initial_group</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the group name or number of the user's initial login group. 
The group name shall exist. A group number shall refer to an already 
existing group. If <TT
CLASS="PARAMETER"
><I
>-g</I
></TT
>
is not specified, the implementation will follow 
the normal user
default for that system. This may create a new group or choose a default
group that normal users are placed in. Applications which require control
of the groups into which a user is placed should specify 
<TT
CLASS="PARAMETER"
><I
>-g</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24911"
></A
><SPAN
STYLE="white-space: nowrap"
>-G group[,...]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies a list of supplementary groups which the user is also a member of.
Each group is separated from the next by a comma, with no intervening
whitespace.  The groups are subject to the same restrictions as the
group given with the 
<TT
CLASS="PARAMETER"
><I
>-g</I
></TT
> option.  The default is for the user to belong
only to the initial group.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24916"
></A
><SPAN
STYLE="white-space: nowrap"
>-m [-k skeleton_dir]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the user's home directory will be created if it does not exist. 
The files contained in <TT
CLASS="FILENAME"
>skeleton_dir</TT
>
will be copied to the home directory
if the <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
>
option is used, otherwise the files contained in 
<TT
CLASS="FILENAME"
>/etc/skel</TT
>
will be used instead.  Any directories contained in 
<TT
CLASS="FILENAME"
>skeleton_dir</TT
> or
<TT
CLASS="FILENAME"
>/etc/skel</TT
> 
will be created in the user's home directory as well.  The
<TT
CLASS="PARAMETER"
><I
>-k</I
></TT
> 
option is only valid in conjunction with the 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
> option.  The
default is to not create the directory and to not copy any files.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24927"
></A
><SPAN
STYLE="white-space: nowrap"
>-p passwd</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is the encrypted password, as returned by <TT
CLASS="FUNCTION"
>crypt()</TT
>.
The default is to
disable the account.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24932"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a system account, that is, a user with a
User ID in the range reserved for system account users. If there is not a
User ID free in the reserved range the command will fail.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24936"
></A
><SPAN
STYLE="white-space: nowrap"
>-s shell</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the name of the user's login shell.  The default is to leave this
field blank, which causes the system to select the default login
shell.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24940"
></A
><SPAN
STYLE="white-space: nowrap"
>-u uid [-o]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the numerical value of the user's ID.  This value shall be unique,
unless the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is used.  The value shall be non-negative.
The default is the smallest ID value greater than 499 which is not yet used. </P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24945"
></A
><H2
>Change Default Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24948"
></A
><SPAN
STYLE="white-space: nowrap"
>-b default_home</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the initial path prefix for a new user's home directory.  The user's
name will be affixed to the end of default_home to create the new
directory name if the -d option is not used when creating a new
account.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24952"
></A
><SPAN
STYLE="white-space: nowrap"
>-g default_group</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the group name or ID for a new user's initial group.  The named 
group shall exist, and a numerical group ID shall have an existing entry.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24956"
></A
><SPAN
STYLE="white-space: nowrap"
>-s default_shell</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the name of the new user's login shell.  The named program will be
used for all future new user accounts.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24960"
></A
><SPAN
STYLE="white-space: nowrap"
>-c comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the new user's password file comment field value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24964"
></A
><H2
>Application Usage</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>-D</I
></TT
> 
option will typically be used by system administration
packages.  Most applications should not change defaults which will
affect other applications and users.</P
></DIV
><H1
><A
NAME="USERDEL"
></A
>userdel</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24971"
></A
><H2
>Name</H2
>userdel&nbsp;--&nbsp;delete a user account and related files</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24974"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>userdel</B
> [-r]  login </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24979"
></A
><H2
>Description</H2
><P
>Delete the user account named <TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
>.  If there is also a group named
<TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
>, this command may
delete the group as well, or may leave it alone.</P
><P
>The <B
CLASS="COMMAND"
>userdel</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24987"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN24990"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>removes files in the user's home directory along with the home
directory itself.  Files located in other file system will have to be
searched for and deleted manually.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="USERMOD"
></A
>usermod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24997"
></A
><H2
>Name</H2
>usermod&nbsp;--&nbsp;modify a user account</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN25000"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>usermod</B
> [-c comment] [-d home_dir  [ -m]] [-g initial_group] [-G group [,...]] [-l login_name] [-p passwd] [-s shell] [-u uid  [ -o]]  login </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25015"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>usermod</B
> command shall modify an entry in the user
account database.</P
><P
>The <B
CLASS="COMMAND"
>usermod</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25022"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25025"
></A
><SPAN
STYLE="white-space: nowrap"
>-c comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the new value of the user's password file comment field.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25029"
></A
><SPAN
STYLE="white-space: nowrap"
>-d home_dir</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the user's new login directory.  If the -m option is given the
contents of the current home directory will be moved to the new home
directory, which is created if it does not already exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25033"
></A
><SPAN
STYLE="white-space: nowrap"
>-g initial_group</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the group name or number of the user's new initial login group. 
The group name shall exist.  A group number shall refer to an already
existing group.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25037"
></A
><SPAN
STYLE="white-space: nowrap"
>-G group,[...]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies a list of supplementary groups which the user is also a member of.
Each group is separated from the next by a comma, with no intervening
whitespace.  The groups are subject to the same restrictions as the
group given with the -g option.  If the user is currently a member of
a group which is not listed, the user will be removed from the group.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25041"
></A
><SPAN
STYLE="white-space: nowrap"
>-l login_name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>changes the name of the user from login to login_name.
Nothing else is changed.  In particular, the user's home directory
name should probably be changed to reflect the new login name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25045"
></A
><SPAN
STYLE="white-space: nowrap"
>-p passwd</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is the encrypted password, as returned by crypt(3).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25049"
></A
><SPAN
STYLE="white-space: nowrap"
>-s shell</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the name of the user's new login shell.  Setting this field to blank
causes the system to select the default login shell.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25053"
></A
><SPAN
STYLE="white-space: nowrap"
>-u uid [-o]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the numerical value of the user's ID.  This value shall be unique,
unless the -o option is used.  The value shall be non-negative.  Any
files which the user owns and which are located in the directory tree
rooted at the user's home directory will have the file user ID changed
automatically.  Files outside of the user's home directory shall be
altered manually.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="XARGS"
></A
>xargs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN25060"
></A
><H2
>Name</H2
>xargs&nbsp;--&nbsp;build and execute command lines from standard input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25063"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>xargs</B
> is as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25068"
></A
><H2
>Differences</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25072"
></A
><SPAN
STYLE="white-space: nowrap"
>-E</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25076"
></A
><SPAN
STYLE="white-space: nowrap"
>-I</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25080"
></A
><SPAN
STYLE="white-space: nowrap"
>-L</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These options have been implemented in <B
CLASS="COMMAND"
>findutils-4.2.9</B
>,
but this version of the utilities is not in widespread use as of
April 2005. However, future versions of this specification will require
support for these arguments.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCEXECENV"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VI. Execution Environment</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>16. <A
HREF="#EXECENVFHS"
>File System Hierarchy</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#DEV"
><TT
CLASS="FILENAME"
>/dev</TT
>: Device Files</A
></DT
><DT
>16.2. <A
HREF="#ETC"
><TT
CLASS="FILENAME"
>/etc</TT
>: Host-specific system configuration</A
></DT
><DD
><DL
><DT
>16.2.1. <A
HREF="#FHS-NAME-RULES"
>File Naming Conventions</A
></DT
></DL
></DD
><DT
>16.3. <A
HREF="#FHS-USER-ACCOUNTING-DBS"
>User Accounting Databases</A
></DT
><DT
>16.4. <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
></DT
></DL
></DD
><DT
>17. <A
HREF="#EXECSTUFF"
>Additional Recommendations</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#PERMISSIONS-SHOULD"
>Recommendations for applications on ownership and permissions</A
></DT
><DD
><DL
><DT
>17.1.1. <A
HREF="#PERMISSIONS-DIRWRITE"
>Directory Write Permissions</A
></DT
><DT
>17.1.2. <A
HREF="#PERMISSIONS-FILEWRITE"
>File Write Permissions</A
></DT
><DT
>17.1.3. <A
HREF="#PERMISSIONS-FILEREAD"
>File Read and execute Permissions</A
></DT
><DT
>17.1.4. <A
HREF="#PERMISSIONS-SBITS"
>SUID and SGID Permissions</A
></DT
><DT
>17.1.5. <A
HREF="#PRIVILEDGED-USERS"
>Privileged users</A
></DT
><DT
>17.1.6. <A
HREF="#CHANGING-PERMISSIONS"
>Changing permissions</A
></DT
><DT
>17.1.7. <A
HREF="#PERMISSION-MEDIA"
>Removable Media (Cdrom, Floppy, etc.)</A
></DT
><DT
>17.1.8. <A
HREF="#PERMISSION-INSTALLERS"
>Installable applications</A
></DT
></DL
></DD
></DL
></DD
><DT
>18. <A
HREF="#EXECENV-ADDNTL-BHVR"
>Additional Behaviors</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#AEN25313"
>Mandatory Optional Behaviors</A
></DT
><DD
><DL
><DT
>18.1.1. <A
HREF="#ADDL-BEHAVIORS-TEST"
>Special Requirements</A
></DT
></DL
></DD
></DL
></DD
><DT
>19. <A
HREF="#LOCALIZATION"
>Localization</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#AEN25424"
>Introduction</A
></DT
><DT
>19.2. <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
></DT
><DT
>19.3. <A
HREF="#LOCALIZATION-GLOB"
>Pattern Matching Notation</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="EXECENVFHS"
></A
>Chapter 16. File System Hierarchy</H1
><P
>An LSB conforming implementation shall provide the mandatory portions of the
file system hierarchy specified in the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> (FHS),
together with any additional requirements made in this specification.</P
><P
>An LSB conforming application shall conform to the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
>.</P
><P
>The FHS allows many components or subsystems to be optional. An application
shall check for the existence of an optional component before using it, and
should behave in a reasonable manner if the optional component is not
present.</P
><P
>The FHS requirement to locate the operating system kernel in either
<TT
CLASS="FILENAME"
>/</TT
> or <TT
CLASS="FILENAME"
>/boot</TT
> does not apply if
the operating system kernel does not exist as a file in the file system.</P
><P
>The FHS specifies certain behaviors for a variety of commands if they
are present (for example, <B
CLASS="COMMAND"
>ping</B
> or <B
CLASS="COMMAND"
>python</B
>).
However, LSB conforming applications
shall not rely on any commands beyond those specified by the LSB.  The
mere existence of a command may not be used as an indication that the
command behaves in any particular way.</P
><P
>The following directories or links need not be present:
<TT
CLASS="FILENAME"
>/etc/X11</TT
> 
<TT
CLASS="FILENAME"
>/usr/bin/X11</TT
>
<TT
CLASS="FILENAME"
>/usr/lib/X11</TT
>
<TT
CLASS="FILENAME"
>/proc</TT
></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEV"
>16.1. <TT
CLASS="FILENAME"
>/dev</TT
>: Device Files</A
></H2
><P
>The following shall exist under <TT
CLASS="FILENAME"
>/dev</TT
>. Other
devices may also exist in <TT
CLASS="FILENAME"
>/dev</TT
>. Device names may exist
as symbolic links to other device nodes located in <TT
CLASS="FILENAME"
>/dev</TT
> or
subdirectories of <TT
CLASS="FILENAME"
>/dev</TT
>.
There is no requirement concerning major/minor number values.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25116"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/dev/null</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An infinite data source and data sink. Data written to this device
shall be discarded. 
Reads from this device shall always return end-of-file (EOF).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25121"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/dev/zero</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This device is a source of zeroed out data. All data written to this device
shall be discarded. A read from this device shall 
always return the requested number of bytes, each initialized to the value '\0'.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25126"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/dev/tty</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In each process, a synonym for the controlling terminal associated
with the process group of that process, if any. 
All reads and writes to this device shall behave as if the actual controlling
terminal device had been opened.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="ETC"
>16.2. <TT
CLASS="FILENAME"
>/etc</TT
>: Host-specific system configuration</A
></H2
><P
>In addition to the requirements for <TT
CLASS="FILENAME"
>/etc</TT
> in the
<A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
>, an LSB conforming system shall also provide the
following directories or symbolic links to directories:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25138"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.d</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing extended <B
CLASS="COMMAND"
>crontab</B
> files;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25145"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.daily</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once a day;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25151"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.hourly</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once per hour;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25157"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.monthly</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once per month;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25163"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.weekly</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once a week;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25169"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/init.d</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing system initialization scripts;
see <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25175"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/profile.d</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts. 
Script names should follow the same conventions
as specified for cron jobs (see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>, but should
have the suffix <TT
CLASS="FILENAME"
>.sh</TT
>.
The behavior is unspecified if a script is installed in this directory that
does not have the suffix <TT
CLASS="FILENAME"
>.sh</TT
>.</P
><P
>The <B
CLASS="COMMAND"
>sh</B
> utility
shall read and execute commands in its current execution environment 
from all the shell scripts in this directory that have the suffix <TT
CLASS="FILENAME"
>.sh</TT
>
when invoked as an interactive login shell,
or if the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> (the letter <I
CLASS="EMPHASIS"
>ell</I
>)
is specified (see <A
HREF="#CMD-SH-INVOKE"
>Shell Invocation</A
>).</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Future Directions: </B
>These directories are required at this version of the LSB since there is not
yet an agreed method for abstracting the implementation so that applications
need not be aware of these locations during installation. However,
<A
HREF="#FUTURE-DIRECTIONS-ANNEX"
>Future Directions</A
>
describes a tool, <B
CLASS="COMMAND"
>lsbinstall</B
>, that will make these
directories implementation specific and no longer required.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FHS-NAME-RULES"
>16.2.1. File Naming Conventions</A
></H3
><P
>Conforming implemetnations and applications installing files into any of the above locations under
<TT
CLASS="FILENAME"
>/etc</TT
> may only use filenames
from the following managed namespaces:
<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>	Assigned names.  Such names must be chosen from
		the character set <TT
CLASS="LITERAL"
>[a-z0-9]</TT
>.
		In order to avoid conflicts these 
		names shall be reserved
		through the Linux Assigned Names and Numbers
		Authority (LANANA).
		Information about the LANANA
		may be found at
		<A
HREF="http://www.lanana.org"
TARGET="_top"
>www.lanana.org</A
>.
	</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>		Commonly used names should be reserved in advance; 
		developers for projects are encouraged to reserve names
		from LANANA, so that each distribution can use the same
		name, and to avoid conflicts with other projects.</P
></BLOCKQUOTE
></DIV
></LI
><LI
STYLE="list-style-type: disc"
><P
>	Hierarchical names.  Script names in this category take
		the form: 
		<TT
CLASS="FILENAME"
>&#60;hier1&#62;-&#60;hier2&#62;-...-&#60;name&#62;</TT
>,
		where name is taken from the character set 
		<TT
CLASS="LITERAL"
>[a-z0-9],</TT
> 
		and where there may be one or more 
		<TT
CLASS="FILENAME"
>&#60;hier-n&#62;</TT
> components.  
		<TT
CLASS="FILENAME"
>&#60;hier1&#62;</TT
> may either be an LSB provider name assigned
		by the LANANA, or
		it may be owners' DNS name in lower case, with at
		least one <TT
CLASS="LITERAL"
>'.'</TT
>.  
	e.g.  "<TT
CLASS="LITERAL"
>debian.org</TT
>", "<TT
CLASS="LITERAL"
>staroffice.sun.com</TT
>", etc.
		The LSB provider name assigned by LANANA 
		shall only consist of the ASCII characters <TT
CLASS="LITERAL"
>[a-z0-9]</TT
>.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>	Reserved names.  Names that
		begin with the character '<TT
CLASS="LITERAL"
>_</TT
>' are reserved for
		distribution use only.  These names should be used
		for essential system packages only.&#13;</P
></LI
></UL
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>A non-conforming application may still have polluted these managed
namespaces with unregistered filenames; a conforming application should check
for namespace collisions and take appropriate steps if they occur.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>In general, if a package or some system function is likely to be used
on multiple systems, the package developers or the distribution should
get a registered name through LANANA, and distributions should strive to
use the same name whenever possible.  For applications which may not
be essential or may not be commonly installed, the hierarchical namespace
may be more appropriate.  An advantage to the hierarchical namespace
is that there is no need to consult with the LANANA before obtaining an
assigned name.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Short names are highly desirable, since system
administrators may need to manually start and stop services.
Given this, they should be standardized on a per-package basis.  This
is the rationale behind having the LANANA organization assign these
names.  The LANANA may be called upon to handle other namespace issues,
such as package/prerequisites naming.</P
></BLOCKQUOTE
></DIV
>&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FHS-USER-ACCOUNTING-DBS"
>16.3. User Accounting Databases</A
></H2
><P
>The <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> specifies two optional locations for user
accounting databases 
used by the <TT
CLASS="FUNCTION"
>getutent()</TT
>, <TT
CLASS="FUNCTION"
>getutent_r()</TT
>, <TT
CLASS="FUNCTION"
>getutxent()</TT
>, <TT
CLASS="FUNCTION"
>getutxid()</TT
>, <TT
CLASS="FUNCTION"
>getutxline()</TT
>, and <TT
CLASS="FUNCTION"
>pututxline()</TT
> functions. These are
<TT
CLASS="FILENAME"
>/var/run/utmp</TT
> and <TT
CLASS="FILENAME"
>/var/run/wtmp</TT
>.</P
><P
>The LSB does not specify the format or structure of these files, or even if
they are files at all. They should be used only as "magic cookies" to
the <TT
CLASS="FUNCTION"
>utmpname()</TT
> function. </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FHS-SYSADMIN"
>16.4. Path For System Administration Utilities</A
></H2
><P
>Certain utilities used for system administration 
(and other privileged commands)
may be stored in 
<TT
CLASS="FILENAME"
>/sbin</TT
>, 
<TT
CLASS="FILENAME"
>/usr/sbin</TT
>, and 
<TT
CLASS="FILENAME"
>/usr/local/sbin</TT
>. Applications
requiring to use commands identified as system administration utilities
should add these directories to their 
<CODE
CLASS="ENVAR"
>PATH</CODE
>. By default, as described in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, standard utilities shall be found on the 
<CODE
CLASS="ENVAR"
>PATH</CODE
> returned
by <B
CLASS="COMMAND"
>getconf PATH</B
> (or <B
CLASS="COMMAND"
>command -p getconf PATH</B
>
to be guaranteed to invoke the correct version of <B
CLASS="COMMAND"
>getconf</B
>).</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="EXECSTUFF"
></A
>Chapter 17. Additional Recommendations</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="PERMISSIONS-SHOULD"
>17.1. Recommendations for applications on ownership and permissions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-DIRWRITE"
>17.1.1. Directory Write Permissions</A
></H3
><P
>The application should not depend on having directory write 
permission in any directory except 
<TT
CLASS="FILENAME"
>/tmp</TT
>, <TT
CLASS="FILENAME"
>/var/tmp</TT
>, and the invoking user's home directory.</P
><P
>In addition, the application may store variable data in 
<TT
CLASS="FILENAME"
>/var/opt/<TT
CLASS="REPLACEABLE"
><I
>package</I
></TT
></TT
>,
(where <TT
CLASS="REPLACEABLE"
><I
>package</I
></TT
> is the name of the 
application package), if such a directory is created with appropriate permissions during the package installation.</P
><P
>For these directories the application should be able to work 
with directory write permissions restricted by the 
<CODE
CLASS="CONSTANT"
>S_ISVTXT</CODE
> bit, implementing the restricted
deletion mode as described for the XSI option for <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>..</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-FILEWRITE"
>17.1.2. File Write Permissions</A
></H3
><P
>The application should not depend on file write permission to
any file that it does not itself create.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-FILEREAD"
>17.1.3. File Read and execute Permissions</A
></H3
><P
>The application should not depend on having read permission to
every file and directory.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-SBITS"
>17.1.4. SUID and SGID Permissions</A
></H3
><P
>The application should not depend on the set user ID or set group ID
(the <CODE
CLASS="CONSTANT"
>S_ISUID</CODE
> or <CODE
CLASS="CONSTANT"
>S_ISGID</CODE
>
permission bits)
permissions of a 
file not packaged with the application. Instead, the distribution is 
responsible for assuming that all system commands have the required 
permissions and work correctly.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>In order to implement common security policies it is strongly advisable
for applications to use the minimum set of security attributes necessary for
correct operation. Applications that require substantial appropriate privilege
are likely to cause problems with such security policies.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PRIVILEDGED-USERS"
>17.1.5. Privileged users</A
></H3
><P
>In general, applications should not depend on running as a privileged user.
This specification uses the term "appropriate privilege" throughout to identify
operations that cannot be achieved without some special granting of additional
privilege.</P
><P
>Applications that have a reason to run with appropriate privilege
should outline this reason clearly in their documentation.
Users of the application should be informed, that "this application 
demands security privileges, which could interfere with system security".</P
><P
>The application should not contain binary-only software that 
requires being run with appropriate privilege, as this makes security auditing 
harder or even impossible. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHANGING-PERMISSIONS"
>17.1.6. Changing permissions</A
></H3
><P
>The application shall not change permissions of files and 
directories that do not belong to its own package. 
Should an application require that certain files and directories
not directly belonging to the package have a particular ownership,
the application shall document this requirement, and may fail during
installation if the permissions on these files is inappropriate.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSION-MEDIA"
>17.1.7. Removable Media (Cdrom, Floppy, etc.)</A
></H3
><P
>Applications that expect to be runnable from removable
media should not depend on logging in as a privileged user,
and should be prepared to deal with a restrictive
environment.  Examples of such restrictions could be
default mount options that disable set-user/group-ID
attributes, disabling block or character-special files on
the medium, or remapping the user and group IDs of files away
from any privileged value.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>System vendors and local system administrators
want to run applications from removable media, but want the
possibility to control what the application can do.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSION-INSTALLERS"
>17.1.8. Installable applications</A
></H3
><P
>Where the installation of an application needs additional privileges, it must
clearly document all files and system databases that are modified outside of
those in 
<TT
CLASS="FILENAME"
>/opt/<TT
CLASS="REPLACEABLE"
><I
>pkg-name</I
></TT
></TT
>
and <TT
CLASS="FILENAME"
>/var/opt/<TT
CLASS="REPLACEABLE"
><I
>pkg-name</I
></TT
></TT
>,
other than those that may be
updated by system logging or auditing activities.
&#13;</P
><P
>Without this, the local system administrator 
would have to blindly trust a piece of software,
particularly with respect to its security.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="EXECENV-ADDNTL-BHVR"
></A
>Chapter 18. Additional Behaviors</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN25313"
>18.1. Mandatory Optional Behaviors</A
></H2
><P
>This section specifies behaviors in which there is optional
behavior in one of the standards on which the LSB relies, and where
the LSB requires a specific behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not require the kernel to be Linux; the set of mandated 
options reflects current existing practice, but may be modified in
future releases.</P
></BLOCKQUOTE
></DIV
></P
><P
>LSB conforming implementations shall support the following options defined
within the <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>_POSIX_FSYNC</TD
></TR
><TR
><TD
>_POSIX_MAPPED_FILES</TD
></TR
><TR
><TD
>_POSIX_MEMLOCK</TD
></TR
><TR
><TD
>_POSIX_MEMLOCK_RANGE</TD
></TR
><TR
><TD
>_POSIX_MEMORY_PROTECTION</TD
></TR
><TR
><TD
>_POSIX_PRIORITY_SCHEDULING</TD
></TR
><TR
><TD
>_POSIX_REALTIME_SIGNALS</TD
></TR
><TR
><TD
>_POSIX_THREAD_ATTR_STACKADDR</TD
></TR
><TR
><TD
>_POSIX_THREAD_ATTR_STACKSIZE</TD
></TR
><TR
><TD
>_POSIX_THREAD_PROCESS_SHARED</TD
></TR
><TR
><TD
>_POSIX_THREAD_SAFE_FUNCTIONS</TD
></TR
><TR
><TD
>_POSIX_THREADS</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>The <TT
CLASS="FUNCTION"
>opendir()</TT
>
function shall consume a file descriptor in the same
fashion as <TT
CLASS="FUNCTION"
>open()</TT
>, and therefore may fail with 
<CODE
CLASS="CONSTANT"
>EMFILE</CODE
> or <CODE
CLASS="CONSTANT"
>ENFILE</CODE
>.</P
><P
>The <CODE
CLASS="CONSTANT"
>START</CODE
> and 
<CODE
CLASS="CONSTANT"
>STOP</CODE
> <TT
CLASS="STRUCTNAME"
>termios</TT
>
characters shall be changeable, as
described as optional behavior in the "General Terminal Interface"
section of the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>.</P
><P
>The <TT
CLASS="FUNCTION"
>access()</TT
> function
function shall fail with <CODE
CLASS="VARNAME"
>errno</CODE
>
set to <CODE
CLASS="CONSTANT"
>EINVAL</CODE
> if the 
<TT
CLASS="PARAMETER"
><I
>amode</I
></TT
> argument contains bits other than 
those set by the bitwise inclusive OR of 
<CODE
CLASS="CONSTANT"
>R_OK</CODE
>, 
<CODE
CLASS="CONSTANT"
>W_OK</CODE
>, 
<CODE
CLASS="CONSTANT"
>X_OK</CODE
> and 
<CODE
CLASS="CONSTANT"
>F_OK</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>link()</TT
> function shall require access
to the existing file in
order to succeed, as described as optional behavior in the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></I
>.</P
><P
>Calling <TT
CLASS="FUNCTION"
>unlink()</TT
> on a directory shall fail.
Calling <TT
CLASS="FUNCTION"
>link()</TT
> specifying a directory as the first
argument shall fail.  See also <A
HREF="#BASELIB-UNLINK-3"
>unlink</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Linux allows <TT
CLASS="FUNCTION"
>rename()</TT
> on a directory without
having write access, but the LSB does not require this.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ADDL-BEHAVIORS-TEST"
>18.1.1. Special Requirements</A
></H3
><P
>LSB conforming systems shall enforce certain special additional restrictions
above and beyond those required by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These additional restrictions are required in order to support the testing
and certification programs associated with the LSB. In each case, these are values
that defined macros must not have; conforming applications that use these values
shall trigger a failure in the interface that is otherwise described as a "may fail".</P
></BLOCKQUOTE
></DIV
></P
><P
>The <TT
CLASS="FUNCTION"
>fcntl()</TT
> function shall treat the "cmd" value -1 as
invalid.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>whence</I
></TT
> value <CODE
CLASS="CONSTANT"
>-1</CODE
>
shall be an invalid value for the
<TT
CLASS="FUNCTION"
>lseek()</TT
>, <TT
CLASS="FUNCTION"
>fseek()</TT
> and 
<TT
CLASS="FUNCTION"
>fcntl()</TT
> functions.</P
><P
>The value <CODE
CLASS="CONSTANT"
>-5</CODE
> shall be an invalid signal number.</P
><P
>If the <TT
CLASS="FUNCTION"
>sigaddset()</TT
> or 
<TT
CLASS="FUNCTION"
>sigdelset()</TT
> functions are passed an
invalid signal number, they shall return with <SPAN
CLASS="ERRORNAME"
>EINVAL</SPAN
>.
Implementations
are only required to enforce this requirement for signal numbers which
are specified to be invalid by this specification (such as the <CODE
CLASS="CONSTANT"
>-5</CODE
>
mentioned above).</P
><P
>The mode value <CODE
CLASS="CONSTANT"
>-1</CODE
> to the <TT
CLASS="FUNCTION"
>access()</TT
>
function shall be treated as
invalid.</P
><P
>A value of <CODE
CLASS="CONSTANT"
>-1</CODE
> shall be an invalid "_PC_..." value for
<TT
CLASS="FUNCTION"
>pathconf()</TT
>.</P
><P
>A value of <CODE
CLASS="CONSTANT"
>-1</CODE
> shall be an invalid "_SC..." value for
<TT
CLASS="FUNCTION"
>sysconf()</TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>nl_item</I
></TT
> value <CODE
CLASS="CONSTANT"
>-1</CODE
>
shall be invalid for <TT
CLASS="FUNCTION"
>nl_langinfo()</TT
>.</P
><P
>The value <CODE
CLASS="CONSTANT"
>-1</CODE
> shall be an invalid "_CS_..." value for 
<TT
CLASS="FUNCTION"
>confstr()</TT
>.</P
><P
>The value <CODE
CLASS="CONSTANT"
>"a"</CODE
> shall be an invalid <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>
argument to <TT
CLASS="FUNCTION"
>popen()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>fcntl()</TT
> function shall fail and set <CODE
CLASS="VARNAME"
>errno</CODE
> to
<SPAN
CLASS="ERRORCODE"
>EDEADLK</SPAN
> if the
<TT
CLASS="PARAMETER"
><I
>cmd</I
></TT
> argument is <CODE
CLASS="CONSTANT"
>F_SETLKW</CODE
>,
and the lock is blocked by a lock from another process already blocked by the current process.</P
><P
>The <TT
CLASS="FUNCTION"
>opendir()</TT
> function shall consume a file descriptor;
the <TT
CLASS="FUNCTION"
>readdir()</TT
> function shall fail and set <CODE
CLASS="VARNAME"
>errno</CODE
>
to <SPAN
CLASS="ERRORCODE"
>EBADF</SPAN
> if the underlying file descriptor is closed.</P
><P
>The <TT
CLASS="FUNCTION"
>link()</TT
> function shall not work across file systems, and
shall fail and set <CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>EXDEV</SPAN
>
as described as optional behavior in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOCALIZATION"
></A
>Chapter 19. Localization</H1
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN25424"
>19.1. Introduction</A
></H2
><P
>In order to install a message catalog, the installation procedure 
shall supply the message catalog in a format readable by the
<B
CLASS="COMMAND"
>msgfmt</B
> utility, which shall be invoked to compile
the message catalog into an appropriate binary format on the target system.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The original intent was to allow an application to contain the binary
GNU MO format files. However, the format of these files is not
officially stable, hence it is necessary to compile these catalogs
on the target system. These binary catalogs
may differ from architecture to architecture
as well.</P
></BLOCKQUOTE
></DIV
>
The resulting binary message catalog shall be
located in the package's private area under <TT
CLASS="FILENAME"
>/opt</TT
>, and the
application may use <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> to specify this
location.</P
><P
>Implementations shall support the POSIX and C locales as specified in
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>. Other locales may be supported.</P
><P
>Implementations may define additional locale categories not defined by that standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Implementations choosing additional locale categories should be aware
of <A
HREF="#STD.TR14652"
>ISO/IEC TR14652</A
> and are advised not to choose names that conflict with that
specification. If implementations provide locale categories whose names
are part of the FDCC set of <A
HREF="#STD.TR14652"
>ISO/IEC TR14652</A
>, they should behave as defined by
that specification.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LOCALIZATION-REGEX"
>19.2. Regular Expressions</A
></H2
><P
>Utilities that process regular expressions shall support Basic
Regular Expressions and Extended Regular Expressions as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, with the following exceptions:</P
><P
>Range expression (such as <TT
CLASS="LITERAL"
>[a-z]</TT
>) can be based on code point
order instead of collating element order.</P
><P
>Equivalence class expression (such as <TT
CLASS="LITERAL"
>[=a=]</TT
>) and multi-character
collating element expression (such as <TT
CLASS="LITERAL"
>[.ch.]</TT
>) are optional.</P
><P
>Handling of a multi-character collating element is
optional.</P
><P
>This affects at least the following utilities: 
<P
></P
><UL
><LI
><P
><B
CLASS="COMMAND"
>awk</B
> (see <A
HREF="#AWK"
>awk</A
>)</P
></LI
><LI
><P
><B
CLASS="COMMAND"
>grep</B
> (see <A
HREF="#GREP"
>grep</A
>) (including <B
CLASS="COMMAND"
>egrep</B
>,
see <A
HREF="#EGREP"
>egrep</A
>)</P
></LI
><LI
><P
><B
CLASS="COMMAND"
>sed</B
>
(see <A
HREF="#SED"
>sed</A
>)</P
></LI
></UL
>
It also affects the behavior of interfaces in the base libraries, including
at least 
<P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>regexec()</TT
> (see <A
HREF="#BASELIB-REGEXEC-2"
>regexec</A
>)</P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LOCALIZATION-GLOB"
>19.3. Pattern Matching Notation</A
></H2
><P
>Utilities that perform filename pattern matching (also known as Filename
Globbing) shall do it as specified in 
<A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, Pattern Matching Notation,
with the following exceptions:</P
><P
>Pattern bracket expressions (such as 
<TT
CLASS="LITERAL"
>[a-z]</TT
>) can be based on code point
order instead of collating element order.</P
><P
>Equivalence class expression (such as <TT
CLASS="LITERAL"
>[=a=]</TT
>) and multi-character
collating element expression (such as <TT
CLASS="LITERAL"
>[.ch.]</TT
>) are optional.</P
><P
>Handling of a multi-character collating element is
optional.</P
><P
>This affects at least the following utilities: 
<B
CLASS="COMMAND"
>cpio</B
>
(<A
HREF="#CPIO"
>cpio</A
>), 
<B
CLASS="COMMAND"
>find</B
> (<A
HREF="#FIND"
>find</A
>) and
<B
CLASS="COMMAND"
>tar</B
> (<A
HREF="#TAR"
>tar</A
>).</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCSYSINIT"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VII. System Initialization</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>20. <A
HREF="#SYSINIT"
>System Initialization</A
></DT
><DD
><DL
><DT
>20.1. <A
HREF="#CRONJOBS"
>Cron Jobs</A
></DT
><DT
>20.2. <A
HREF="#INISCRPTACT"
>Init Script Actions</A
></DT
><DT
>20.3. <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
></DT
><DT
>20.4. <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
></DT
><DT
>20.5. <A
HREF="#RUNLEVELS"
>Run Levels</A
></DT
><DT
>20.6. <A
HREF="#FACILNAME"
>Facility Names</A
></DT
><DT
>20.7. <A
HREF="#SCRPTNAMES"
>Script Names</A
></DT
><DT
>20.8. <A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYSINIT"
></A
>Chapter 20. System Initialization</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="CRONJOBS"
>20.1. Cron Jobs</A
></H2
><P
>In addition to the individual user <TT
CLASS="FILENAME"
>crontab</TT
> files specified
by <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
> stored under <TT
CLASS="FILENAME"
>/var/spool/cron</TT
>,
the process that executes scheduled commands shall also process the following
additional <TT
CLASS="FILENAME"
>crontab</TT
> files:
<TT
CLASS="FILENAME"
>/etc/crontab</TT
>, <TT
CLASS="FILENAME"
>/etc/cron.d/*</TT
>.
The installation of a package shall not modify
the configuration file <TT
CLASS="FILENAME"
>/etc/crontab</TT
>.</P
><P
>If a package wishes to install a job that has to be executed periodically,
it shall place an executable <I
CLASS="FIRSTTERM"
>cron script</I
> in one of the
following directories:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.hourly</TT
></TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.daily</TT
></TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.weekly</TT
></TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.monthly</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
><P
>As these directory names suggest, the files within them are executed on a
hourly, daily, weekly, or monthly basis, respectively, under the control of an
entry in one of the system <TT
CLASS="FILENAME"
>crontab</TT
> files, at an
unspecified time of day.
See below for the rules concerning the names of cron scripts.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is recommended that cron scripts installed in any of these directories be
script files rather than compiled binaries so that they may be
modified by the local system administrator. Conforming applications
may only install cron scripts which use an interpreter required by
this specification or provided by this or another conforming application.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>This specification does not define the concept of a package
<I
CLASS="FIRSTTERM"
>upgrade</I
>. Implementations may do different
things when packages are upgraded, including not replacing a
cron script if it marked as a configuration file,
particularly if the cron script appears to have been modified since
installation.  In some circumstances, the cron script may
not be removed when the package is uninstalled. 
Applications should design their installation
procedure and cron scripts to be robust in the face of such
behavior.  In particular, cron scripts should not fail obscurely
if run in unexpected circumstances. Testing for the existence
of application binaries before executing them is suggested.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Future versions of this specification may remove the need to install
file directly into these directories, and instead abstract the interface
to the <B
CLASS="COMMAND"
>cron</B
> utility in such a way as to hide the 
implementation. Please see <A
HREF="#FUTURE-DIRECTIONS-ANNEX"
>Future Directions</A
>.</P
></BLOCKQUOTE
></DIV
><P
>If a certain task has to be executed at other than the predefined
frequencies, the package shall install a file
<TT
CLASS="FILENAME"
>/etc/cron.d/<TT
CLASS="REPLACEABLE"
><I
>cron-name</I
></TT
></TT
>.
The file shall have  the same format as that described for the 
<B
CLASS="COMMAND"
>crontab</B
> command in <A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
>, except that 
there shall be an additional field, <TT
CLASS="PARAMETER"
><I
>username</I
></TT
>, before
the name of the command to execute. For completeness, the seven fields shall
be:
<P
></P
><OL
TYPE="1"
><LI
><P
>Minute [0,59]</P
></LI
><LI
><P
>Hour [0,23]</P
></LI
><LI
><P
>Day of the month [1,31]</P
></LI
><LI
><P
>Month of the year [1,12]</P
></LI
><LI
><P
>Day of the week [0,6] (with 0=Sunday)</P
></LI
><LI
><P
>Username</P
></LI
><LI
><P
>command [args ...]</P
></LI
></OL
>

This file shall be processed by the system automatically, with the named
command being run at the specified time, as the specified username.</P
><P
>Applications installing files in these directories shall use the
LSB naming conventions (see <A
HREF="#FHS-NAME-RULES"
>File Naming Conventions</A
>).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INISCRPTACT"
>20.2. Init Script Actions</A
></H2
><P
>Conforming applications which need to execute commands on changes
to the system run level (including boot and shutdown),
may install one or more <I
CLASS="FIRSTTERM"
>init scripts</I
>.
Init scripts provided by conforming applications shall accept a single
argument which selects the action:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><B
CLASS="COMMAND"
>start</B
></TD
><TD
>start the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>stop</B
></TD
><TD
>stop the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>restart</B
></TD
><TD
>stop and restart the service if the service
is already running, otherwise start the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>try-restart</B
></TD
><TD
>restart the service if the service
is already running</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>reload</B
></TD
><TD
>cause the configuration of the service to be
reloaded without actually stopping and restarting the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>force-reload</B
></TD
><TD
>cause the configuration to be reloaded
if the service supports this, otherwise restart the service if it is
running</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>status</B
></TD
><TD
>print the current status of the service</TD
></TR
></TBODY
></TABLE
><P
></P
><P
>The <B
CLASS="COMMAND"
>start</B
>, <B
CLASS="COMMAND"
>stop</B
>, <B
CLASS="COMMAND"
>restart</B
>, <B
CLASS="COMMAND"
>force-reload</B
>, and <B
CLASS="COMMAND"
>status</B
> actions shall be supported
by all init scripts; the <B
CLASS="COMMAND"
>reload</B
> and the <B
CLASS="COMMAND"
>try-restart</B
> actions are optional. Other
init-script actions may be defined by the init script.</P
><P
>Init scripts shall ensure that they will behave sensibly if invoked
with <B
CLASS="COMMAND"
>start</B
> when the service is already running, or with <B
CLASS="COMMAND"
>stop</B
> when
not running, and that they do not kill similarly-named user processes. 
The best way to achieve this is to use the init-script functions provided by
<TT
CLASS="FILENAME"
>/lib/lsb/init-functions</TT
> (see 
<A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
>)</P
><P
>If a service reloads its configuration automatically (as in the case
of cron, for example), the <B
CLASS="COMMAND"
>reload</B
> action of the init
script shall behave as if the configuration was reloaded successfully.
The <B
CLASS="COMMAND"
>restart</B
>,
<B
CLASS="COMMAND"
>try-restart</B
>, <B
CLASS="COMMAND"
>reload</B
> and 
<B
CLASS="COMMAND"
>force-reload</B
> actions may be atomic; that is if a service
is known not to be operational after a restart or reload, the script may return
an error without any further action.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not define the concept of a package
<I
CLASS="FIRSTTERM"
>upgrade</I
>. Implementations may do different
things when packages are upgraded, including not replacing an
init script if it is marked as a configuration file,
particularly if the file appears to have been modified since
installation.  In some circumstances, the init script may
not be removed when the package is uninstalled. 
Applications should design their installation
procedure and init scripts to be robust in the face of such
behavior.  In particular, init scripts should not fail obscurely
if run in unexpected circumstances. Testing for the existence
of application binaries before executing them is suggested.</P
></BLOCKQUOTE
></DIV
><P
>If the <B
CLASS="COMMAND"
>status</B
> action is requested,
the init script will return the following 
exit status codes.  

<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>0</SPAN
></TD
><TD
>program is running or service is OK</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>1</SPAN
></TD
><TD
>program is dead and /var/run pid file exists</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>2</SPAN
></TD
><TD
>program is dead and /var/lock lock file exists</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>3</SPAN
></TD
><TD
>program is not running</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>4</SPAN
></TD
><TD
>program or service status is unknown</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>5-99</SPAN
></TD
><TD
>reserved for future LSB use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>100-149</SPAN
></TD
><TD
>reserved for distribution use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>150-199</SPAN
></TD
><TD
>reserved for application use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>200-254</SPAN
></TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>For all other init-script actions, the init
script shall return an exit status of zero if the action 
was successful.  Otherwise, the exit status shall
be non-zero, as defined below.  In addition to straightforward
success, the following situations are also to be considered
successful:

<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>restarting a service (instead of reloading it) with the <B
CLASS="COMMAND"
>force-reload</B
> argument</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>start</B
> on a service already running</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>stop</B
> on a service already stopped or not running</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>restart</B
> on a service already stopped or not running</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>try-restart</B
> on a service already stopped or not running</P
></LI
></UL
>&#13;</P
><P
>In case of an error while processing any init-script action except
for <B
CLASS="COMMAND"
>status</B
>, the init script shall print an error
message and exit with a non-zero status code:

<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>1</SPAN
></TD
><TD
>generic or unspecified error (current practice)</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>2</SPAN
></TD
><TD
>invalid or excess argument(s)</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>3</SPAN
></TD
><TD
>unimplemented feature (for example, "reload")</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>4</SPAN
></TD
><TD
>user had insufficient privilege</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>5</SPAN
></TD
><TD
>program is not installed</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>6</SPAN
></TD
><TD
>program is not configured</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>7</SPAN
></TD
><TD
>program is not running</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>8-99</SPAN
></TD
><TD
>reserved for future LSB use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>100-149</SPAN
></TD
><TD
>reserved for distribution use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>150-199</SPAN
></TD
><TD
>reserved for application use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>200-254</SPAN
></TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>Error and status messages should be printed with the logging
functions (see <A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
>) 
<TT
CLASS="FUNCTION"
>log_success_msg()</TT
>,
<TT
CLASS="FUNCTION"
>log_failure_msg()</TT
> and 
<TT
CLASS="FUNCTION"
>log_warning_msg()</TT
>.
Scripts may write to
standard error or standard output, but implementations need not
present text written to standard error/output to the user or do
anything else with it.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Since init scripts may be run manually by a system administrator with
non-standard environment variable values for <CODE
CLASS="ENVAR"
>PATH</CODE
>, 
<CODE
CLASS="ENVAR"
>USER</CODE
>, <CODE
CLASS="ENVAR"
>LOGNAME</CODE
>, etc., 
init scripts should not depend on the values of these environment
variables.  They should set them to some known/default values if they
are needed.&#13;</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INITSCRCOMCONV"
>20.3. Comment Conventions for Init Scripts</A
></H2
><P
>Conforming applications may install one or more init scripts.
These init scripts must be activated by invoking the
<B
CLASS="COMMAND"
>install_initd</B
> command.
Prior to package removal, the changes applied by
<B
CLASS="COMMAND"
>install_initd</B
> must be undone by
invoking <B
CLASS="COMMAND"
>remove_initd</B
>.
See <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
> for more details.</P
><P
> 
<B
CLASS="COMMAND"
>install_initd</B
> and <B
CLASS="COMMAND"
>remove_initd</B
>
determine actions to take by decoding a specially formatted
block of lines in the script. This block shall be delimited
by the lines 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>### BEGIN INIT INFO
### END INIT INFO</PRE
></TD
></TR
></TABLE
>
The delimiter lines may contain trailing whitespace, which shall be
ignored.  All lines inside the block shall begin with a hash
character <TT
CLASS="LITERAL"
>'#'</TT
> in the first column, so the shell
interprets them as comment lines which do not affect operation of
the script. The lines shall be of the form:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># {keyword}: arg1 [arg2...]</PRE
></TD
></TR
></TABLE
>
with exactly one space character between the <TT
CLASS="LITERAL"
>'#'</TT
>
and the keyword, with a single exception.  In lines following a
line containing the <B
CLASS="COMMAND"
>Description</B
> keyword, and until the
next keyword or block ending delimiter is seen,
a line where the <TT
CLASS="LITERAL"
>'#'</TT
>
is followed by more than one space or a tab character
shall be treated as a continuation of the previous line.</P
><P
>The information extracted from the block is used by the
installation tool or the init-script system to assure
that init scripts are run in the correct order.   
It is unspecified whether the information is evaluated
only when <B
CLASS="COMMAND"
>install_initd</B
> runs, when
the init scripts are executed, or both. The information
extracted includes run levels, defined in <A
HREF="#RUNLEVELS"
>Run Levels</A
>,
and boot facilities, defined in <A
HREF="#FACILNAME"
>Facility Names</A
>.</P
><P
>The following keywords, with their arguments, are defined:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Provides:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>boot facilities provided by this init script.
When an init script is run with a <B
CLASS="COMMAND"
>start</B
> argument,
the boot facility or facilities specified by the 
<B
CLASS="COMMAND"
>Provides</B
> keyword shall be deemed present
and hence init scripts which require those boot facilities
should be started later.  When an init script is run with a 
<B
CLASS="COMMAND"
>stop</B
> argument, the boot facilities specified by
the <B
CLASS="COMMAND"
>Provides</B
> keyword are deemed  no longer present.  </P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Required-Start:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which must be available during startup of this service.
The init-script system should insure init scripts which
provide the <B
CLASS="COMMAND"
>Required-Start</B
> facilities
are started before starting this script.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Required-Stop:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which must
be available during the shutdown of this service.  The
init-script system should avoid stopping init scripts which provide
the <B
CLASS="COMMAND"
>Required-Stop</B
>
facilities until this script is stopped.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Should-Start:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which, if present, should
be available during startup of this service. This allows for weak dependencies
which do not cause the service to fail if a facility is not available.
The service may provide reduced functionality in this situation.
Conforming applications should not rely on the existence of this feature.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Should-Stop:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which should be available during shutdown of this service.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Default-Start:</B
>  run_level_1  [run_level_2...]</TT
>, <TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Default-Stop:</B
>  run_level_1  [run_level_2...]</TT
></DT
><DD
><P
>which run levels should by default run the init script with a 
<B
CLASS="COMMAND"
>start</B
> (<B
CLASS="COMMAND"
>stop</B
>) argument
to start (stop) the services controlled by the init script.
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN25772"
></A
><P
>For example, if a service should run in runlevels 3, 4, and 5 only,
specify "Default-Start: 3 4 5" and "Default-Stop: 0 1 2 6".</P
><P
></P
></DIV
></P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Short-Description:</B
>  short_description </TT
></DT
><DD
><P
>provide a brief description of the actions of the init script.
Limited to a single line of text.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Description:</B
>  multiline_description </TT
></DT
><DD
><P
>provide a more complete description of the actions of the init script.
May span mulitple lines.  In a multiline description,
each continuation line shall begin with a '#' followed by tab character
or a '#' followed by at least two space characters.  The multiline
description is terminated by the first line that does not match this
criteria.</P
></DD
></DL
></DIV
><P
>Additional keywords may be defined in future versions of
this specification. Also, implementations 
may define local extensions by using the prefix
<B
CLASS="COMMAND"
>X-<TT
CLASS="REPLACEABLE"
><I
>implementor</I
></TT
></B
>.
For example, <B
CLASS="COMMAND"
>X-RedHat-foobardecl</B
>, or 
<B
CLASS="COMMAND"
>X-Debian-xyzzydecl</B
>.  </P
><P
>Example:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN25794"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	### BEGIN INIT INFO
	# Provides: lsb-ourdb
	# Required-Start: $local_fs $network $remote_fs
	# Required-Stop: $local_fs $network $remote_fs
	# Default-Start:  2 3 4 5
	# Default-Stop: 0 1 6
	# Short-Description: start and stop OurDB
	# Description: OurDB is a very fast and reliable database
	#	 engine used for illustrating init scripts
	### END INIT INFO</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>The comment conventions described in this section are only required for
init scripts installed by conforming applications. Conforming
runtime implementations are not required to use this scheme in their system
provided init scripts.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not require, but is designed to allow, the
development of a system which runs init scripts in parallel.  Hence,
enforced-serialization of scripts is avoided unless it is explicitly
necessary. </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INITSRCINSTRM"
>20.4. Installation and Removal of Init Scripts</A
></H2
><P
>Conforming applications may install one or more initialization scripts
(or <I
CLASS="EMPHASIS"
>init scripts</I
>).
An init script shall be installed in <TT
CLASS="FILENAME"
>/etc/init.d</TT
>
(which may be a symbolic link to another location), by the package
installer.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The requirement to install scripts
in <TT
CLASS="FILENAME"
>/etc/init.d</TT
> may be removed in future versions of this
specification. See <A
HREF="#ETC"
>Host-specific system configuration</A
> and <A
HREF="#FUTURE-DIRECTIONS-ANNEX"
>Future Directions</A
>
for further details.</P
></BLOCKQUOTE
></DIV
></P
><P
>During the installer's post-install processing phase the program
<B
CLASS="COMMAND"
>/usr/lib/lsb/install_initd</B
> must be called to
activate the init script. Activation consists of arranging for
the init script to be called in the correct order on system
run-level changes (including system boot and shutdown), based on
dependencies supplied in the init script (see <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
>).
The <B
CLASS="COMMAND"
>install_initd</B
> command should be thought of as
a wrapper which hides the implementation details;
how any given implementation arranges for the init
script to be called at the appropriate time is not specified.</P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN25813"
></A
><A
NAME="AEN25814"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Example: if an init script specified 
"Default-Start: 3 4 5" and "Default-Stop: 0 1 2 6",
<B
CLASS="COMMAND"
>install_initd</B
> might create
"start" symbolic links with names starting with 'S' in 
<TT
CLASS="FILENAME"
>/etc/rc3.d</TT
>,
<TT
CLASS="FILENAME"
>/etc/rc4.d</TT
> and
<TT
CLASS="FILENAME"
>/etc/rc5.d</TT
>
and "stop" symbolic links with names starting with 'K' in
<TT
CLASS="FILENAME"
>/etc/rc0.d</TT
>,
<TT
CLASS="FILENAME"
>/etc/rc1.d</TT
>,
<TT
CLASS="FILENAME"
>/etc/rc2.d</TT
> and
<TT
CLASS="FILENAME"
>/etc/rc6.d</TT
>. Such
a scheme would be similar to the System V Init
mechanism, but is by no means the only way
this specification could be implemented.</P
></BLOCKQUOTE
><P
></P
></DIV
><P
>The <B
CLASS="COMMAND"
>install_initd</B
> command takes a single argument, the full pathname
of the installed init script. The init script must already be installed
in <TT
CLASS="FILENAME"
>/etc/init.d</TT
>.
The <B
CLASS="COMMAND"
>install_initd</B
> command will not copy it there, only activate
it once it has been installed.
For example:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN25828"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	/usr/lib/lsb/install_initd /etc/init.d/example.com-coffeed</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>The <B
CLASS="COMMAND"
>install_initd</B
> command
shall return an exit status of zero if the
init-script activation was successful or if the init script was
already activated. If the dependencies in the init script 
(see <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
>)  cannot be met, 
an exit status of one shall be returned and the init script shall not be
activated.</P
><P
> 
When a software package is removed, <B
CLASS="COMMAND"
>/usr/lib/lsb/remove_initd</B
>
must be called to deactivate the init script. This must occur
before the init script itself is removed, as the dependency
information in the script may be required for successful completion.
Thus the installer's pre-remove processing phase must call
<B
CLASS="COMMAND"
>remove_initd</B
>, and pass the full pathname of
the installed init script.
The package installer is still responsible for removing 
the init script.
For example:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN25836"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	/usr/lib/lsb/remove_initd /etc/init.d/example.com-coffeed</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>The <B
CLASS="COMMAND"
>remove_initd</B
> program shall return an exit status
of zero if the init script has been successfully deactivated or if the
init script is not activated. If another init script which depends
on a boot facility provided by this init script is activated,
an exit status of one shall be returned and the init script shall
remain activated. The installer must fail on such an exit code
so it does not subsequently remove the init script.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not describe a mechanism for the system
administrator to manipulate the run levels at which an init script
is started or stopped. There is no assurance that modifying the
comment block for this purpose will have the desired effect.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="RUNLEVELS"
>20.5. Run Levels</A
></H2
><P
>The following <I
CLASS="FIRSTTERM"
>run levels</I
> are specified for use by the 
<B
CLASS="COMMAND"
>Default-Start</B
> and <B
CLASS="COMMAND"
>Default-Stop</B
> 
actions defined in <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
> as hints
to the <B
CLASS="COMMAND"
>install_initd</B
> command.
Conforming implementations are not required to provide these exact
run levels or give them the meanings described here,
and may map any level described here to a different level which
provides the equivalent functionality. Applications may not depend
on specific run-level numbers.</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>0</TD
><TD
>halt</TD
></TR
><TR
><TD
>1</TD
><TD
>single user mode</TD
></TR
><TR
><TD
>2</TD
><TD
>multiuser with no network services exported</TD
></TR
><TR
><TD
>3</TD
><TD
>normal/full multiuser</TD
></TR
><TR
><TD
>4</TD
><TD
>reserved for local use, default is normal/full multiuser</TD
></TR
><TR
><TD
>5</TD
><TD
>multiuser with a display manager or equivalent</TD
></TR
><TR
><TD
>6</TD
><TD
>reboot</TD
></TR
></TBODY
></TABLE
><P
></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These run levels were chosen as reflecting the most frequent existing
practice, and in the absence of other considerations, implementors are
strongly encouraged to follow this convention to provide consistency
for system administrators who need to work with multiple distributions.  </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FACILNAME"
>20.6. Facility Names</A
></H2
><P
>Boot <I
CLASS="FIRSTTERM"
>facilities</I
> are used to indicate dependencies
in initialization scripts, as defined in <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
>. 
Facility names
are assigned to scripts by the <B
CLASS="COMMAND"
>Provides:</B
> keyword.
Facility names that begin with a
dollar sign (<TT
CLASS="LITERAL"
>'$'</TT
>) are reserved system facility names.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Facility names are only recognized in the context of the
init script comment block and are not available in the body of
the init script. In particular, the use of the leading '$' character
does not imply system facility names are subject to shell variable
expansion, since they appear inside comments.</P
></BLOCKQUOTE
></DIV
>
Conforming applications shall not provide facilities that begin with a dollar
sign.  Implementations shall provide the following facility names:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25877"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$local_fs</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>all local file systems are mounted</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25882"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$network</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>basic networking support is available. Example:
a server program could listen on a socket.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25887"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$named</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>IP name-to-address translation, using the interfaces
described in this specification, are available to the level
the system normally provides them. Example: if a DNS
query daemon normally provides this facility, then that
daemon has been started. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25892"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$portmap</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>daemons providing SunRPC/ONCRPC portmapping 
service as defined in <A
HREF="#STD.RFC1833"
>RFC 1833: Binding Protocols for ONC RPC Version 2</A
>
(if present) are running.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25898"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$remote_fs</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>all remote file systems are available. In some
configurations, file systems such as <TT
CLASS="FILENAME"
>/usr</TT
>
may be remote.  Many
applications that require <B
CLASS="COMMAND"
>$local_fs</B
> will probably
also require <B
CLASS="COMMAND"
>$remote_fs</B
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25906"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$syslog</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>system logger is operational.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN25911"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$time</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the system time has been set,
for example by using a network-based time program such as 
<B
CLASS="COMMAND"
>ntp</B
> or 
<B
CLASS="COMMAND"
>rdate</B
>, or 
via the hardware Real Time Clock.</P
></TD
></TR
></TBODY
></TABLE
><P
>Other (non-system) facilities may be defined by other conforming applications.
These facilities shall be named using the same conventions defined for
naming init scripts (see <A
HREF="#SCRPTNAMES"
>Script Names</A
>).
Commonly, the facility provided by a conforming init script will have
the same name as the name assigned to the init script.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SCRPTNAMES"
>20.7. Script Names</A
></H2
><P
>Since init scripts live in a single directory, they must
share a single namespace. To avoid conflicts, 
applications installing files in this directories shall use the
LSB naming conventions (see <A
HREF="#FHS-NAME-RULES"
>File Naming Conventions</A
>).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INISCRPTFUNC"
>20.8. Init Script Functions</A
></H2
><P
>Each conforming init script shall execute the commands in the file
<TT
CLASS="FILENAME"
>/lib/lsb/init-functions</TT
> in the 
current environment (see shell special built-in command <B
CLASS="COMMAND"
>dot</B
>).
This file shall cause the
following shell script commands to be defined in an unspecified manner.  
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This can be done either by
adding a directory to the 
<CODE
CLASS="ENVAR"
>PATH</CODE
> variable which defines these commands, or by
defining shell aliases or functions.  </P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Although the commands made available via this mechanism need not
be conforming applications in their own right, applications that
use them should only depend on features described in this specification.</P
></BLOCKQUOTE
></DIV
>
Conforming scripts
shall not specify the "exit on error" option (i.e. 
<B
CLASS="COMMAND"
>set -e</B
>) when sourcing this file, or calling any of the
commands thus made available. </P
><P
>The <B
CLASS="COMMAND"
>start_daemon</B
>, <B
CLASS="COMMAND"
>killproc</B
> and
<B
CLASS="COMMAND"
>pidofproc</B
> functions shall use 
the following algorithm for determining
the status and the process identifiers of the specified program. 
<P
></P
><OL
TYPE="1"
><LI
><P
>If the <TT
CLASS="PARAMETER"
><I
>-p pidfile</I
></TT
> option is specified,
and the named <TT
CLASS="FILENAME"
>pidfile</TT
> exists,
a single line at the start of the <TT
CLASS="FILENAME"
>pidfile</TT
> shall be read. 
If this line contains one or more numeric values, separated by spaces,
these values shall be used.
If the <TT
CLASS="PARAMETER"
><I
>-p pidfile</I
></TT
> option is specified and the named 
<TT
CLASS="FILENAME"
>pidfile</TT
> does not exist, the functions
shall assume that the daemon is not running.</P
></LI
><LI
><P
>Otherwise, 
<TT
CLASS="FILENAME"
>/var/run/<TT
CLASS="REPLACEABLE"
><I
>basename</I
></TT
>.pid</TT
> 
shall be read in a similar fashion.
If this contains one or more numeric values on the first line, these values
shall be used.
Optionally, implementations may use unspecified additional
methods to locate the process identifiers required.</P
></LI
></OL
>
The method used
to determine the status is implementation defined, but should allow for
non-binary programs.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Commonly used methods check either for the
existence of the <TT
CLASS="FILENAME"
>/proc/pid</TT
> directory or use
<TT
CLASS="FILENAME"
>/proc/pid/exe</TT
> and <TT
CLASS="FILENAME"
>/proc/pid/cmdline</TT
>.
Relying only on <TT
CLASS="FILENAME"
>/proc/pid/exe</TT
> is discouraged since this
specification does not specify the existence of, or semantics
for, <TT
CLASS="FILENAME"
>/proc</TT
>. Additionally, using
<TT
CLASS="FILENAME"
>/proc/pid/exe</TT
>
may result in a not-running status for daemons that are written in a script
language.</P
></BLOCKQUOTE
></DIV
>
Conforming implementations may use other mechanisms besides those based on
pidfiles, unless the <TT
CLASS="PARAMETER"
><I
>-p pidfile</I
></TT
>
option has been used. Conforming applications
should not rely on such mechanisms and should
always use a <TT
CLASS="FILENAME"
>pidfile</TT
>.
When a program is stopped, it should delete its
<TT
CLASS="FILENAME"
>pidfile</TT
>. Multiple process identifiers
shall be separated by a single space in the <TT
CLASS="FILENAME"
>pidfile</TT
>
and in the output of <B
CLASS="COMMAND"
>pidofproc</B
>.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>start_daemon</B
> [-f] [-n nicelevel] [-p pidfile]  pathname  [args...]</TT
></DT
><DD
><P
>runs the specified program as a daemon.
The <B
CLASS="COMMAND"
>start_daemon</B
> function
shall check if the program is already running
using the algorithm given above. If so, it shall not
start another copy of the daemon unless the <TT
CLASS="PARAMETER"
><I
>-f</I
></TT
>
option is given. The <TT
CLASS="PARAMETER"
><I
>-n</I
></TT
> option specifies a nice
level. See <B
CLASS="COMMAND"
>nice</B
>.
<B
CLASS="COMMAND"
>start_daemon</B
> shall
return the LSB defined exit status codes. It
shall return 0 if the program has been successfully started or
is running and not 0 otherwise.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>killproc</B
> [-p pidfile]  pathname  [signal]</TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>killproc</B
> function
shall stop the specified program. The program is 
found using the algorithm given above. If a
signal is specified, using the
<TT
CLASS="PARAMETER"
><I
>-<TT
CLASS="REPLACEABLE"
><I
>signal_name</I
></TT
></I
></TT
> or
<TT
CLASS="PARAMETER"
><I
>-<TT
CLASS="REPLACEABLE"
><I
>signal_number</I
></TT
></I
></TT
> syntaxes
as specified by the <B
CLASS="COMMAND"
>kill</B
> command,
the program is sent that signal.
Otherwise, a <CODE
CLASS="CONSTANT"
>SIGTERM</CODE
> followed by a 
<CODE
CLASS="CONSTANT"
>SIGKILL</CODE
>
after an unspecified number of seconds shall be sent.
If a program has been terminated, the <TT
CLASS="FILENAME"
>pidfile</TT
>
should be removed if the
terminated process has not already done so.
The <B
CLASS="COMMAND"
>killproc</B
> function
shall return the LSB defined exit status codes. If called
without a signal, it shall return 0 if the program has been stopped or
is not running and not 0 otherwise. If a signal is given, it shall return 0
only if the program is running. </P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>pidofproc</B
> [-p pidfile]  pathname </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>pidofproc</B
> function shall return
one or more process identifiers for a particular
daemon using the algorithm given above. Only process identifiers
of running processes should be returned.
Multiple process identifiers shall be separated by a single space.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>A process may exit between <B
CLASS="COMMAND"
>pidofproc</B
> discovering its identity
and the caller of <B
CLASS="COMMAND"
>pidofproc</B
> being able to act on that identity.
As a result, no test assertion can be made that the process identifiers
returned by <B
CLASS="COMMAND"
>pidofproc</B
> <I
CLASS="EMPHASIS"
>shall</I
> be
running processes.</P
></BLOCKQUOTE
></DIV
>
The <B
CLASS="COMMAND"
>pidofproc</B
> function
shall return the LSB defined exit status
codes for "status". It shall return 0 if the program is
running and not 0 otherwise.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>log_success_msg</B
>  message </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>log_success_msg</B
> function
shall cause the system to write a success
message to an unspecified log file. The format of the message is
unspecified.
The <B
CLASS="COMMAND"
>log_success_msg</B
> function
may also write a message to the standard output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The message should be relatively short; no
more than 60 characters is highly desirable.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>log_failure_msg</B
>  message </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>log_failure_msg</B
> function
shall cause the system to write a failure
message to an unspecified log file. The format of the message is
unspecified.
The <B
CLASS="COMMAND"
>log_failure_msg</B
> function
may also write a message to the standard output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The message should be relatively short; no
more than 60 characters is highly desirable.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>log_warning_msg</B
>  message </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>log_warning_msg</B
> function
shall cause the system to write a warning
message to an unspecified log file. The format of the message is
unspecified.
The <B
CLASS="COMMAND"
>log_warning_msg</B
> function
may also write a message to the standard output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The message should be relatively short; no
more than 60 characters is highly desirable.</P
></BLOCKQUOTE
></DIV
></P
></DD
></DL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCUSERSGROUPS"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VIII. Users &#38; Groups</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>21. <A
HREF="#USERSGROUPS"
>Users &#38; Groups</A
></DT
><DD
><DL
><DT
>21.1. <A
HREF="#USERGRPDATABASE"
>User and Group Database</A
></DT
><DT
>21.2. <A
HREF="#USERNAMES"
>User &#38; Group Names</A
></DT
><DT
>21.3. <A
HREF="#UIDRANGE"
>User ID Ranges</A
></DT
><DT
>21.4. <A
HREF="#USERGRPRAT"
>Rationale</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="USERSGROUPS"
></A
>Chapter 21. Users &#38; Groups</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="USERGRPDATABASE"
>21.1. User and Group Database</A
></H2
><P
>The format of the User and Group databases is not specified. Programs may only
read these databases using the provided API. Changes to these databases should
be made using the provided commands.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="USERNAMES"
>21.2. User &#38; Group Names</A
></H2
><P
><A
HREF="#TBL-REQUIREDUSERS"
>Table 21-1</A
> describes required mnemonic user and group names.   This 
specification makes no attempt to numerically assign user or group identity numbers,
with the exception that both the User ID and Group ID for the user <TT
CLASS="LITERAL"
>root</TT
>
shall be equal to 0.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-REQUIREDUSERS"
></A
><P
><B
>Table 21-1. Required User &#38; Group Names</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>User</TH
><TH
>Group</TH
><TH
>Comments</TH
></TR
></THEAD
><TBODY
><TR
><TD
>root</TD
><TD
>root</TD
><TD
>Administrative user
with all appropriate privileges</TD
></TR
><TR
><TD
>bin</TD
><TD
>bin</TD
><TD
>Legacy User ID/Group ID<A
NAME="AEN26077"
HREF="#FTN.AEN26077"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
></TD
></TR
><TR
><TD
>daemon</TD
><TD
>daemon</TD
><TD
>Legacy User ID/Group ID<A
NAME="AEN26085"
HREF="#FTN.AEN26085"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
></TD
></TR
></TBODY
><TR
><TD
COLSPAN="3"
>Notes:<BR><A
NAME="FTN.AEN26077"
>a. </A
>The <TT
CLASS="LITERAL"
>bin</TT
> User ID/Group ID is included for compatibility with legacy applications.
New applications should no longer use the <TT
CLASS="LITERAL"
>bin</TT
> User ID/Group ID.<BR><A
NAME="FTN.AEN26085"
>b. </A
>The <TT
CLASS="LITERAL"
>daemon</TT
> User ID/Group ID was used as an unprivileged User ID/Group ID for daemons to
execute under in order to limit their access to the system.  Generally
daemons should now run under individual User ID/Group IDs in order to further
partition daemons from one another.<BR></TD
></TR
></TABLE
></DIV
><P
></P
><P
><A
HREF="#TBL-OPTUSERS"
>Table 21-2</A
> is a table of optional mnemonic user and group names.   This 
specification makes no attempt to numerically assign uid or gid numbers.
If the username exists on a system, then they should be in the suggested
corresponding group.
These user and group names are for use by distributions, not by applications.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-OPTUSERS"
></A
><P
><B
>Table 21-2. Optional User &#38; Group Names</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>User</TH
><TH
>Group</TH
><TH
>Comments</TH
></TR
></THEAD
><TBODY
><TR
><TD
>adm</TD
><TD
>adm</TD
><TD
>Administrative special privileges</TD
></TR
><TR
><TD
>lp</TD
><TD
>lp</TD
><TD
>Printer special privileges</TD
></TR
><TR
><TD
>sync</TD
><TD
>sync</TD
><TD
>Login to sync the system</TD
></TR
><TR
><TD
>shutdown</TD
><TD
>shutdown</TD
><TD
>Login to shutdown the system</TD
></TR
><TR
><TD
>halt</TD
><TD
>halt</TD
><TD
>Login to halt the system</TD
></TR
><TR
><TD
>mail</TD
><TD
>mail</TD
><TD
>Mail special privileges</TD
></TR
><TR
><TD
>news</TD
><TD
>news</TD
><TD
>News special privileges</TD
></TR
><TR
><TD
>uucp</TD
><TD
>uucp</TD
><TD
>UUCP special privileges</TD
></TR
><TR
><TD
>operator</TD
><TD
>root</TD
><TD
>Operator special privileges</TD
></TR
><TR
><TD
>man</TD
><TD
>man</TD
><TD
>Man special privileges</TD
></TR
><TR
><TD
>nobody</TD
><TD
>nobody</TD
><TD
>Used by NFS</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Only a minimum working set of "user names" and their corresponding 
"user groups" are required.
Applications cannot assume non system user or group names will be defined.</P
><P
>Applications cannot assume any policy for the default file creation mask 
(<B
CLASS="COMMAND"
>umask</B
>) or the default
directory permissions a user may have. Applications should enforce user
only file permissions on private files such as mailboxes.  The location of
the users home directory is also not defined by policy other than the
recommendations of the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> and should be obtained by 
the <TT
CLASS="FUNCTION"
>getpwnam()</TT
>, <TT
CLASS="FUNCTION"
>getpwnam_r()</TT
>, <TT
CLASS="FUNCTION"
>getpwent()</TT
>, <TT
CLASS="FUNCTION"
>getpwuid()</TT
>, and <TT
CLASS="FUNCTION"
>getpwuid_r()</TT
> functions.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="UIDRANGE"
>21.3. User ID Ranges</A
></H2
><P
>The system User IDs from 0 to 99 should be statically allocated by the system,
and shall not be created by applications.</P
><P
>The system User IDs from 100 to 499 should be reserved for dynamic
allocation by system administrators and post install scripts using <B
CLASS="COMMAND"
>useradd</B
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="USERGRPRAT"
>21.4. Rationale</A
></H2
><P
>The purpose of specifying optional users and groups is to reduce the
potential for name conflicts between applications and distributions.</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="PACKAGEFMT"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>IX. Package Format and Installation</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>22. <A
HREF="#SWINSTALL"
>Software Installation</A
></DT
><DD
><DL
><DT
>22.1. <A
HREF="#SWINSTALL-INTRO"
>Introduction</A
></DT
><DT
>22.2. <A
HREF="#PKGFORMAT"
>Package File Format</A
></DT
><DD
><DL
><DT
>22.2.1. <A
HREF="#AEN26203"
>Lead Section</A
></DT
><DT
>22.2.2. <A
HREF="#AEN26253"
>Header Structure</A
></DT
><DT
>22.2.3. <A
HREF="#AEN26483"
>Signature Section</A
></DT
><DT
>22.2.4. <A
HREF="#AEN26625"
>Header Section</A
></DT
><DT
>22.2.5. <A
HREF="#AEN27739"
>Payload Section</A
></DT
></DL
></DD
><DT
>22.3. <A
HREF="#PKGSCRIPTS"
>Package Script Restrictions</A
></DT
><DT
>22.4. <A
HREF="#PKGTOOLS"
>Package Tools</A
></DT
><DT
>22.5. <A
HREF="#PKGNAMECONV"
>Package Naming</A
></DT
><DT
>22.6. <A
HREF="#PKGDEPEND"
>Package Dependencies</A
></DT
><DT
>22.7. <A
HREF="#PKGARCHCON"
>Package Architecture Considerations</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SWINSTALL"
></A
>Chapter 22. Software Installation</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="SWINSTALL-INTRO"
>22.1. Introduction</A
></H2
><P
>Applications shall either be packaged in the RPM packaging format as
defined in this specification, or supply an installer which is LSB
conforming (for example, calls LSB commands and utilities).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Supplying an RPM format package is encouraged because it makes systems
easier to manage.  
This specification does not require the implementation to use
RPM as the package manager; it only specifies the format of
the package file.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Applications are also encouraged to uninstall cleanly.</P
></BLOCKQUOTE
></DIV
></P
><P
>A package in RPM format may include a dependency on the LSB Core and other
LSB specifications, as described in <A
HREF="#PKGDEPEND"
>Section 22.6</A
>. Packages that are not
in RPM format may test for the presence of a conforming implementation by means of
the <B
CLASS="COMMAND"
>lsb_release</B
> utility.</P
><P
>Implementations shall provide a mechanism for installing applications in
this packaging format with some restrictions listed
below.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><A
NAME="PKG-2"
></A
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The implementation itself may use a different packaging format for its
own packages, and of course it may use any available mechanism for 
installing the LSB-conformant packages.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGFORMAT"
>22.2. Package File Format</A
></H2
><P
>An RPM format file consists of 4 sections, the Lead, Signature, Header, and
the Payload. All values are stored in network byte order.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26186"
></A
><P
><B
>Table 22-1. RPM File Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Lead</TD
></TR
><TR
><TD
>Signature</TD
></TR
><TR
><TD
>Header</TD
></TR
><TR
><TD
>Payload</TD
></TR
></TBODY
></TABLE
></DIV
><P
>These 4 sections shall exist in the order specified. </P
><P
>The lead section is used to identify the package file.</P
><P
>The signature section is used to verify the integrity, and optionally, the
authenticity of the majority of the package file.</P
><P
>The header section contains all available information about the package. Entries
such as the package's name, version, and file list, are contained in the header.</P
><P
>The payload section holds the files to be installed.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26203"
>22.2.1. Lead Section</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct rpmlead {
    unsigned char magic[4];
    unsigned char major, minor;
    short type;
    short archnum;
    char name[66];
    short osnum;
    short signature_type;
    char reserved[16];
} ;</PRE
></TD
></TR
></TABLE
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26208"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>magic</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this file as an RPM format file. This value shall be
"\355\253\356\333".</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26213"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>major</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the major version number of the file format version. This
value shall be 3.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26218"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>minor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the minor revision number of file format version. This value
shall be 0.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26223"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>type</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating whether this is a source or binary package.
This value shall be 0 to indicate a binary package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26228"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>archnum</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the architecture for which this package is valid. This value
is specified in the architecture specific supplement.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26233"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A NUL terminated string that provides the package name. This name shall
conform with the Package Naming section of this specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26238"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>osnum</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the Operating System for which this package is valid. This
value shall be 1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26243"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>signature_type</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the type of the signature used in the Signature part of the
file. This value shall be 5.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26248"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>reserved</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Reserved space. The value is undefined.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26253"
>22.2.2. Header Structure</A
></H3
><P
>The Header structure is used for both the Signature and Header Sections. A
Header Structure consists of 3 parts, a Header record, followed by 1 or more
Index records, followed by 0 or more bytes of data associated with the Index
records. A Header structure shall be aligned to an 8 byte boundary.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26256"
></A
><P
><B
>Table 22-2. Signature Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Header Record</TD
></TR
><TR
><TD
>Array of Index Records</TD
></TR
><TR
><TD
>Store of Index Values</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26266"
>22.2.2.1. Header Record</A
></H4
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct rpmheader {
    unsigned char magic[4];
    unsigned char reserved[4];
    int nindex;
    int hsize;
    } ;</PRE
></TD
></TR
></TABLE
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26271"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>magic</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this record as an RPM header record. This value shall be
<TT
CLASS="LITERAL"
>"\216\255\350\001"</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26277"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>reserved</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Reserved space.  This value shall be <TT
CLASS="LITERAL"
>"\000\000\000\000"</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26283"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>nindex</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The number of Index Records that follow this Header Record. There should be at
least 1 Index Record.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26288"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>hsize</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The size in bytes of the storage area for the data pointed to by the
Index Records.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26293"
>22.2.2.2. Index Record</A
></H4
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct rpmhdrindex {
    int tag;
    int type;
    int offset;
    int count;
    } ;</PRE
></TD
></TR
></TABLE
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26298"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>tag</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the purpose of the data associated with this Index Record.
The value of this field is dependent on the context in which the Index Record
is used, and is defined below and in later sections.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26303"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>type</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the type of the data associated with this Index Record. The
possible <CODE
CLASS="STRUCTFIELD"
>type</CODE
> values are defined below.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26309"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>offset</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Location in the Store of the data associated with this Index Record. This value
should between 0 and the value contained in the <CODE
CLASS="STRUCTFIELD"
>hsize</CODE
>
of the Header Structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26315"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>count</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of the data associated with this Index Record. The
<CODE
CLASS="STRUCTFIELD"
>count</CODE
> is the number of elements whose size is
defined by the type of this Record.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN26321"
>22.2.2.2.1. Index Type Values</A
></H5
><P
>The possible values for the <CODE
CLASS="STRUCTFIELD"
>type</CODE
> field are defined
in this table.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26325"
></A
><P
><B
>Table 22-3. Index Type values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Type</TH
><TH
>Value</TH
><TH
>Size (in bytes)</TH
><TH
>Alignment</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_NULL_TYPE</CODE
></TD
><TD
>0</TD
><TD
>Not Implemented.</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_CHAR_TYPE</CODE
></TD
><TD
>1</TD
><TD
>1</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT8_TYPE</CODE
></TD
><TD
>2</TD
><TD
>1</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT16_TYPE</CODE
></TD
><TD
>3</TD
><TD
>2</TD
><TD
>2</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT32_TYPE</CODE
></TD
><TD
>4</TD
><TD
>4</TD
><TD
>4</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT64_TYPE</CODE
></TD
><TD
>5</TD
><TD
>Reserved.</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_STRING_TYPE</CODE
></TD
><TD
>6</TD
><TD
>variable, NUL terminated</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_BIN_TYPE</CODE
></TD
><TD
>7</TD
><TD
>1</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_STRING_ARRAY_TYPE</CODE
></TD
><TD
>8</TD
><TD
>Variable, sequence of NUL terminated strings</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
></TD
><TD
>9</TD
><TD
>variable, sequence of NUL terminated strings</TD
><TD
>1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The string arrays specified for entries of type
<CODE
CLASS="CONSTANT"
>RPM_STRING_ARRAY_TYPE</CODE
> and
<CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
>
are vectors of strings in a contiguous block of memory, each element separated
from its neighbors by a NUL character.</P
><P
>Index records with type <CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
> shall always
have a <CODE
CLASS="STRUCTFIELD"
>count</CODE
> of 1. The array entries in an index of
type <CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
> correspond to the locale names
contained in the <CODE
CLASS="CONSTANT"
>RPMTAG_HDRI18NTABLE</CODE
> index.</P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN26403"
>22.2.2.2.2. Index Tag Values</A
></H5
><P
>Some values are designated as header private, and may appear in any header
structure. These are defined here. Additional values are defined in later
sections.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26406"
></A
><P
><B
>Table 22-4. Header Private Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERSIGNATURES</CODE
></TD
><TD
>62</TD
><TD
>BIN</TD
><TD
>16</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERIMMUTABLE</CODE
></TD
><TD
>63</TD
><TD
>BIN</TD
><TD
>16</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERI18NTABLE</CODE
></TD
><TD
>100</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERSIGNATURES</CODE
></DT
><DD
><P
>The signature tag differentiates a signature header from a metadata header, and identifies the original contents of the signature header.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERIMMUTABLE</CODE
></DT
><DD
><P
>This tag contains an index record which specifies the portion of the Header Record which was used for the calculation of a signature. This data shall be preserved or any header-only signature will be invalidated.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERI18NTABLE</CODE
></DT
><DD
><P
>Contains a list of locales for which strings are provided in other parts of the package.</P
></DD
></DL
></DIV
><P
>Not all Index records defined here will be present in all packages. Each tag
value has a status which is defined here.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26456"
></A
><SPAN
STYLE="white-space: nowrap"
>Required</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record shall be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26460"
></A
><SPAN
STYLE="white-space: nowrap"
>Optional</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record may be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26464"
></A
><SPAN
STYLE="white-space: nowrap"
>Informational</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record may be present, but does not contribute to the processing of the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26468"
></A
><SPAN
STYLE="white-space: nowrap"
>Deprecated</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record should not be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26472"
></A
><SPAN
STYLE="white-space: nowrap"
>Obsolete</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record shall not be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26476"
></A
><SPAN
STYLE="white-space: nowrap"
>Reserved</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record shall not be present.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26480"
>22.2.2.3. Header Store</A
></H4
><P
>The header store contains the values specified by the Index structures. These
values are aligned according to their type and padding is used if needed. The
store is located immediately following the Index structures.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26483"
>22.2.3. Signature Section</A
></H3
><P
>The Signature section is implemented using the Header structure. The signature
section defines the following additional tag values which may be used in
the Index structures.</P
><P
>These values exist to provide additional information about the rest of the
package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26487"
></A
><P
><B
>Table 22-5. Signature Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SIZE</CODE
></TD
><TD
>1000</TD
><TD
>INT32</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PAYLOADSIZE</CODE
></TD
><TD
>1007</TD
><TD
>INT32</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SIZE</CODE
></DT
><DD
><P
>This tag specifies the combined size of the Header and Payload sections.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PAYLOADSIZE</CODE
></DT
><DD
><P
>This tag specifies the uncompressed size of the Payload archive, including the cpio headers.</P
></DD
></DL
></DIV
><P
>These values exist to ensure the integrity of the rest of the package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26524"
></A
><P
><B
>Table 22-6. Signature Digest Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SHA1</CODE
></TD
><TD
>269</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_MD5</CODE
></TD
><TD
>1004</TD
><TD
>BIN</TD
><TD
>16</TD
><TD
>Required</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26550"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SHA1</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This index contains the SHA1 checksum of the entire Header Section, including the Header Record, Index Records and Header store.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26555"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_MD5</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the 128-bit MD5 checksum of the combined Header and Archive sections.</P
></TD
></TR
></TBODY
></TABLE
><P
>These values exist to provide authentication of the package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26561"
></A
><P
><B
>Table 22-7. Signature Signing Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_DSA</CODE
></TD
><TD
>267</TD
><TD
>BIN</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_RSA</CODE
></TD
><TD
>268</TD
><TD
>BIN</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PGP</CODE
></TD
><TD
>1002</TD
><TD
>BIN</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_GPG</CODE
></TD
><TD
>1005</TD
><TD
>BIN</TD
><TD
>65</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26601"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_DSA</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tag contains the DSA signature of the Header section. The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>. If this tag is present,then the SIGTAG_GPG tag shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26607"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_RSA</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tag contains the RSA signature of the Header section.The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>. If this tag is present, then the SIGTAG_PGP shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26613"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PGP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the RSA signature of the combined Header and Payload sections. The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26619"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_GPG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tag contains the DSA signature of the combined Header and Payload sections. The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26625"
>22.2.4. Header Section</A
></H3
><P
>The Header section is implemented using the Header structure. The Header
section defines the following additional tag values which may be used in
the Index structures.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26628"
>22.2.4.1. Package Information</A
></H4
><P
>The following tag values are used to indicate information that describes the
package as a whole.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26631"
></A
><P
><B
>Table 22-8. Package Info Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_NAME</CODE
></TD
><TD
>1000</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_VERSION</CODE
></TD
><TD
>1001</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_RELEASE</CODE
></TD
><TD
>1002</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_SUMMARY</CODE
></TD
><TD
>1004</TD
><TD
>I18NSTRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DESCRIPTION</CODE
></TD
><TD
>1005</TD
><TD
>I18NSTRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_SIZE</CODE
></TD
><TD
>1009</TD
><TD
>INT32</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTRIBUTION</CODE
></TD
><TD
>1010</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_VENDOR</CODE
></TD
><TD
>1011</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_LICENSE</CODE
></TD
><TD
>1014</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PACKAGER</CODE
></TD
><TD
>1015</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_GROUP</CODE
></TD
><TD
>1016</TD
><TD
>I18NSTRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_URL</CODE
></TD
><TD
>1020</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OS</CODE
></TD
><TD
>1021</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCH</CODE
></TD
><TD
>1022</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_SOURCERPM</CODE
></TD
><TD
>1044</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCHIVESIZE</CODE
></TD
><TD
>1046</TD
><TD
>INT32</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_RPMVERSION</CODE
></TD
><TD
>1064</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_COOKIE</CODE
></TD
><TD
>1094</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTURL</CODE
></TD
><TD
>1123</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFORMAT</CODE
></TD
><TD
>1124</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADCOMPRESSOR</CODE
></TD
><TD
>1125</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFLAGS</CODE
></TD
><TD
>1126</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Required</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_NAME</CODE
></DT
><DD
><P
>This tag specifies the name of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_VERSION</CODE
></DT
><DD
><P
>This tag specifies the version of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_RELEASE</CODE
></DT
><DD
><P
>This tag specifies the release of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_SUMMARY</CODE
></DT
><DD
><P
>This tag specifies the summary description of the package. The summary value pointed to by this index record contains a one line description of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_DESCRIPTION</CODE
></DT
><DD
><P
>This tag specifies the description of the package. The description value pointed to by this index record contains a full desription of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_SIZE</CODE
></DT
><DD
><P
>This tag specifies the sum of the sizes of the regular files in the archive.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTRIBUTION</CODE
></DT
><DD
><P
>A string containing the name of the distribution on which the package was built.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_VENDOR</CODE
></DT
><DD
><P
>A string containing the name of the organization that produced the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_LICENSE</CODE
></DT
><DD
><P
>This tag specifies the license which applies to this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PACKAGER</CODE
></DT
><DD
><P
>A string identifying the tool used to build the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_GROUP</CODE
></DT
><DD
><P
>This tag specifies the administrative group to which this package belongs.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_URL</CODE
></DT
><DD
><P
>Generic package information URL</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OS</CODE
></DT
><DD
><P
>This tag specifies the OS of the package. The OS value pointed to by this index record shall be "linux".</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCH</CODE
></DT
><DD
><P
>This tag specifies the architecture of the package. The architecture value pointed to by this index record is defined in architecture specific LSB specification.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_SOURCERPM</CODE
></DT
><DD
><P
>This tag specifies the name of the source RPM</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCHIVESIZE</CODE
></DT
><DD
><P
>This tag specifies the uncompressed size of the Payload archive, including the cpio headers.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_RPMVERSION</CODE
></DT
><DD
><P
>This tag indicates the version of RPM tool used to build this package. The value is unused.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_COOKIE</CODE
></DT
><DD
><P
>This tag contains an opaque string whose contents are undefined.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTURL</CODE
></DT
><DD
><P
>URL for package</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFORMAT</CODE
></DT
><DD
><P
>This tag specifies the format of the Archive section. The format value pointed to by this index record shall be 'cpio'.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADCOMPRESSOR</CODE
></DT
><DD
><P
>This tag specifies the compression used on the Archive section. The compression value pointed to by this index record shall be 'gzip'</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFLAGS</CODE
></DT
><DD
><P
>This tag indicates the compression level used for the Payload. This value shall always be '9'.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26907"
>22.2.4.2. Installation Information</A
></H4
><P
>The following tag values are used to provide information needed during the
installation of the package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN26910"
></A
><P
><B
>Table 22-9. Installation Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREIN</CODE
></TD
><TD
>1023</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTIN</CODE
></TD
><TD
>1024</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUN</CODE
></TD
><TD
>1025</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUN</CODE
></TD
><TD
>1026</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREINPROG</CODE
></TD
><TD
>1085</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTINPROG</CODE
></TD
><TD
>1086</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUNPROG</CODE
></TD
><TD
>1087</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUNPROG</CODE
></TD
><TD
>1088</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26978"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREIN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the preinstall scriptlet. If present, then RPMTAG_PREINPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26983"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTIN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the postinstall scriptlet. If present, then RPMTAG_POSTINPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26988"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>his tag specifies the preuninstall scriptlet. If present, then RPMTAG_PREUNPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26993"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specified the postuninstall scriptlet. If present, then RPMTAG_POSTUNPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26998"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREINPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the name of the intepreter to which the preinstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27004"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTINPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the name of the intepreter to which the postinstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27010"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUNPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the name of the intepreter to which the preuninstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27016"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUNPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This program specifies the name of the intepreter to which the postuninstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27022"
>22.2.4.3. File Information</A
></H4
><P
>The following tag values are used to provide information about the files
in the payload. This information is provided in the header to allow more
efficient access of the information.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN27025"
></A
><P
><B
>Table 22-10. File Info Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OLDFILENAMES</CODE
></TD
><TD
>1027</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILESIZES</CODE
></TD
><TD
>1028</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMODES</CODE
></TD
><TD
>1030</TD
><TD
>INT16</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILERDEVS</CODE
></TD
><TD
>1033</TD
><TD
>INT16</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMTIMES</CODE
></TD
><TD
>1034</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMD5S</CODE
></TD
><TD
>1035</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELINKTOS</CODE
></TD
><TD
>1036</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEFLAGS</CODE
></TD
><TD
>1037</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEUSERNAME</CODE
></TD
><TD
>1039</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEGROUPNAME</CODE
></TD
><TD
>1040</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
></TD
><TD
>1095</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEINODES</CODE
></TD
><TD
>1096</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELANGS</CODE
></TD
><TD
>1097</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES</CODE
></TD
><TD
>1116</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_BASENAMES</CODE
></TD
><TD
>1117</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRNAMES</CODE
></TD
><TD
>1118</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27149"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_OLDFILENAMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the filenames when not in a compressed format as determined by the absence of rpmlib(CompressedFileNames) in the RPMTAG_REQUIRENAME index.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27154"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILESIZES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the size of each file in the archive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27159"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMODES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the mode of each file in the archive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27164"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILERDEVS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the device number from which the file was copied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27169"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMTIMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the modification time in seconds since the epoch of each file in the archive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27174"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMD5S</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the ASCII representation of the MD5 sum of the corresponding file contents. This value is empty if the corresponding archive entry is not a regular file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27179"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELINKTOS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The target for a symlink, otherwise NULL.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27184"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEFLAGS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the bit(s) to classify and control how files are to be installed. See below.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27189"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEUSERNAME</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the owner of the corresponding file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27194"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEGROUPNAME</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the group of the corresponding file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27199"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the 16 bit device number from which the file was copied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27204"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEINODES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the inode value from the original file system on the the system on which it was built.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27209"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELANGS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies a per-file locale marker used to install only locale specific subsets of files when the package is installed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27214"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the index into the array provided by the RPMTAG_DIRNAMES Index which contains the directory name for the corresponding filename.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27219"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_BASENAMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the base portion of the corresponding filename.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27224"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRNAMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
></TBODY
></TABLE
><P
>One of <CODE
CLASS="CONSTANT"
>RPMTAG_OLDFILENAMES</CODE
> or the tuple
<CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES,RPMTAG_BASENAMES,RPMTAG_DIRNAMES</CODE
> shall be present, but not
both.</P
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN27232"
>22.2.4.3.1. File Flags</A
></H5
><P
>The <CODE
CLASS="CONSTANT"
>RPMTAG_FILEFLAGS</CODE
> tag value shall identify 
various characteristics of the file in the payload that it describes. It
shall be an
<SPAN
CLASS="TYPE"
>INT32</SPAN
> value consisting of either the
value <CODE
CLASS="CONSTANT"
>RPMFILE_NONE</CODE
> (0) or the bitwise inclusive or of one
or more of the following values:
<DIV
CLASS="TABLE"
><A
NAME="AEN27238"
></A
><P
><B
>Table 22-11. File Flags</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_CONFIG</CODE
></TD
><TD
>(1 &#60;&#60; 0)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_DOC</CODE
></TD
><TD
>(1 &#60;&#60; 1)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_DONOTUSE</CODE
></TD
><TD
>(1 &#60;&#60; 2)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_MISSINGOK</CODE
></TD
><TD
>(1 &#60;&#60; 3)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_NOREPLACE</CODE
></TD
><TD
>(1 &#60;&#60; 4)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_SPECFILE</CODE
></TD
><TD
>(1 &#60;&#60; 5)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_GHOST</CODE
></TD
><TD
>(1 &#60;&#60; 6)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_LICENSE</CODE
></TD
><TD
>(1 &#60;&#60; 7)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_README</CODE
></TD
><TD
>(1 &#60;&#60; 8)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_EXCLUDE</CODE
></TD
><TD
>(1 &#60;&#60; 9)</TD
></TR
></TBODY
></TABLE
></DIV
></P
><P
>These bits have the following meaning:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27288"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_CONFIG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is a configuration file, and an existing file should be saved during
a package upgrade operation and not removed during a pakage removal operation.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27293"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_DOC</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file contains documentation.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27298"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_DONOTUSE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This value is reserved for future use; conforming
packages may not use this flag.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27303"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_MISSINGOK</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file need not exist on the installed system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27308"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_NOREPLACE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Similar to the <CODE
CLASS="CONSTANT"
>RPMFILE_CONFIG</CODE
>, this
flag indicates that during an upgrade operation the original
file on the system should not be altered.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27314"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_SPECFILE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is a package specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27319"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_GHOST</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is not actually included in the payload, but
should still be considered as a part of the package. 
For example, a log file
generated by the application at run time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27324"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_LICENSE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file contains the license conditions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27329"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_README</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file contains high level notes about the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27334"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_EXCLUDE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The corresponding file is not a part of the package,
and should not be installed.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27339"
>22.2.4.4. Dependency Information</A
></H4
><P
>The following tag values are used to provide information about
interdependencies between packages.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN27342"
></A
><P
><B
>Table 22-12. Package Dependency Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDENAME</CODE
></TD
><TD
>1047</TD
><TD
>STRING_ARRAY</TD
><TD
>1</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREFLAGS</CODE
></TD
><TD
>1048</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIRENAME</CODE
></TD
><TD
>1049</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREVERSION</CODE
></TD
><TD
>1050</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTFLAGS</CODE
></TD
><TD
>1053</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTNAME</CODE
></TD
><TD
>1054</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTVERSION</CODE
></TD
><TD
>1055</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETENAME</CODE
></TD
><TD
>1090</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEFLAGS</CODE
></TD
><TD
>1112</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEVERSION</CODE
></TD
><TD
>1113</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEFLAGS</CODE
></TD
><TD
>1114</TD
><TD
>INT32</TD
><TD
>1</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEVERSION</CODE
></TD
><TD
>1115</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDENAME</CODE
></DT
><DD
><P
>This tag indicates the name of the dependency provided by this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the dependency range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIRENAME</CODE
></DT
><DD
><P
>This tag indicates the dependencies for this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_REQUIRENAME Index.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the conflict range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTNAME</CODE
></DT
><DD
><P
>This tag indicates the conflicting dependencies for this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_CONFLICTNAME Index.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETENAME</CODE
></DT
><DD
><P
>This tag indicates the obsoleted dependencies for this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the conflict range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_PROVIDENAME Index.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the conflict range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_OBSOLETENAME Index.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN27498"
>22.2.4.4.1. Package Dependency Values</A
></H5
><P
>The package dependencies are stored in the
<CODE
CLASS="VARNAME"
>RPMTAG_REQUIRENAME</CODE
> and
<CODE
CLASS="VARNAME"
>RPMTAG_REQUIREVERSION</CODE
>
index records. The following values may be used.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN27503"
></A
><P
><B
>Table 22-13. Index Type values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Version</TH
><TH
>Meaning</TH
><TH
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
>rpmlib(VersionedDependencies)</TD
><TD
>3.0.3-1</TD
><TD
>Indicates that the package contains <CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDENAME</CODE
>,
<CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETENAME</CODE
> or 
<CODE
CLASS="CONSTANT"
>RPMTAG_PREREQ</CODE
> records that have a version associated
with them.</TD
><TD
>Optional</TD
></TR
><TR
><TD
>rpmlib(PayloadFilesHavePrefix)</TD
><TD
>4.0-1</TD
><TD
>Indicates the filenames in the Archive have had "." prepended to them.</TD
><TD
>Optional</TD
></TR
><TR
><TD
>rpmlib(CompressedFileNames)</TD
><TD
>3.0.4-1</TD
><TD
>Indicates that the filenames in the Payload are represented in the
<CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES</CODE
>, 
<CODE
CLASS="CONSTANT"
>RPMTAG_DIRNAME</CODE
> and 
<CODE
CLASS="CONSTANT"
>RPMTAG_BASENAMES</CODE
> indexes.</TD
><TD
>Optional</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>/bin/sh</B
></TD
><TD
>&nbsp;</TD
><TD
>Interpreter usually required for installation scripts.</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Additional dependencies are specified in the Package Dependencies section of
this specification, and the architecture specific supplements.</P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN27541"
>22.2.4.4.2. Package Dependencies Attributes</A
></H5
><P
>The package dependency attributes are stored in the
<CODE
CLASS="VARNAME"
>RPMTAG_REQUIREFLAGS</CODE
>,
<CODE
CLASS="VARNAME"
>RPMTAG_PROVIDEFLAGS</CODE
> and
<CODE
CLASS="VARNAME"
>RPMTAG_OBSOLETEFLAGS</CODE
>
index records. The following values may be used.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN27547"
></A
><P
><B
>Table 22-14. Package Dependency Attributes</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_LESS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x02</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_GREATER</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x04</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_EQUAL</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x08</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_PREREQ</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x40</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_INTERP</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x100</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_PRE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x200</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_POST</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x400</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_PREUN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x800</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_POSTUN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x1000</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_RPMLIB</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x1000000</TT
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27616"
>22.2.4.5. Other Information</A
></H4
><P
>The following tag values are also found in the Header section.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN27619"
></A
><P
><B
>Table 22-15. Other Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDTIME</CODE
></TD
><TD
>1006</TD
><TD
>INT32</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDHOST</CODE
></TD
><TD
>1007</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEVERIFYFLAGS</CODE
></TD
><TD
>1045</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTIME</CODE
></TD
><TD
>1080</TD
><TD
>INT32</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGNAME</CODE
></TD
><TD
>1081</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTEXT</CODE
></TD
><TD
>1082</TD
><TD
>STRING_ARRAY</TD
><TD
>&nbsp;</TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OPTFLAGS</CODE
></TD
><TD
>1122</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_RHNPLATFORM</CODE
></TD
><TD
>1131</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Deprecated</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PLATFORM</CODE
></TD
><TD
>1132</TD
><TD
>STRING</TD
><TD
>1</TD
><TD
>Informational</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDTIME</CODE
></DT
><DD
><P
>This tag specifies the time as seconds since the epoch at which the package was built.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDHOST</CODE
></DT
><DD
><P
>This tag specifies the hostname of the system on which which the package was built.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEVERIFYFLAGS</CODE
></DT
><DD
><P
>This tag specifies the bit(s) to control how files are to be verified after install, specifying which checks should be performed.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTIME</CODE
></DT
><DD
><P
>This tag specifies the Unix time in seconds since the epoch associated with each entry in the Changelog file.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGNAME</CODE
></DT
><DD
><P
>This tag specifies the name of who made a change to this package</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTEXT</CODE
></DT
><DD
><P
>This tag specifies the changes asssociated with a changelog entry.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OPTFLAGS</CODE
></DT
><DD
><P
>This tag indicates additional flags which may have been passed to the compiler when building this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_RHNPLATFORM</CODE
></DT
><DD
><P
>This tag contains an opaque string whose contents are undefined.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PLATFORM</CODE
></DT
><DD
><P
>This tag contains an opaque string whose contents are undefined.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27739"
>22.2.5. Payload Section</A
></H3
><P
>The Payload section contains a compressed cpio archive. The format of this
section is defined by <A
HREF="#STD.RFC1952"
>RFC 1952: GZIP File Format Specification</A
>.</P
><P
>When uncompressed, the cpio archive contains a sequence of records for each
file. Each record contains a CPIO Header, Filename, Padding, and File Data.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN27744"
></A
><P
><B
>Table 22-16. CPIO File Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>CPIO Header</TD
><TD
>Header structure as defined below.</TD
></TR
><TR
><TD
>Filename</TD
><TD
>NUL terminated ASCII string containing the name of the file.</TD
></TR
><TR
><TD
>Padding</TD
><TD
>0-3 bytes as needed to align the file stream to a 4 byte boundary.</TD
></TR
><TR
><TD
>File data</TD
><TD
>The contents of the file.</TD
></TR
><TR
><TD
>Padding</TD
><TD
>0-3 bytes as needed to align the file stream to a 4 byte boundary.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The CPIO Header uses the following header structure (sometimes referred to
as "new ASCII" or "SVR4 cpio"). All numbers are stored as ASCII
representations of their hexadecimal value with leading zeros as needed to fill
the field.  With the exception of <CODE
CLASS="STRUCTFIELD"
>c_namesize</CODE
>
and the corresponding name string, and <CODE
CLASS="STRUCTFIELD"
>c_checksum</CODE
>,
all information contained in the CPIO Header is also represented in the
Header Section.
The values in the CPIO Header shall match the values contained in the
Header Section.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
        char    c_magic[6];
        char    c_ino[8];
        char    c_mode[8];
        char    c_uid[8];
        char    c_gid[8];
        char    c_nlink[8];
        char    c_mtime[8];
        char    c_filesize[8];
        char    c_devmajor[8];
        char    c_devminor[8];
        char    c_rdevmajor[8];
        char    c_rdevminor[8];
        char    c_namesize[8];
        char    c_checksum[8];
        };</PRE
></TD
></TR
></TABLE
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27769"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_magic</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this cpio format. This value shall be "070701".</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27774"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_ino</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This field contains the inode number from the filesystem from which the
file was read.
This field is ignored when installing a package.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEINODES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27780"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_mode</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Permission bits of the file. This is an ascii representation of the hexadecimal
number representing the bit as defined for the
<CODE
CLASS="STRUCTFIELD"
>st_mode</CODE
> field of the <TT
CLASS="STRUCTNAME"
>stat</TT
>
structure defined for the <CODE
CLASS="VARNAME"
>stat</CODE
> function.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEMODES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27789"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_uid</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this owner of this file.
This value matches the uid value of the corresponding user in the
RPMTAG_FILEUSERNAME as found on the system where this package was built. The
username specified in RPMTAG_FILEUSERNAME should take precedence when
installing the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27794"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_gid</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this group of this file.
This value matches the gid value of the corresponding user in the
RPMTAG_FILEGROUPNAME as found on the system where this package was built. The
groupname specified in RPMTAG_FILEGROUPNAME should take precedence when
installing the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27799"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_nlink</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the number of links associated with this file. If the value
is greater than 1, then this filename will be linked to 1 or more files in this
archive that has a matching value for the c_ino, c_devmajor and c_devminor
fields.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27804"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_mtime</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the modification time of the file when it was read.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEMTIMES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27810"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_filesize</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the size of the file.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILESIZES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27816"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_devmajor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The major number of the device containing the file system from which the
file was read.
With the exception of processing files with c_nlink &#62;1, this field is ignored
when installing a package.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27822"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_devminor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The minor number of the device containing the file system from which the
file was read.
With the exception of processing files with c_nlink &#62;1, this field is ignored
when installing a package.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27828"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_rdevmajor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The major number of the raw device containing the file system from which the
file was read.
This field is ignored when installing a package.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_RDEVS</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27834"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_rdevminor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The minor number of the raw device containing the file system from which the
file was read.
This field is ignored when installing a package.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_RDEVS</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27840"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_namesize</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the length of the filename, which is located immediately
following the CPIO Header structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27845"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_checksum</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value containing the CRC checksum of the file data. This field is not used,
and shall contain the value "00000000".
This field is ignored when installing a package.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>A record with the filename "TRAILER!!!" indicates the last record in the
archive.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGSCRIPTS"
>22.3. Package Script Restrictions</A
></H2
><P
>Scripts used as part of the package install and uninstall shall only use
commands and interfaces that are specified by the LSB. All other commands are
not guaranteed to be present, or to behave in expected ways.</P
><P
>Packages shall not use RPM triggers.</P
><P
>Packages shall not depend on the order in which scripts are executed
(pre-install, pre-uninstall, etc), when doing an upgrade.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGTOOLS"
>22.4. Package Tools</A
></H2
><P
>The LSB does not specify the interface to the tools used to manipulate 
LSB-conformant packages. Each conforming implementation shall provide 
documentation for installing LSB packages.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGNAMECONV"
>22.5. Package Naming</A
></H2
><P
>Packages supplied by implementations and applications shall follow the
following rules for the name field within the package.  These rules
are not required for the filename of the package file itself.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>There are discrepancies among implementations
concerning whether the name might be <TT
CLASS="LITERAL"
>frobnicator-1.7-21-ppc32.rpm</TT
> or
<TT
CLASS="LITERAL"
>frobnicator-1.7-21-powerpc32.rpm</TT
>.  
The architecture aside, recommended
practice is for the filename of the package file to match the name
within the package.</P
></BLOCKQUOTE
></DIV
>&#13;</P
><P
>The following rules apply to the name field alone, not including any
release or version.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If the name with the
release and version is <TT
CLASS="LITERAL"
>frobnicator-1.7-21</TT
>, the name part is
<TT
CLASS="LITERAL"
>frobnicator</TT
> and falls under the rules for a name with no
hyphens.</P
></BLOCKQUOTE
></DIV
></P
><P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>If the name begins with <TT
CLASS="LITERAL"
>lsb-</TT
> and contains no other hyphens, the name
shall be assigned by the 
<A
HREF="http://www.lanana.org"
TARGET="_top"
>Linux Assigned Names and 
Numbers Authority</A
> (LANANA), which shall maintain a
registry of LSB names.
The name may be registered by either an implementation or an application.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>If the package name begins with <TT
CLASS="LITERAL"
>lsb-</TT
> and
contains more than one hyphen (for example
<TT
CLASS="LITERAL"
>lsb-distro.example.com-database</TT
> or 
<TT
CLASS="LITERAL"
>lsb-gnome-gnumeric</TT
>), then 
the portion of the package name between first and second hyphens shall 
either be an LSB provider name assigned by the LANANA, or it may be 
one of the owners' fully-qualified domain names in lower case (e.g., 
<TT
CLASS="LITERAL"
>debian.org</TT
>, <TT
CLASS="LITERAL"
>staroffice.sun.com</TT
>). 
The LSB provider name assigned 
by LANANA shall only consist of the ASCII characters [a-z0-9].
The provider name or domain name may be either that of an implementation
or an application.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Package names containing no hyphens are reserved for use by
implementations.  Applications shall not use such names.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>&#13;Package names which do not start with <TT
CLASS="LITERAL"
>lsb-</TT
> and which contain a
hyphen are open to both implementations and applications.  Implementations
may name packages in any part of this namespace.  They are encouraged
to use names from one of the other namespaces available to them, but
this is not required due to the large amount of current practice to
the contrary.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Widespread existing practice includes such names as
<TT
CLASS="LITERAL"
>ssh-common</TT
>, <TT
CLASS="LITERAL"
>ssh-client</TT
>,
<TT
CLASS="LITERAL"
>kernel-pcmcia</TT
>, and the like.  Possible alternative names include
<TT
CLASS="LITERAL"
>sshcommon</TT
>, <TT
CLASS="LITERAL"
>foolinux-ssh-common</TT
>
(where <TT
CLASS="LITERAL"
>foolinux</TT
> is registered to the
implementation), or <TT
CLASS="LITERAL"
>lsb-foolinux-ssh-common</TT
>.</P
></BLOCKQUOTE
></DIV
>
Applications may name their packages this way, but only if the portion
of the name before the first hyphen is a provider name or registered
domain name as described above.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If an
application vendor has domain name such as <TT
CLASS="LITERAL"
>visicalc.example.com</TT
> and has
registered <TT
CLASS="LITERAL"
>visicalc</TT
> as a provider name, they might name packages
<TT
CLASS="LITERAL"
>visicalc-base</TT
>, <TT
CLASS="LITERAL"
>visicalc.example.com-charting</TT
>, and the
like.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Package names in this namespace are
available to both the implementation and an application.  Implementations
and applications will need to consider this potential for conflicts
when deciding to use these names rather than the alternatives (such as
names starting with <TT
CLASS="LITERAL"
>lsb-</TT
>).</P
></BLOCKQUOTE
></DIV
>&#13;</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGDEPEND"
>22.6. Package Dependencies</A
></H2
><P
>Packages shall have a dependency that indicates which LSB modules are
required.
LSB module descriptions are dash seperated tuples containing the name 'lsb',
the module name, and the architecture name. The following dependencies may be
used.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27909"
></A
><SPAN
STYLE="white-space: nowrap"
>lsb-core-<TT
CLASS="REPLACEABLE"
><I
>arch</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This dependency is used to indicate that the application is dependent
on features contained in the LSB-Core specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27914"
></A
><SPAN
STYLE="white-space: nowrap"
>lsb-core-noarch</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This dependency is used to indicate that the application is dependent
on features contained in the LSB-Core specification and that the package 
does not contain any architecture specific files.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>These dependencies shall have a version of 3.0.</P
><P
>Packages shall not depend on other system-provided dependencies.  They
shall not depend on non-system-provided dependencies unless those dependencies
are fulfilled by packages which are part of the same application. 
A package may only provide a virtual package name
which is registered to that application.</P
><P
>Other modules in the LSB may supplement this list. The architecture
specific dependencies are described in the relevant architecture
specific LSB.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGARCHCON"
>22.7. Package Architecture Considerations</A
></H2
><P
>Packages which do not contain any architecture specific files should specify an
architecture of <SAMP
CLASS="COMPUTEROUTPUT"
>noarch</SAMP
>. An LSB runtime
environment shall accept values <SAMP
CLASS="COMPUTEROUTPUT"
>noarch</SAMP
>, or
the value specified in the architecture specific supplement.</P
><P
>Additional specifications or restrictions may be found in the architecture
specific LSB specification.</P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="APP-A"
></A
>Appendix A. Alphabetical Listing of Interfaces</H1
><P
></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBC"
>A.1. libc</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV2"
>SUSv2</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SVID.3"
>SVID Issue 3</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SVID.4"
>SVID Issue 4</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN27947"
></A
><P
><B
>Table A-1. libc Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Exit(GLIBC_2.1.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>getpwuid_r(GLIBC_2.1.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigaddset(GLIBC_2.1.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_IO_feof(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getrlimit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigaltstack(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_IO_getc(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getrlimit64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>sigandset(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>_IO_putc(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getrusage(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigdelset(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_IO_puts(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getservbyname(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigemptyset(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__assert_fail(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getservbyport(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigfillset(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__ctype_b_loc<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getservent()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sighold()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__ctype_get_mb_cur_max(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getsid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigignore(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__ctype_tolower_loc<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getsockname()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>siginterrupt()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__ctype_toupper_loc<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getsockopt()<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>sigisemptyset()<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__cxa_atexit(GLIBC_2.1.3)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getsubopt(GLIBC_2.1.3)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigismember(GLIBC_2.1.3)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__errno_location(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gettext(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>siglongjmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__fpending(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gettimeofday(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>signal(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__fxstat(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getuid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigorset(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__fxstat64(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getutent(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>sigpause(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__getpagesize(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getutent_r(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>sigpending(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__getpgid(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getutxent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigprocmask(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__h_errno_location<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getutxid()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigqueue()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__isinf<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getutxline()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigrelse()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__isinff<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getw()<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>sigreturn()<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__isinfl<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getwc()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigset()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__isnan<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getwchar()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigsuspend()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__isnanf<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>getwd()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigtimedwait()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__isnanl<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>glob()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigwait()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__libc_current_sigrtmax(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>glob64(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>sigwaitinfo(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__libc_current_sigrtmin(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>globfree(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sleep(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__libc_start_main(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>globfree64(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>snprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__lxstat(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gmtime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sockatmark<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__lxstat64(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gmtime_r(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>socket(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__mempcpy(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>grantpt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>socketpair(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__rawmemchr(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>hcreate(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sprintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__register_atfork<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>hdestroy()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>srand()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__sigsetjmp(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>hsearch(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>srand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__stpcpy(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>htonl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>srandom(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__strdup(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>htons(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__strtod_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>iconv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>statvfs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__strtof_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>iconv_close(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>statvfs64<A
HREF="#STD.LFS"
>[1]</A
></TD
></TR
><TR
><TD
>__strtok_r(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>iconv_open(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>stime(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__strtol_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>if_freenameindex<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>stpcpy(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__strtold_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>if_indextoname<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>stpncpy(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__strtoll_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>if_nameindex<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcasecmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__strtoul_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>if_nametoindex<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcasestr(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__strtoull_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>imaxabs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcat(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__sysconf(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>imaxdiv(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strchr(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__sysv_signal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>index(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__wcstod_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inet_addr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcoll(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__wcstof_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inet_ntoa(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__wcstol_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inet_ntop<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strcspn(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__wcstold_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inet_pton<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strdup(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__wcstoul_internal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>initgroups(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>strerror(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__xmknod(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>initstate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strerror_r(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>__xstat(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>insque(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strfmon(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__xstat64(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>ioctl(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>strftime(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_exit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isalnum(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strlen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_longjmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isalpha(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strncasecmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_setjmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isascii(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strncat(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_tolower(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isatty(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strncmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_toupper(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isblank(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strncpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>a64l(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iscntrl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strndup(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>abort(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isdigit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strnlen(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>abs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isgraph(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strpbrk(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>accept(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>islower(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strptime(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>access(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isprint(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strrchr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acct(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>ispunct(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strsep(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>adjtime(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>isspace(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strsignal(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>alarm(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>isupper(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strspn(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asctime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswalnum(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strstr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asctime_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswalpha(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtod(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asprintf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>iswblank(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtof(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atof(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswcntrl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtoimax(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atoi(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswctype(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtok(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atol(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswdigit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtok_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atoll<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswgraph()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtol()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>authnone_create(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>iswlower(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtold(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>basename(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswprint(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtoll(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>bcmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswpunct(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtoq(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>bcopy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswspace(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtoul(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>bind(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>iswupper(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtoull(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>bind_textdomain_codeset<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>iswxdigit()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtoumax()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>bindresvport(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>isxdigit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strtouq(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>bindtextdomain(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>jrand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>strxfrm(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>brk(GLIBC_2.0)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>key_decryptsession(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
><TD
>svc_getreqset(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>bsd_signal(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>kill(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>svc_register(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>bsearch(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>killpg(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svc_run(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>btowc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>l64a(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svc_sendreply(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>bzero(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>labs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcerr_auth(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>calloc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lchown(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcerr_decode(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>catclose(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lcong48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcerr_noproc(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>catgets(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ldiv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcerr_noprog(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>catopen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lfind(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcerr_progvers(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>cfgetispeed(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>link(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>svcerr_systemerr(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>cfgetospeed(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>listen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcerr_weakauth(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>cfmakeraw(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>llabs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svctcp_create(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>cfsetispeed(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lldiv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>svcudp_create(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>cfsetospeed(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>localeconv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>swab(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cfsetspeed(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>localtime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>swapcontext(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>chdir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>localtime_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>swprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>chmod(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lockf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>swscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>chown(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lockf64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>symlink(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>chroot(GLIBC_2.0)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>longjmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sync(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clearerr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lrand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sysconf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_create(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>lsearch(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>syslog(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_pcreateerror(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>lseek(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>system(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_perrno(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>makecontext(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcdrain(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_perror(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>malloc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcflow(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_spcreateerror(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>mblen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcflush(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_sperrno(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>mbrlen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcgetattr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clnt_sperror(GLIBC_2.0)<A
HREF="#STD.SVID.4"
>[1]</A
></TD
><TD
>mbrtowc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcgetpgrp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clock(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mbsinit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcgetsid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>close(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mbsnrtowcs(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>tcsendbreak(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>closedir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mbsrtowcs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcsetattr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>closelog(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mbstowcs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tcsetpgrp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>confstr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mbtowc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tdelete<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>connect(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>memccpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>telldir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>creat(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>memchr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tempnam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>creat64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>memcmp(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>textdomain(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>ctermid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>memcpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tfind(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ctime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>memmem(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>time(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ctime_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>memmove(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>times(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cuserid(GLIBC_2.0)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>memrchr(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>tmpfile(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>daemon(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>memset(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tmpfile64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
></TR
><TR
><TD
>dcgettext(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>mkdir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tmpnam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>dcngettext<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>mkfifo()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>toascii()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>dgettext<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>mkstemp()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tolower()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>difftime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mkstemp64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>toupper(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>dirname(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mktemp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>towctrans(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>div(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mktime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>towlower(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>dngettext<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>mlock()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>towupper()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>drand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mlockall(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>truncate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>dup(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mmap(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>truncate64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
></TR
><TR
><TD
>dup2(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mmap64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>tsearch(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>duplocale<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>mprotect()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ttyname()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ecvt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>mrand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ttyname_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>endgrent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>msgctl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>twalk(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>endprotoent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>msgget(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tzset(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>endpwent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>msgrcv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ualarm(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>endservent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>msgsnd(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ulimit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>endutent(GLIBC_2.0)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>msync(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>umask(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>endutxent(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>munlock(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>uname(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>erand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>munlockall(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ungetc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>err(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>munmap(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ungetwc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>error(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>nanosleep(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>unlink(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>errx(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>newlocale<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>unlockpt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>execl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nftw(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>unsetenv<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>execle(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nftw64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>uselocale<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>execlp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ngettext<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>usleep(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>execv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nice(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>utime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>execve(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nl_langinfo(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>utimes(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>execvp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nrand48(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>utmpname<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>exit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ntohl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vasprintf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fchdir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ntohs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vdprintf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fchmod(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>open(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>verrx(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fchown(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>opendir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vfork(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fclose(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>openlog(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vfprintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fcntl(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pathconf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vfscanf<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fcvt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pause(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vfwprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fdatasync(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pclose(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vfwscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fdopen(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>perror(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vprintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>feof(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pipe(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vscanf<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>ferror(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pmap_getport(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>vsnprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fflush(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pmap_set(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>vsprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fflush_unlocked(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pmap_unset(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>vsscanf<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>ffs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>poll(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vswprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fgetc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>popen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vswscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fgetpos(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>posix_memalign(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vsyslog<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fgetpos64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>posix_openpt<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vwprintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fgets(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>printf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>vwscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fgetwc(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>psignal(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>wait(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fgetwc_unlocked(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>ptsname(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wait4(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fgetws(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>putc(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>waitpid(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fileno(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>putc_unlocked(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>warn(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>flock(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>putchar(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>warnx(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>flockfile(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>putchar_unlocked(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcpcpy(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fmtmsg(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>putenv(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcpncpy(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fnmatch(GLIBC_2.2.3)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>puts(GLIBC_2.2.3)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcrtomb(GLIBC_2.2.3)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fopen(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pututxline(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcscasecmp(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fopen64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>putw(GLIBC_2.1)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>wcscat(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fork(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>putwc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcschr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fpathconf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>putwchar(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcscmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>qsort(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcscoll(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fputc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>raise(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcscpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fputs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rand(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcscspn(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fputwc(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rand_r(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsdup(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fputws(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>random(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsftime(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fread(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>read(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcslen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>free(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>readdir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsncasecmp(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>freeaddrinfo<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>readdir64()<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>wcsncat()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>freelocale<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>readdir_r<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsncmp()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>freopen(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>readlink(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsncpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>freopen64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>readv(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsnlen(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>realloc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsnrtombs(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>fseek(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>realpath(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcspbrk(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fseeko(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>recv(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsrchr(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fseeko64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>recvfrom(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsrtombs(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fsetpos(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>recvmsg(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsspn(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fsetpos64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>regcomp(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsstr(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fstatvfs(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>regerror(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstod(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fstatvfs64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>regexec(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>wcstof(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fsync(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>regfree(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstoimax(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftell(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>remove(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstok(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftello(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>remque(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstol(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftello64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>rename(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstold(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftime(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rewind(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstoll(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftok(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rewinddir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstombs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftruncate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rindex(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstoq(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>ftruncate64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>rmdir(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstoul(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftrylockfile(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sbrk(GLIBC_2.0)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>wcstoull(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftw(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>wcstoumax(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ftw64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>sched_get_priority_max(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcstouq(GLIBC_2.1)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>funlockfile(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sched_get_priority_min(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcswcs(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fwide(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sched_getparam(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcswidth(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fwprintf(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sched_getscheduler(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcsxfrm(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fwrite(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sched_rr_get_interval(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wctob(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>fwscanf(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>sched_setparam(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wctomb(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>gai_strerror<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sched_setscheduler()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wctrans()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>gcvt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sched_yield(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wctype(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getaddrinfo<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>seed48()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wcwidth()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>seekdir(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wmemchr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getc_unlocked(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>select(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wmemcmp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getchar(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>semctl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wmemcpy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getchar_unlocked(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>semget(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wmemmove(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getcontext(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>semop(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wmemset(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getcwd(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>send(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wordexp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getdate(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sendmsg(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wordfree(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getegid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sendto(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wprintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getenv(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setbuf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>write(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>geteuid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setbuffer(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>writev(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>getgid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setcontext(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>wscanf(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>getgrent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setegid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_accepted_reply(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getgrgid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setenv<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_array(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getgrgid_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>seteuid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_bool(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getgrnam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setgid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_bytes(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getgrnam_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setgrent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_callhdr(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getgrouplist<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>setgroups()<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>xdr_callmsg()<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getgroups(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sethostname(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>xdr_char(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>gethostbyaddr(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setitimer(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_double(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>gethostbyname(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setlocale(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_enum(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>gethostid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setlogmask(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_float(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>gethostname(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setpgid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_free(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getitimer(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setpgrp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_int(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getloadavg(GLIBC_2.2)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>setpriority(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_long(GLIBC_2.2)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getlogin(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setprotoent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_opaque(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getlogin_r<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setpwent()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_opaque_auth()<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getnameinfo<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setregid()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_pointer()<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getopt(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>setreuid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_reference(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getopt_long(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>setrlimit(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_rejected_reply(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getopt_long_only(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>setrlimit64<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>xdr_replymsg(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpagesize(GLIBC_2.0)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>setservent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_short(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpeername(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setsid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_string(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpgid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setsockopt(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>xdr_u_char(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpgrp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setstate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_u_int(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>getpid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setuid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_u_long(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getppid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setutent(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>xdr_u_short(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpriority(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setutxent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_union(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getprotobyname(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setvbuf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_vector(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getprotobynumber(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shmat(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_void(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getprotoent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shmctl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdr_wrapstring(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpwent(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shmdt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdrmem_create(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpwnam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shmget(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdrrec_create(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpwnam_r(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shutdown(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>xdrrec_eof(GLIBC_2.0)<A
HREF="#STD.SVID.3"
>[1]</A
></TD
></TR
><TR
><TD
>getpwuid(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sigaction(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN29777"
></A
><P
><B
>Table A-2. libc Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__daylight<A
HREF="#STD.LSB"
></A
></TD
><TD
>__timezone<A
HREF="#STD.LSB"
></A
></TD
><TD
>_sys_errlist<A
HREF="#STD.LSB"
></A
></TD
></TR
><TR
><TD
>__environ<A
HREF="#STD.LSB"
></A
></TD
><TD
>__tzname<A
HREF="#STD.LSB"
></A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBCRYPT"
>A.2. libcrypt</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN29801"
></A
><P
><B
>Table A-3. libcrypt Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>crypt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>encrypt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>setkey(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBDL"
>A.3. libdl</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN29821"
></A
><P
><B
>Table A-4. libdl Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>dladdr(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>dlerror(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>dlsym(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>dlclose(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>dlopen(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBM"
>A.4. libm</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.ISOC99"
>ISO C (1999)</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV2"
>SUSv2</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN29851"
></A
><P
><B
>Table A-5. libm Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__finite<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>csinhf()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log10()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__finitef<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>csinhl()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log10f<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__finitel<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>csinl()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log10l<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__fpclassify<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>csqrt()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log1p()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__fpclassifyf<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>csqrtf()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log1pf<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__signbit<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>csqrtl()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log1pl<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>__signbitf<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>ctan()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log2<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acos(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ctanf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log2f<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acosf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ctanh(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log2l<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acosh(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ctanhf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>logb(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acoshf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ctanhl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>logbf<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acoshl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ctanl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>logbl<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>acosl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>dremf(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>logf<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asin(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>dreml(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>logl<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asinf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>erf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lrint(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asinh(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>erfc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lrintf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asinhf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>erfcf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lrintl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asinhl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>erfcl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lround(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>asinl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>erff(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lroundf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atan(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>erfl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lroundl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atan2(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>exp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>matherr(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>atan2f(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>exp2<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>modf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atan2l(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>exp2f<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>modff(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atanf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>expf<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>modfl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atanh(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>expl<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nan(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atanhf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>expm1(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nanf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atanhl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>expm1f<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nanl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>atanl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>expm1l<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nearbyint(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cabs(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fabs(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nearbyintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cabsf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fabsf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nearbyintl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cabsl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fabsl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nextafter(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cacos(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fdim(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nextafterf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cacosf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fdimf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nextafterl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cacosh(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fdiml(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nexttoward(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cacoshf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>feclearexcept(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nexttowardf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cacoshl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fegetenv(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>nexttowardl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cacosl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fegetexceptflag(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pow(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>carg(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fegetround(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pow10(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cargf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>feholdexcept(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pow10f(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cargl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>feraiseexcept(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pow10l(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>casin(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fesetenv(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>powf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>casinf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fesetexceptflag(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>powl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>casinh(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fesetround(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>remainder(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>casinhf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fetestexcept(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>remainderf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>casinhl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>feupdateenv(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>remainderl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>casinl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>finite(GLIBC_2.1)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>remquo(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>catan(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>finitef(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>remquof(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>catanf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>finitel(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>remquol(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>catanh(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>floor(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rint(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>catanhf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>floorf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>catanhl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>floorl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>rintl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>catanl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fma(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>round(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cbrt(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmaf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>roundf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cbrtf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmal(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>roundl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cbrtl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmax(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalb(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ccos(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmaxf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalbf(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>ccosf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmaxl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalbl(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>ccosh(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmin(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalbln(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ccoshf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fminf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalblnf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ccoshl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fminl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalblnl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ccosl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmod(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalbn(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ceil(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmodf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalbnf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ceilf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>fmodl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>scalbnl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>ceill(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>frexp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>significand(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cexp(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>frexpf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>significandf(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cexpf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>frexpl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>significandl(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cexpl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>gamma(GLIBC_2.1)<A
HREF="#STD.SUSV2"
>[1]</A
></TD
><TD
>sin(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cimag(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>gammaf(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>sincos(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cimagf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>gammal(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>sincosf(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cimagl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>hypot(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sincosl(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>clog(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>hypotf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sinf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clog10(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>hypotl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sinh(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clog10f(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>ilogb(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sinhf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clog10l(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>ilogbf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sinhl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clogf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ilogbl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sinl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clogl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>j0(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sqrt(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>conj(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>j0f(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>sqrtf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>conjf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>j0l(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>sqrtl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>conjl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>j1(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tan(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>copysign(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>j1f(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>tanf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>copysignf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>j1l(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>tanh(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>copysignl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>jn(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tanhf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cos(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>jnf(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>tanhl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cosf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>jnl(GLIBC_2.0)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>tanl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cosh(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ldexp(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tgamma(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>coshf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ldexpf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tgammaf(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>coshl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ldexpl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>tgammal(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cosl(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lgamma(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>trunc(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cpow(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lgamma_r(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>truncf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cpowf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lgammaf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>truncl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cpowl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lgammaf_r(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>y0(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>cproj(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lgammal(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>y0f(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cprojf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>lgammal_r(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
><TD
>y0l(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>cprojl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>llrint(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>y1(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>creal(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>llrintf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>y1f(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>crealf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>llrintl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>y1l(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>creall(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>llround(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>yn(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>csin(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>llroundf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ynf(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>csinf(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>llroundl(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>ynl(GLIBC_2.1)<A
HREF="#STD.ISOC99"
>[1]</A
></TD
></TR
><TR
><TD
>csinh(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>log(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN30554"
></A
><P
><B
>Table A-6. libm Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>signgam<A
HREF="#STD.SUSV3"
></A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBNCURSES"
>A.5. libncurses</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.SUS.CURSES"
>X/Open Curses</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN30570"
></A
><P
><B
>Table A-7. libncurses Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>addch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvdelch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_refresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>addchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvderwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_restore<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>addchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvgetch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>addnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvgetnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_touch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>addstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvgetstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>standend<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attr_get<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvhline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>standout<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attr_off<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>start_color<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attr_on<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>subpad<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attr_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>subwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attroff<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>syncok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attron<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinsch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>termattrs<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>attrset<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinsnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>termname<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>baudrate<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinsstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tgetent<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>beep<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvinstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tgetflag<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>bkgd<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvprintw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tgetnum<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>bkgdset<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvscanw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tgetstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>border<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvvline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tgoto<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>box<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwaddch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tigetflag<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>can_change_color<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwaddchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tigetnum<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>cbreak<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwaddchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tigetstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>chgat<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwaddnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>timeout<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>clear<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwaddstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>touchline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>clearok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwchgat<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>touchwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>clrtobot<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwdelch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tparm<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>clrtoeol<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwgetch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>tputs<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>color_content<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwgetnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>typeahead<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>color_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwgetstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>unctrl<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>copywin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwhline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>ungetch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>curs_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>untouchwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>def_prog_mode<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>use_env<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>def_shell_mode<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vidattr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>del_curterm<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vidputs<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>delay_output<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>delch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinsch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vw_printw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>deleteln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinsnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vw_scanw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>delscreen<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinsstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vwprintw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>delwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwinstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>vwscanw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>derwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwprintw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>waddch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>doupdate<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwscanw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>waddchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>dupwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>mvwvline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>waddchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>echo<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>napms<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>waddnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>echochar<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>newpad<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>waddstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>endwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>newterm<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattr_get<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>erase<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>newwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattr_off<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>erasechar<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>nl<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattr_on<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>filter<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>nocbreak<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattr_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>flash<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>nodelay<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattroff<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>flushinp<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>noecho<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattron<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>getbkgd<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>nonl<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wattrset<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>getch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>noqiflush<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wbkgd<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>getnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>noraw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wbkgdset<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>getstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>notimeout<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wborder<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>getwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>overlay<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wchgat<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>halfdelay<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>overwrite<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wclear<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>has_colors<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>pair_content<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wclrtobot<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>has_ic<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>pechochar<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wclrtoeol<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>has_il<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>pnoutrefresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wcolor_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>hline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>prefresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wcursyncup<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>idcok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>printw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wdelch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>idlok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>putp<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wdeleteln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>immedok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>putwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wechochar<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>inch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>qiflush<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>werase<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>inchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>raw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wgetch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>inchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>redrawwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wgetnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>init_color<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>refresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wgetstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>init_pair<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>reset_prog_mode<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>whline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>initscr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>reset_shell_mode<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>innstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>resetty<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>insch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>restartterm<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>insdelln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>ripoffline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>insertln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>savetty<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winsch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>insnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scanw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winsdelln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>insstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scr_dump<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winsertln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>instr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scr_init<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winsnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>intrflush<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scr_restore<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winsstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>is_linetouched<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scr_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>winstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>is_wintouched<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scrl<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wmove<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>isendwin<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scroll<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wnoutrefresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>keyname<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>scrollok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wprintw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>keypad<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>set_curterm<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wredrawln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>killchar<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>set_term<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wrefresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>leaveok<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>setscrreg<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wscanw<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>longname<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>setupterm<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wscrl<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>meta<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_attr_set<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wsetscrreg<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>move<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_attroff<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wstandend<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvaddch<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_attron<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wstandout<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvaddchnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_attrset<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wsyncdown<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvaddchstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_clear<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wsyncup<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvaddnstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_color<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wtimeout<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvaddstr<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_init<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wtouchln<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvchgat<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_label<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>wvline<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
></TR
><TR
><TD
>mvcur<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>slk_noutrefresh<A
HREF="#STD.SUS.CURSES"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN31217"
></A
><P
><B
>Table A-8. libncurses Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>COLORS<A
HREF="#STD.SUS.CURSES"
></A
></TD
><TD
>LINES<A
HREF="#STD.SUS.CURSES"
></A
></TD
><TD
>curscr<A
HREF="#STD.SUS.CURSES"
></A
></TD
></TR
><TR
><TD
>COLOR_PAIRS<A
HREF="#STD.SUS.CURSES"
></A
></TD
><TD
>acs_map<A
HREF="#STD.SUS.CURSES"
></A
></TD
><TD
>stdscr<A
HREF="#STD.SUS.CURSES"
></A
></TD
></TR
><TR
><TD
>COLS<A
HREF="#STD.SUS.CURSES"
></A
></TD
><TD
>cur_term<A
HREF="#STD.SUS.CURSES"
></A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBPAM"
>A.6. libpam</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN31248"
></A
><P
><B
>Table A-9. libpam Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pam_acct_mgmt<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_fail_delay<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_setcred<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>pam_authenticate<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_get_item<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_start<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>pam_chauthtok<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_getenvlist<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_strerror<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>pam_close_session<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_open_session<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>pam_end<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pam_set_item<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBPTHREAD"
>A.7. libpthread</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN31296"
></A
><P
><B
>Table A-10. libpthread Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_pthread_cleanup_pop<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pthread_cond_wait()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_timedwrlock<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>_pthread_cleanup_push<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>pthread_condattr_destroy()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_tryrdlock()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>lseek64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>pthread_condattr_getpshared<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_trywrlock(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>open64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>pthread_condattr_init(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_unlock(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pread(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_condattr_setpshared<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_wrlock(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pread64(GLIBC_2.1)<A
HREF="#STD.LFS"
>[1]</A
></TD
><TD
>pthread_create(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlockattr_destroy(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_destroy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_detach(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlockattr_getpshared(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getdetachstate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_equal(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlockattr_init(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getguardsize(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_exit(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlockattr_setpshared(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getinheritsched(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_getconcurrency<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_self(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getschedparam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_getschedparam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_setcancelstate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getschedpolicy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_getspecific(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_setcanceltype(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getscope(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_join(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_setconcurrency<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstack<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_key_create()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_setschedparam()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstackaddr(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_key_delete(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_setschedprio<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstacksize(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_kill(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_setspecific(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_init(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutex_destroy(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_sigmask(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setdetachstate(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutex_init(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_testcancel(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setguardsize(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutex_lock(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pwrite(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setinheritsched(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutex_trylock(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pwrite64(GLIBC_2.0)<A
HREF="#STD.LFS"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedparam(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutex_unlock(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_close(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedpolicy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutexattr_destroy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_destroy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setscope(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutexattr_getpshared(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_getvalue(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setstack<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutexattr_gettype()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_init()<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setstackaddr(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutexattr_init(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_open(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_attr_setstacksize(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutexattr_setpshared(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_post(GLIBC_2.1)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_cancel(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_mutexattr_settype(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_timedwait(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_cond_broadcast(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_once(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_trywait(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_cond_destroy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_destroy(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_unlink(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_cond_init(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_init(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>sem_wait(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>pthread_cond_signal(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_rdlock(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>pthread_cond_timedwait(GLIBC_2.0)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>pthread_rwlock_timedrdlock<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBRT"
>A.8. librt</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.SUSV3"
>ISO POSIX (2003)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN31529"
></A
><P
><B
>Table A-11. librt Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>clock_getcpuclockid(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>clock_settime(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>timer_delete(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clock_getres(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shm_open(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>timer_getoverrun(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clock_gettime(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>shm_unlink(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>timer_gettime(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
><TR
><TD
>clock_nanosleep(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>timer_create(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
><TD
>timer_settime(GLIBC_2.2)<A
HREF="#STD.SUSV3"
>[1]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBUTIL"
>A.9. libutil</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN31568"
></A
><P
><B
>Table A-12. libutil Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>forkpty(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>login_tty(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>logwtmp(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>login(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>logout(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>openpty(GLIBC_2.0)<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBZ"
>A.10. libz</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN31593"
></A
><P
><B
>Table A-13. libz Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>adler32<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzclose<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gztell<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>compress<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzdopen<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzwrite<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>compress2<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzeof<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflate<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>compressBound<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzerror<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateEnd<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>crc32<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzflush<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateInit2_<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflate<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzgetc<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateInit_<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateBound<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzgets<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateReset<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateCopy<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzopen<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateSetDictionary<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateEnd<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzprintf<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateSync<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateInit2_<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzputc<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>inflateSyncPoint<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateInit_<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzputs<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>uncompress<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateParams<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzread<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>zError<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateReset<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzrewind<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>zlibVersion<A
HREF="#STD.LSB"
>[1]</A
></TD
></TR
><TR
><TD
>deflateSetDictionary<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzseek<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>get_crc_table<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>gzsetparams<A
HREF="#STD.LSB"
>[1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="FUTURE-DIRECTIONS-ANNEX"
></A
>Appendix B. Future Directions (Informative)</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="APPB-INTRO"
>B.1. Introduction</A
></H2
><P
>This appendix describes interfaces that are under development
and aimed at future releases of this specification. At this
stage, such interfaces are at best recommended practice, and do not
constitute normative requirements of this specification.
Applications may not assume that any system provides these
interfaces.</P
><P
>We encourage system implementors and ISVs to provide these interfaces, and to
provide feedback on their specification to 
<A
HREF="mailto://lsb-spec@freestandards.org"
TARGET="_top"
>lsbspec@freestandards.org</A
>. These interfaces may well be further
modified during the development process, and may be withdrawn if concensus
cannot be reached.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APPB-COMMANDS"
>B.2. Commands And Utilities</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#LSBINSTALL"
>lsbinstall</A
>&nbsp;--&nbsp;installation tool for various types of data</DT
></DL
></DIV
><H1
><A
NAME="LSBINSTALL"
></A
>lsbinstall</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31712"
></A
><H2
>Name</H2
>lsbinstall&nbsp;--&nbsp;installation tool for various types of data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31715"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/lib/lsb/lsbinstall</B
> [-c | --check | -r | --remove]  { -t type | --type=type }  [-p package | --package=package]  operand... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31730"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>lsbinstall</B
> utility may be used to install certain types
of files into system specific locations, repositories, or databases.
This command may be used during a
package post installation script to add package specific data to system wide
repositories.
A user may need appropriate privilege to invoke <B
CLASS="COMMAND"
>lsbinstall</B
>.</P
><P
>The operand (or operands) name an object of type <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> (see below)
that belongs to a package named <TT
CLASS="PARAMETER"
><I
>package</I
></TT
>. The combination
of package name, object type and object name should be unique amongst all objects installed
by <B
CLASS="COMMAND"
>lsbinstall</B
>. The <B
CLASS="COMMAND"
>lsbinstall</B
> utility may rename
an object if another package already owns an object of the same type 
with the same name. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If a namespace collision is detected by <B
CLASS="COMMAND"
>lsbinstall</B
>, it is unspecified
how the object is renamed, although typical implementations may prepend the package
name to the object in some way (e.g. <TT
CLASS="LITERAL"
>package.obj-name</TT
>).  The
<B
CLASS="COMMAND"
>lsbinstall</B
> utility may maintain a database of the mappings
it has performed during installation in order to ensure that the correct object is removed
during a subsequent removal operation.</P
></BLOCKQUOTE
></DIV
>
Scripts installed by <B
CLASS="COMMAND"
>lsbinstall</B
> should not
make use of the script name in order to decide on their functionality.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is appropriate for such a script to use the script name in
error messages, usage statements, etc. The only guarantee made by 
<B
CLASS="COMMAND"
>lsbinstall</B
> is
the effect that an installation (or removal) should have, not where a script is installed, or
how it is named.</P
></BLOCKQUOTE
></DIV
>
The <TT
CLASS="PARAMETER"
><I
>-p pkg</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--package=pkg</I
></TT
> is required
for all object types unless explicitly noted below.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
>
option is specified, <B
CLASS="COMMAND"
>lsbinstall</B
> should test to
see if there is an existing object of the type specified already installed.
If there is, <B
CLASS="COMMAND"
>lsbinstall</B
> should print a message to its
standard output and immediately exit with
a status of zero. If there is no object of the type and name specified
already installed, <B
CLASS="COMMAND"
>lsbinstall</B
> should exit with a
non-zero status and take no further action.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
>
is specified, the named object of the specified type should be removed or disabled from
the system, except as noted below. The behavior is unspecified if
the named object was not previously installed by
<B
CLASS="COMMAND"
>lsbinstall</B
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><B
CLASS="COMMAND"
>lsbinstall</B
> may rename objects during installation in order to prevent
name collisions where another package has already installed an object with the
given name. Using <B
CLASS="COMMAND"
>lsbinstall --remove</B
> will remove only the object belonging
to the named package, and not the object belonging to another package.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Also note that the intent of the <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> option is to prevent the
effect of the installed object; it should be sufficient to disable or comment out
the addition in some way, while leaving the content behind. It is not intended that
<TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> be required to be the exact reverse of installation.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31768"
></A
><H2
>Object Types</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>-t type</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--type=type</I
></TT
>
option should support at least the following types:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31774"
></A
><SPAN
STYLE="white-space: nowrap"
>profile</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>install a profile script into a system specific location.
There should be one operand, that names a profile shell script.
The behavior is unspecified if this name does not have the suffix
<TT
CLASS="LITERAL"
>.sh</TT
>.</P
><P
>The <B
CLASS="COMMAND"
>sh</B
> utility
should read and execute commands in its current execution environment 
from all such installed profile shell scripts 
when invoked as an interactive login shell,
or if the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> (the letter <I
CLASS="EMPHASIS"
>ell</I
>)
is specified (see <A
HREF="#CMD-SH-INVOKE"
>Shell Invocation</A
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31784"
></A
><SPAN
STYLE="white-space: nowrap"
>service</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>ensure a service name and number pair is known to the system service database.
When installing, there must be at least two operands.
The first operand should have the format <TT
CLASS="LITERAL"
>%d/%s</TT
> with the port
number and protocol values (e.g. <TT
CLASS="LITERAL"
>22/tcp</TT
>), and the second
operand should be the name of the service. Any subsequent operands 
provide aliases for this service.
The <TT
CLASS="PARAMETER"
><I
>-p pkg</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--package=pkg</I
></TT
>
option is not required for service objects, and is ignored if specified.
If any of the <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
> options
are specified, 
there should be a single operand identifying the 
port and protocol values (with the same format as above).</P
><P
>It should not be an error to attempt to add a service name to the
system service database if that service name already exists for the same
port and protocol combination. If the port and protocol combination was already present,
but the name unknown, the name should be added as an alias to the existing
entry. It should be an error to attempt to add a second entry for a given
service name and protocol, but where the port number differs from an existing
entry.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> is
specified, the system service database need not be updated to remove or disable
the named service.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31800"
></A
><SPAN
STYLE="white-space: nowrap"
>inet</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>add an entry to the system's network super daemon configuration.
If none of the <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
> options
are specified, 
the first operand should have the format:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>"%s:%s:%s:%s:%s:%s"</PRE
></TD
></TR
></TABLE
>
Otherwise, the first operand should 
have the format
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>"%s:%s"</PRE
></TD
></TR
></TABLE
>
The fields in the first operand have the following meaning, in order:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31811"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>svc_name</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of this service. If the name does not contain a 
<TT
CLASS="LITERAL"
>/</TT
>, this should match the name of an already installed
<TT
CLASS="LITERAL"
>service</TT
> (see also <TT
CLASS="FUNCTION"
>getservbyname()</TT
>).
If the name contains a <TT
CLASS="LITERAL"
>/</TT
> character,
the behavior is unspecified.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>This version of the LSB does not specify <TT
CLASS="FUNCTION"
>getrpcbyname()</TT
>
nor the existence or format of the <TT
CLASS="FILENAME"
>/etc/rpc</TT
> file. Therefore,
installation of RPC based services is not specified at this point.
A future version of this specification may require names containing a 
<TT
CLASS="LITERAL"
>/</TT
> character to be Remote Procedure Call based services.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31826"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>protocol</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of a protocol. The name should be one of those
listed in <TT
CLASS="FILENAME"
>/etc/protocols</TT
>.
If this attribute is not specified (i.e. a null value is passed), the system should
use an implementation defined default protocol.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31832"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>socket_type</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of the following values:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31838"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>stream</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the service will use a stream type socket.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31843"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>dgram</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the service will use a datagram type socket.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31848"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>seqpacket</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the service will use a sequenced packet type socket.</P
></TD
></TR
></TBODY
></TABLE
>
This field is not required for the
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-r</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> options.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31857"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>wait_flag</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the value of this attribute is <TT
CLASS="LITERAL"
>wait</TT
>,
once the service is started, no further requests for that
service will be handled until the service exits. If the
value is <TT
CLASS="LITERAL"
>nowait</TT
>, the network super daemon
should continue to handle further requests for the given
service while that service is running.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If the service has the <TT
CLASS="LITERAL"
>socket_type</TT
> attribute set
to <TT
CLASS="LITERAL"
>dgram</TT
>, the <TT
CLASS="LITERAL"
>wait_flag</TT
> attribute 
should be set to <TT
CLASS="LITERAL"
>wait</TT
>, since such services
do not have any distinction between the socket used for
listening and that used for accepting.</P
></BLOCKQUOTE
></DIV
>
This field is not required for the
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-r</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> options.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31874"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>user[.group]</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of a user from the user login database, optionally followed
by the name of a group from the group database. The service
started to handle this request should run with the privileges of 
the specified user and group. 
This field is not required for the
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-r</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> options.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31883"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>server [arg ...]</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of a program to run to handle the request, optionally followed
by any arguments required. The server name and each of its arguments
is separated by whitespace.
This field is not required for the
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-r</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
> options.</P
></TD
></TR
></TBODY
></TABLE
>
If the implementation supports additional controls over services
started through the inet super daemon, there may be additional,
implementation-defined, operands.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Systems that use the <B
CLASS="COMMAND"
>xinetd</B
> super daemon may support
additional controls such as IP address restrictions, logging requirements,
etc. The LSB does not require these additional controls.
However, it was believed to be
of sufficient benefit that implementations are granted permission to extend
this interface as required.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31896"
></A
><H2
>Examples</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>lsbinstall --package=myapp --type=profile myco.com-prod.sh</PRE
></TD
></TR
></TABLE
><P
>Install the profile shell script for <TT
CLASS="LITERAL"
>myco.com-prod.sh</TT
>, part of the
<TT
CLASS="LITERAL"
>myapp</TT
> package..</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>lsbinstall --package=myapp --check --type=profile myco.com-prod.sh</PRE
></TD
></TR
></TABLE
><P
>Test to see if the profile shell script for <TT
CLASS="LITERAL"
>myco.com-prod.sh</TT
>, as part of the
<TT
CLASS="LITERAL"
>myapp</TT
> package,
is installed correctly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31906"
></A
><H2
>Exit Status</H2
><P
>If the <TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--check</I
></TT
>
option is specified, <B
CLASS="COMMAND"
>lsbinstall</B
> should exit with a zero
status if an object of the specified type and name is already installed,
or non-zero otherwise.
Otherwise, <B
CLASS="COMMAND"
>lsbinstall</B
> should exit with a zero status
if the object with the specified type and name was successfully installed
(or removed if the <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--remove</I
></TT
>
option was specified), and non-zero if the installation (or removal)
failed. On failure, a diagnostic message should be printed to the
standard error file descriptor.</P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="GFDL"
></A
>Appendix C. GNU Free Documentation License (Informative)</H1
><P
>This specification is published under the terms of the 
GNU Free Documentation License, Version 1.1, March 2000</P
><A
NAME="AEN31918"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (C) 2000  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.</P
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-0"
>C.1. PREAMBLE</A
></H2
><P
>The purpose of this License is to make a manual, textbook,
    or other written document "free" in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it,
    with or without modifying it, either commercially or
    noncommercially.  Secondarily, this License preserves for the
    author and publisher a way to get credit for their work, while not
    being considered responsible for modifications made by
    others.</P
><P
>This License is a kind of "copyleft", which means that
    derivative works of the document must themselves be free in the
    same sense.  It complements the GNU General Public License, which
    is a copyleft license designed for free software.</P
><P
>We have designed this License in order to use it for manuals
    for free software, because free software needs free documentation:
    a free program should come with manuals providing the same
    freedoms that the software does.  But this License is not limited
    to software manuals; it can be used for any textual work,
    regardless of subject matter or whether it is published as a
    printed book.  We recommend this License principally for works
    whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-1"
>C.2. APPLICABILITY AND DEFINITIONS</A
></H2
><P
>This License applies to any manual or other work that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  The "Document",
    below, refers to any such manual or work.  Any member of the
    public is a licensee, and is addressed as "you".</P
><P
>A "Modified Version" of the Document means any work
    containing the Document or a portion of it, either copied
    verbatim, or with modifications and/or translated into another
    language.</P
><P
>A "Secondary Section" is a named appendix or a front-matter
    section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains
    nothing that could fall directly within that overall subject.
    (For example, if the Document is in part a textbook of
    mathematics, a Secondary Section may not explain any mathematics.)
    The relationship could be a matter of historical connection with
    the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding
    them.</P
><P
>The "Invariant Sections" are certain Secondary Sections
    whose titles are designated, as being those of Invariant Sections,
    in the notice that says that the Document is released under this
    License.</P
><P
>The "Cover Texts" are certain short passages of text that
    are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this
    License.</P
><P
>A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification
    is available to the general public, whose contents can be viewed
    and edited directly and straightforwardly with generic text
    editors or (for images composed of pixels) generic paint programs
    or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic
    translation to a variety of formats suitable for input to text
    formatters.  A copy made in an otherwise Transparent file format
    whose markup has been designed to thwart or discourage subsequent
    modification by readers is not Transparent.  A copy that is not
    "Transparent" is called "Opaque".</P
><P
>Examples of suitable formats for Transparent copies include
    plain ASCII without markup, Texinfo input format, LaTeX input
    format, SGML or XML using a publicly available DTD, and
    standard-conforming simple HTML designed for human modification.
    Opaque formats include PostScript, PDF, proprietary formats that
    can be read and edited only by proprietary word processors, SGML
    or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML produced by some word
    processors for output purposes only.</P
><P
>The "Title Page" means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly,
    the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such,
    "Title Page" means the text near the most prominent appearance of
    the work's title, preceding the beginning of the body of the
    text.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-2"
>C.3. VERBATIM COPYING</A
></H2
><P
>You may copy and distribute the Document in any medium,
    either commercially or noncommercially, provided that this
    License, the copyright notices, and the license notice saying this
    License applies to the Document are reproduced in all copies, and
    that you add no other conditions whatsoever to those of this
    License.  You may not use technical measures to obstruct or
    control the reading or further copying of the copies you make or
    distribute.  However, you may accept compensation in exchange for
    copies.  If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</P
><P
>You may also lend copies, under the same conditions stated
    above, and you may publicly display copies.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-3"
>C.4. COPYING IN QUANTITY</A
></H2
><P
>If you publish printed copies of the Document numbering more
    than 100, and the Document's license notice requires Cover Texts,
    you must enclose the copies in covers that carry, clearly and
    legibly, all these Cover Texts: Front-Cover Texts on the front
    cover, and Back-Cover Texts on the back cover.  Both covers must
    also clearly and legibly identify you as the publisher of these
    copies.  The front cover must present the full title with all
    words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes
    limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim
    copying in other respects.</P
><P
>If the required texts for either cover are too voluminous to
    fit legibly, you should put the first ones listed (as many as fit
    reasonably) on the actual cover, and continue the rest onto
    adjacent pages.</P
><P
>If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a
    machine-readable Transparent copy along with each Opaque copy, or
    state in or with each Opaque copy a publicly-accessible
    computer-network location containing a complete Transparent copy
    of the Document, free of added material, which the general
    network-using public has access to download anonymously at no
    charge using public-standard network protocols.  If you use the
    latter option, you must take reasonably prudent steps, when you
    begin distribution of Opaque copies in quantity, to ensure that
    this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you
    distribute an Opaque copy (directly or through your agents or
    retailers) of that edition to the public.</P
><P
>It is requested, but not required, that you contact the
    authors of the Document well before redistributing any large
    number of copies, to give them a chance to provide you with an
    updated version of the Document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-4"
>C.5. MODIFICATIONS</A
></H2
><P
>You may copy and distribute a Modified Version of the
    Document under the conditions of sections 2 and 3 above, provided
    that you release the Modified Version under precisely this
    License, with the Modified Version filling the role of the
    Document, thus licensing distribution and modification of the
    Modified Version to whoever possesses a copy of it.  In addition,
    you must do these things in the Modified Version:</P
><P
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page
      (and on the covers, if any) a title distinct from that of the
      Document, and from those of previous versions (which should, if
      there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if
      the original publisher of that version gives permission.</P
></LI
><LI
><P
>List on the Title Page,
      as authors, one or more persons or entities responsible for
      authorship of the modifications in the Modified Version,
      together with at least five of the principal authors of the
      Document (all of its principal authors, if it has less than
      five).</P
></LI
><LI
><P
>State on the Title page
      the name of the publisher of the Modified Version, as the
      publisher.</P
></LI
><LI
><P
>Preserve all the
      copyright notices of the Document.</P
></LI
><LI
><P
>Add an appropriate
      copyright notice for your modifications adjacent to the other
      copyright notices.</P
></LI
><LI
><P
>Include, immediately
      after the copyright notices, a license notice giving the public
      permission to use the Modified Version under the terms of this
      License, in the form shown in the Addendum below.</P
></LI
><LI
><P
>Preserve in that license
      notice the full lists of Invariant Sections and required Cover
      Texts given in the Document's license notice.</P
></LI
><LI
><P
>Include an unaltered
      copy of this License.</P
></LI
><LI
><P
>Preserve the section
      entitled "History", and its title, and add to it an item stating
      at least the title, year, new authors, and publisher of the
      Modified Version as given on the Title Page.  If there is no
      section entitled "History" in the Document, create one stating
      the title, year, authors, and publisher of the Document as given
      on its Title Page, then add an item describing the Modified
      Version as stated in the previous sentence.</P
></LI
><LI
><P
>Preserve the network
      location, if any, given in the Document for public access to a
      Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was
      based on.  These may be placed in the "History" section.  You
      may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission.</P
></LI
><LI
><P
>In any section entitled
      "Acknowledgements" or "Dedications", preserve the section's
      title, and preserve in the section all the substance and tone of
      each of the contributor acknowledgements and/or dedications
      given therein.</P
></LI
><LI
><P
>Preserve all the
      Invariant Sections of the Document, unaltered in their text and
      in their titles.  Section numbers or the equivalent are not
      considered part of the section titles.</P
></LI
><LI
><P
>Delete any section
      entitled "Endorsements".  Such a section may not be included in
      the Modified Version.</P
></LI
><LI
><P
>Do not retitle any
      existing section as "Endorsements" or to conflict in title with
      any Invariant Section.</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections
    or appendices that qualify as Secondary Sections and contain no
    material copied from the Document, you may at your option
    designate some or all of these sections as invariant.  To do this,
    add their titles to the list of Invariant Sections in the Modified
    Version's license notice.  These titles must be distinct from any
    other section titles.</P
><P
>You may add a section entitled "Endorsements", provided it
    contains nothing but endorsements of your Modified Version by
    various parties--for example, statements of peer review or that
    the text has been approved by an organization as the authoritative
    definition of a standard.</P
><P
>You may add a passage of up to five words as a Front-Cover
    Text, and a passage of up to 25 words as a Back-Cover Text, to the
    end of the list of Cover Texts in the Modified Version.  Only one
    passage of Front-Cover Text and one of Back-Cover Text may be
    added by (or through arrangements made by) any one entity.  If the
    Document already includes a cover text for the same cover,
    previously added by you or by arrangement made by the same entity
    you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous
    publisher that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by
    this License give permission to use their names for publicity for
    or to assert or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-5"
>C.6. COMBINING DOCUMENTS</A
></H2
><P
>You may combine the Document with other documents released
    under this License, under the terms defined in section 4 above for
    modified versions, provided that you include in the combination
    all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your
    combined work in its license notice.</P
><P
>The combined work need only contain one copy of this
    License, and multiple identical Invariant Sections may be replaced
    with a single copy.  If there are multiple Invariant Sections with
    the same name but different contents, make the title of each such
    section unique by adding at the end of it, in parentheses, the
    name of the original author or publisher of that section if known,
    or else a unique number.  Make the same adjustment to the section
    titles in the list of Invariant Sections in the license notice of
    the combined work.</P
><P
>In the combination, you must combine any sections entitled
    "History" in the various original documents, forming one section
    entitled "History"; likewise combine any sections entitled
    "Acknowledgements", and any sections entitled "Dedications".  You
    must delete all sections entitled "Endorsements."</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-6"
>C.7. COLLECTIONS OF DOCUMENTS</A
></H2
><P
>You may make a collection consisting of the Document and
    other documents released under this License, and replace the
    individual copies of this License in the various documents with a
    single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of
    the documents in all other respects.</P
><P
>You may extract a single document from such a collection,
    and distribute it individually under this License, provided you
    insert a copy of this License into the extracted document, and
    follow this License in all other respects regarding verbatim
    copying of that document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-7"
>C.8. AGGREGATION WITH INDEPENDENT WORKS</A
></H2
><P
>A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of
    a storage or distribution medium, does not as a whole count as a
    Modified Version of the Document, provided no compilation
    copyright is claimed for the compilation.  Such a compilation is
    called an "aggregate", and this License does not apply to the
    other self-contained works thus compiled with the Document, on
    account of their being thus compiled, if they are not themselves
    derivative works of the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to
    these copies of the Document, then if the Document is less than
    one quarter of the entire aggregate, the Document's Cover Texts
    may be placed on covers that surround only the Document within the
    aggregate.  Otherwise they must appear on covers around the whole
    aggregate.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-8"
>C.9. TRANSLATION</A
></H2
><P
>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section
    4.  Replacing Invariant Sections with translations requires
    special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition
    to the original versions of these Invariant Sections.  You may
    include a translation of this License provided that you also
    include the original English version of this License.  In case of
    a disagreement between the translation and the original English
    version of this License, the original English version will
    prevail.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-9"
>C.10. TERMINATION</A
></H2
><P
>You may not copy, modify, sublicense, or distribute the
    Document except as expressly provided for under this License.  Any
    other attempt to copy, modify, sublicense or distribute the
    Document is void, and will automatically terminate your rights
    under this License.  However, parties who have received copies, or
    rights, from you under this License will not have their licenses
    terminated so long as such parties remain in full
    compliance.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-10"
>C.11. FUTURE REVISIONS OF THIS LICENSE</A
></H2
><P
>The Free Software Foundation may publish new, revised
    versions of the GNU Free Documentation License from time to time.
    Such new versions will be similar in spirit to the present
    version, but may differ in detail to address new problems or
    concerns.  See <A
HREF="http://www.gnu.org/copyleft/"
TARGET="_top"
>http://www.gnu.org/copyleft/</A
>.</P
><P
>Each version of the License is given a distinguishing
    version number.  If the Document specifies that a particular
    numbered version of this License "or any later version" applies to
    it, you have the option of following the terms and conditions
    either of that specified version or of any later version that has
    been published (not as a draft) by the Free Software Foundation.
    If the Document does not specify a version number of this License,
    you may choose any version ever published (not as a draft) by the
    Free Software Foundation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-11"
>C.12. How to use this License for your documents</A
></H2
><P
>To use this License in a document you have written, include
    a copy of the License in the document and put the following
    copyright and license notices just after the title page:</P
><A
NAME="AEN32008"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</P
></BLOCKQUOTE
><P
>If you have no Invariant Sections, write "with no Invariant
    Sections" instead of saying which ones are invariant.  If you have
    no Front-Cover Texts, write "no Front-Cover Texts" instead of
    "Front-Cover Texts being LIST"; likewise for Back-Cover
    Texts.</P
><P
>If your document contains nontrivial examples of program
    code, we recommend releasing these examples in parallel under your
    choice of free software license, such as the GNU General Public
    License, to permit their use in free software.</P
></DIV
></DIV
></DIV
></BODY
></HTML
>